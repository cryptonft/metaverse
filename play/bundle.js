/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/aabb-3d/index.js":
/*!***************************************!*\
  !*** ./node_modules/aabb-3d/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = AABB\r\n\r\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/aabb-3d/node_modules/gl-vec3/index.js\")\r\n\r\nfunction AABB(pos, vec) {\r\n\r\n  if(!(this instanceof AABB)) {\r\n    return new AABB(pos, vec)\r\n  }\r\n\r\n  var pos2 = vec3.create()\r\n  vec3.add(pos2, pos, vec)\r\n \r\n  this.base = vec3.min(vec3.create(), pos, pos2)\r\n  this.vec = vec3.clone(vec)\r\n  this.max = vec3.max(vec3.create(), pos, pos2)\r\n\r\n  this.mag = vec3.length(this.vec)\r\n\r\n}\r\n\r\nvar cons = AABB\r\n  , proto = cons.prototype\r\n\r\nproto.width = function() {\r\n  return this.vec[0]\r\n}\r\n\r\nproto.height = function() {\r\n  return this.vec[1]\r\n}\r\n\r\nproto.depth = function() {\r\n  return this.vec[2]\r\n}\r\n\r\nproto.x0 = function() {\r\n  return this.base[0]\r\n}\r\n\r\nproto.y0 = function() {\r\n  return this.base[1]\r\n}\r\n\r\nproto.z0 = function() {\r\n  return this.base[2]\r\n}\r\n\r\nproto.x1 = function() {\r\n  return this.max[0]\r\n}\r\n\r\nproto.y1 = function() {\r\n  return this.max[1]\r\n}\r\n\r\nproto.z1 = function() {\r\n  return this.max[2]\r\n}\r\n\r\nproto.translate = function(by) {\r\n  vec3.add(this.max, this.max, by)\r\n  vec3.add(this.base, this.base, by)\r\n  return this\r\n}\r\n\r\nproto.setPosition = function(pos) {\r\n  vec3.add(this.max, pos, this.vec)\r\n  vec3.copy(this.base, pos)\r\n  return this\r\n}\r\n\r\nproto.expand = function(aabb) {\r\n  var max = vec3.create()\r\n    , min = vec3.create()\r\n\r\n  vec3.max(max, aabb.max, this.max)\r\n  vec3.min(min, aabb.base, this.base)\r\n  vec3.subtract(max, max, min)\r\n\r\n  return new AABB(min, max)\r\n}\r\n\r\nproto.intersects = function(aabb) {\r\n  if(aabb.base[0] > this.max[0]) return false\r\n  if(aabb.base[1] > this.max[1]) return false\r\n  if(aabb.base[2] > this.max[2]) return false\r\n  if(aabb.max[0] < this.base[0]) return false\r\n  if(aabb.max[1] < this.base[1]) return false\r\n  if(aabb.max[2] < this.base[2]) return false\r\n\r\n  return true\r\n}\r\n\r\nproto.touches = function(aabb) {\r\n\r\n  var intersection = this.union(aabb);\r\n\r\n  return (intersection !== null) &&\r\n         ((intersection.width() == 0) ||\r\n         (intersection.height() == 0) || \r\n         (intersection.depth() == 0))\r\n\r\n}\r\n\r\nproto.union = function(aabb) {\r\n  if(!this.intersects(aabb)) return null\r\n\r\n  var base_x = Math.max(aabb.base[0], this.base[0])\r\n    , base_y = Math.max(aabb.base[1], this.base[1])\r\n    , base_z = Math.max(aabb.base[2], this.base[2])\r\n    , max_x = Math.min(aabb.max[0], this.max[0])\r\n    , max_y = Math.min(aabb.max[1], this.max[1])\r\n    , max_z = Math.min(aabb.max[2], this.max[2])\r\n\r\n  return new AABB([base_x, base_y, base_z], [max_x - base_x, max_y - base_y, max_z - base_z])\r\n}\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/index.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/add.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/add.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/add.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/angle.js":
/*!************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/angle.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = angle\n\nvar fromValues = __webpack_require__(/*! ./fromValues */ \"./node_modules/aabb-3d/node_modules/gl-vec3/fromValues.js\")\nvar normalize = __webpack_require__(/*! ./normalize */ \"./node_modules/aabb-3d/node_modules/gl-vec3/normalize.js\")\nvar dot = __webpack_require__(/*! ./dot */ \"./node_modules/aabb-3d/node_modules/gl-vec3/dot.js\")\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/angle.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/ceil.js":
/*!***********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/ceil.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ceil\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0])\n  out[1] = Math.ceil(a[1])\n  out[2] = Math.ceil(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/ceil.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/clone.js":
/*!************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/clone.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = clone;\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n    var out = new Float32Array(3)\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/clone.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/copy.js":
/*!***********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/copy.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/copy.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/create.js":
/*!*************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/create.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = create;\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n    var out = new Float32Array(3)\n    out[0] = 0\n    out[1] = 0\n    out[2] = 0\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/create.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/cross.js":
/*!************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/cross.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/cross.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/dist.js":
/*!***********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/dist.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./distance */ \"./node_modules/aabb-3d/node_modules/gl-vec3/distance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/dist.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/distance.js":
/*!***************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/distance.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = distance;\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/distance.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/div.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/div.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./divide */ \"./node_modules/aabb-3d/node_modules/gl-vec3/divide.js\")\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/div.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/divide.js":
/*!*************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/divide.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = divide;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n    out[0] = a[0] / b[0]\n    out[1] = a[1] / b[1]\n    out[2] = a[2] / b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/divide.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/dot.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/dot.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/dot.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/epsilon.js":
/*!**************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/epsilon.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 0.000001\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/epsilon.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/equals.js":
/*!*************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/equals.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = equals\n\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/aabb-3d/node_modules/gl-vec3/epsilon.js\")\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/equals.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/exactEquals.js":
/*!******************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/exactEquals.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exactEquals\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/exactEquals.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/floor.js":
/*!************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/floor.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = floor\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0])\n  out[1] = Math.floor(a[1])\n  out[2] = Math.floor(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/floor.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/forEach.js":
/*!**************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/forEach.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = forEach;\n\nvar vec = __webpack_require__(/*! ./create */ \"./node_modules/aabb-3d/node_modules/gl-vec3/create.js\")()\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nfunction forEach(a, stride, offset, count, fn, arg) {\n        var i, l\n        if(!stride) {\n            stride = 3\n        }\n\n        if(!offset) {\n            offset = 0\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length)\n        } else {\n            l = a.length\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i] \n            vec[1] = a[i+1] \n            vec[2] = a[i+2]\n            fn(vec, vec, arg)\n            a[i] = vec[0] \n            a[i+1] = vec[1] \n            a[i+2] = vec[2]\n        }\n        \n        return a\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/forEach.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/fromValues.js":
/*!*****************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/fromValues.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/fromValues.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/index.js":
/*!************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  EPSILON: __webpack_require__(/*! ./epsilon */ \"./node_modules/aabb-3d/node_modules/gl-vec3/epsilon.js\")\n  , create: __webpack_require__(/*! ./create */ \"./node_modules/aabb-3d/node_modules/gl-vec3/create.js\")\n  , clone: __webpack_require__(/*! ./clone */ \"./node_modules/aabb-3d/node_modules/gl-vec3/clone.js\")\n  , angle: __webpack_require__(/*! ./angle */ \"./node_modules/aabb-3d/node_modules/gl-vec3/angle.js\")\n  , fromValues: __webpack_require__(/*! ./fromValues */ \"./node_modules/aabb-3d/node_modules/gl-vec3/fromValues.js\")\n  , copy: __webpack_require__(/*! ./copy */ \"./node_modules/aabb-3d/node_modules/gl-vec3/copy.js\")\n  , set: __webpack_require__(/*! ./set */ \"./node_modules/aabb-3d/node_modules/gl-vec3/set.js\")\n  , equals: __webpack_require__(/*! ./equals */ \"./node_modules/aabb-3d/node_modules/gl-vec3/equals.js\")\n  , exactEquals: __webpack_require__(/*! ./exactEquals */ \"./node_modules/aabb-3d/node_modules/gl-vec3/exactEquals.js\")\n  , add: __webpack_require__(/*! ./add */ \"./node_modules/aabb-3d/node_modules/gl-vec3/add.js\")\n  , subtract: __webpack_require__(/*! ./subtract */ \"./node_modules/aabb-3d/node_modules/gl-vec3/subtract.js\")\n  , sub: __webpack_require__(/*! ./sub */ \"./node_modules/aabb-3d/node_modules/gl-vec3/sub.js\")\n  , multiply: __webpack_require__(/*! ./multiply */ \"./node_modules/aabb-3d/node_modules/gl-vec3/multiply.js\")\n  , mul: __webpack_require__(/*! ./mul */ \"./node_modules/aabb-3d/node_modules/gl-vec3/mul.js\")\n  , divide: __webpack_require__(/*! ./divide */ \"./node_modules/aabb-3d/node_modules/gl-vec3/divide.js\")\n  , div: __webpack_require__(/*! ./div */ \"./node_modules/aabb-3d/node_modules/gl-vec3/div.js\")\n  , min: __webpack_require__(/*! ./min */ \"./node_modules/aabb-3d/node_modules/gl-vec3/min.js\")\n  , max: __webpack_require__(/*! ./max */ \"./node_modules/aabb-3d/node_modules/gl-vec3/max.js\")\n  , floor: __webpack_require__(/*! ./floor */ \"./node_modules/aabb-3d/node_modules/gl-vec3/floor.js\")\n  , ceil: __webpack_require__(/*! ./ceil */ \"./node_modules/aabb-3d/node_modules/gl-vec3/ceil.js\")\n  , round: __webpack_require__(/*! ./round */ \"./node_modules/aabb-3d/node_modules/gl-vec3/round.js\")\n  , scale: __webpack_require__(/*! ./scale */ \"./node_modules/aabb-3d/node_modules/gl-vec3/scale.js\")\n  , scaleAndAdd: __webpack_require__(/*! ./scaleAndAdd */ \"./node_modules/aabb-3d/node_modules/gl-vec3/scaleAndAdd.js\")\n  , distance: __webpack_require__(/*! ./distance */ \"./node_modules/aabb-3d/node_modules/gl-vec3/distance.js\")\n  , dist: __webpack_require__(/*! ./dist */ \"./node_modules/aabb-3d/node_modules/gl-vec3/dist.js\")\n  , squaredDistance: __webpack_require__(/*! ./squaredDistance */ \"./node_modules/aabb-3d/node_modules/gl-vec3/squaredDistance.js\")\n  , sqrDist: __webpack_require__(/*! ./sqrDist */ \"./node_modules/aabb-3d/node_modules/gl-vec3/sqrDist.js\")\n  , length: __webpack_require__(/*! ./length */ \"./node_modules/aabb-3d/node_modules/gl-vec3/length.js\")\n  , len: __webpack_require__(/*! ./len */ \"./node_modules/aabb-3d/node_modules/gl-vec3/len.js\")\n  , squaredLength: __webpack_require__(/*! ./squaredLength */ \"./node_modules/aabb-3d/node_modules/gl-vec3/squaredLength.js\")\n  , sqrLen: __webpack_require__(/*! ./sqrLen */ \"./node_modules/aabb-3d/node_modules/gl-vec3/sqrLen.js\")\n  , negate: __webpack_require__(/*! ./negate */ \"./node_modules/aabb-3d/node_modules/gl-vec3/negate.js\")\n  , inverse: __webpack_require__(/*! ./inverse */ \"./node_modules/aabb-3d/node_modules/gl-vec3/inverse.js\")\n  , normalize: __webpack_require__(/*! ./normalize */ \"./node_modules/aabb-3d/node_modules/gl-vec3/normalize.js\")\n  , dot: __webpack_require__(/*! ./dot */ \"./node_modules/aabb-3d/node_modules/gl-vec3/dot.js\")\n  , cross: __webpack_require__(/*! ./cross */ \"./node_modules/aabb-3d/node_modules/gl-vec3/cross.js\")\n  , lerp: __webpack_require__(/*! ./lerp */ \"./node_modules/aabb-3d/node_modules/gl-vec3/lerp.js\")\n  , random: __webpack_require__(/*! ./random */ \"./node_modules/aabb-3d/node_modules/gl-vec3/random.js\")\n  , transformMat4: __webpack_require__(/*! ./transformMat4 */ \"./node_modules/aabb-3d/node_modules/gl-vec3/transformMat4.js\")\n  , transformMat3: __webpack_require__(/*! ./transformMat3 */ \"./node_modules/aabb-3d/node_modules/gl-vec3/transformMat3.js\")\n  , transformQuat: __webpack_require__(/*! ./transformQuat */ \"./node_modules/aabb-3d/node_modules/gl-vec3/transformQuat.js\")\n  , rotateX: __webpack_require__(/*! ./rotateX */ \"./node_modules/aabb-3d/node_modules/gl-vec3/rotateX.js\")\n  , rotateY: __webpack_require__(/*! ./rotateY */ \"./node_modules/aabb-3d/node_modules/gl-vec3/rotateY.js\")\n  , rotateZ: __webpack_require__(/*! ./rotateZ */ \"./node_modules/aabb-3d/node_modules/gl-vec3/rotateZ.js\")\n  , forEach: __webpack_require__(/*! ./forEach */ \"./node_modules/aabb-3d/node_modules/gl-vec3/forEach.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/index.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/inverse.js":
/*!**************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/inverse.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = inverse;\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0]\n  out[1] = 1.0 / a[1]\n  out[2] = 1.0 / a[2]\n  return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/inverse.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/len.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/len.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./length */ \"./node_modules/aabb-3d/node_modules/gl-vec3/length.js\")\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/len.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/length.js":
/*!*************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/length.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = length;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/length.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/lerp.js":
/*!***********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/lerp.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = lerp;\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2]\n    out[0] = ax + t * (b[0] - ax)\n    out[1] = ay + t * (b[1] - ay)\n    out[2] = az + t * (b[2] - az)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/lerp.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/max.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/max.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = max;\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n    out[0] = Math.max(a[0], b[0])\n    out[1] = Math.max(a[1], b[1])\n    out[2] = Math.max(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/max.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/min.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/min.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = min;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n    out[0] = Math.min(a[0], b[0])\n    out[1] = Math.min(a[1], b[1])\n    out[2] = Math.min(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/min.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/mul.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/mul.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./multiply */ \"./node_modules/aabb-3d/node_modules/gl-vec3/multiply.js\")\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/mul.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/multiply.js":
/*!***************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/multiply.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = multiply;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n    out[0] = a[0] * b[0]\n    out[1] = a[1] * b[1]\n    out[2] = a[2] * b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/multiply.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/negate.js":
/*!*************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/negate.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = negate;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n    out[0] = -a[0]\n    out[1] = -a[1]\n    out[2] = -a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/negate.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/normalize.js":
/*!****************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/normalize.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/normalize.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/random.js":
/*!*************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/random.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = random;\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n    scale = scale || 1.0\n\n    var r = Math.random() * 2.0 * Math.PI\n    var z = (Math.random() * 2.0) - 1.0\n    var zScale = Math.sqrt(1.0-z*z) * scale\n\n    out[0] = Math.cos(r) * zScale\n    out[1] = Math.sin(r) * zScale\n    out[2] = z * scale\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/random.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/rotateX.js":
/*!**************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/rotateX.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/rotateX.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/rotateY.js":
/*!**************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/rotateY.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/rotateY.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/rotateZ.js":
/*!**************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/rotateZ.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/rotateZ.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/round.js":
/*!************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/round.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = round\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0])\n  out[1] = Math.round(a[1])\n  out[2] = Math.round(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/round.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/scale.js":
/*!************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/scale.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scale;\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n    out[0] = a[0] * b\n    out[1] = a[1] * b\n    out[2] = a[2] * b\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/scale.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/scaleAndAdd.js":
/*!******************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/scaleAndAdd.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/scaleAndAdd.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/set.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/set.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/set.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/sqrDist.js":
/*!**************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/sqrDist.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredDistance */ \"./node_modules/aabb-3d/node_modules/gl-vec3/squaredDistance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/sqrDist.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/sqrLen.js":
/*!*************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/sqrLen.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredLength */ \"./node_modules/aabb-3d/node_modules/gl-vec3/squaredLength.js\")\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/sqrLen.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/squaredDistance.js":
/*!**********************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/squaredDistance.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredDistance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/squaredDistance.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/squaredLength.js":
/*!********************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/squaredLength.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredLength;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/squaredLength.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/sub.js":
/*!**********************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/sub.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./subtract */ \"./node_modules/aabb-3d/node_modules/gl-vec3/subtract.js\")\n\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/sub.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/subtract.js":
/*!***************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/subtract.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = subtract;\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n    out[0] = a[0] - b[0]\n    out[1] = a[1] - b[1]\n    out[2] = a[2] - b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/subtract.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/transformMat3.js":
/*!********************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/transformMat3.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat3;\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n    var x = a[0], y = a[1], z = a[2]\n    out[0] = x * m[0] + y * m[3] + z * m[6]\n    out[1] = x * m[1] + y * m[4] + z * m[7]\n    out[2] = x * m[2] + y * m[5] + z * m[8]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/transformMat3.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/transformMat4.js":
/*!********************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/transformMat4.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/transformMat4.js?");

/***/ }),

/***/ "./node_modules/aabb-3d/node_modules/gl-vec3/transformQuat.js":
/*!********************************************************************!*\
  !*** ./node_modules/aabb-3d/node_modules/gl-vec3/transformQuat.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformQuat;\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/aabb-3d/node_modules/gl-vec3/transformQuat.js?");

/***/ }),

/***/ "./node_modules/babylon-atlas/index.js":
/*!*********************************************!*\
  !*** ./node_modules/babylon-atlas/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global BABYLON */\n\nmodule.exports = Atlas\n\nvar loader = __webpack_require__(/*! load-json-xhr */ \"./node_modules/load-json-xhr/index.js\")\n\n\n\n\n/*\n*  Atlas constructor - keeps the json data and a base texture\n*/\n\n\nfunction Atlas(imgURL, jsonURL, scene, BAB, noMip, sampling) {\n\tif (!(this instanceof Atlas)) {\n\t\treturn new Atlas(imgURL, jsonURL, scene, BAB, noMip, sampling)\n\t}\n\n\tthis._ready = false\n\tthis._scene = scene\n\tthis._BABYLON = BAB\n\tthis._data = null\n\n\tthis.frames = []\n\n\tvar dataReady = false\n\tvar texReady = false\n\tvar self = this\n\n\t// json loader and event\n\tif (typeof jsonURL === 'string') {\n\t\tloader(jsonURL, function (err, data) {\n\t\t\tif (err) throw err\n\t\t\tself._data = data\n\t\t\tinitData(self)\n\t\t})\n\t} else if (typeof jsonURL === 'object') {\n\t\t// if passed an object, assume it's the JSON\n\t\tself._data = jsonURL\n\t\tinitData(self)\n\t}\n\n\t// texture loader and event\n\tthis._baseTexture = new BAB.Texture(imgURL, scene, noMip, true, sampling)\n\n\t// atlas will almost always need alpha\n\tthis._baseTexture.hasAlpha = true\n}\n\n// called once json + image are both loaded\n/* Expects json like:\n\t{\"frames\":{\n\t\t\"frame_001\": {\"frame\": {\"x\":0, \"y\":32,\"w\":22,\"h\":18} },\n\t\t\"frame_002\": {\"frame\": {\"x\":53,\"y\":0, \"w\":22,\"h\":21} }\n\t}}\n*/\nfunction initData(self) {\n\tvar list = Object.keys(self._data.frames)\n\tfor (var i = 0; i < list.length; i++) {\n\t\tself.frames.push(list[i])\n\t}\n\tself._ready = true\n}\n\n\n\n\n\n/*\n*\n*    API\n* \n*/\n\n// return a plane-like sprite mesh showing the given atlas frame\n\nAtlas.prototype.makeSpriteMesh = function (frame, material) {\n\tvar BAB = this._BABYLON\n\tif (!frame) frame = 0\n\n\t// make a material unless one was passed in\n\tif (!material) {\n\t\tmaterial = new BAB.StandardMaterial('spriteMat', this._scene)\n\t\tmaterial.specularColor = new BAB.Color3(0, 0, 0)\n\t\tmaterial.emissiveColor = new BAB.Color3(1, 1, 1)\n\t\tmaterial.backFaceCulling = false\n\t}\n\n\t// basic plane mesh\n\tvar mesh = this._BABYLON.Mesh.CreatePlane('atlas sprite', 1, this._scene, true)\n\tmesh.material = material\n\tmesh.material.diffuseTexture = this._baseTexture\n\tmesh._currentAtlasFrame = null\n\t\n\t// set to correct frame\n\tthis.setMeshFrame(mesh, frame)\n\n\treturn mesh\n}\n\n\n\n// public accessor to set a created mesh's frame\nAtlas.prototype.setMeshFrame = function (mesh, frame) {\n\tif (frame === mesh._currentAtlasFrame) return\n\t\n\t// defer if needed\n\tif (!this._ready) {\n\t\tvar self = this\n\t\tsetTimeout(function () { self.setMeshFrame(mesh, frame) }, 10)\n\t\treturn\n\t} else {\n\t\tvar frameDat = getFrameData(this, frame)\n\t\tsetMeshUVs(this, mesh, frameDat)\n\t\tmesh._currentAtlasFrame = frame\n\t}\n}\n\n\n\n// Create a texture with the right uv settings for a given frame\n\nAtlas.prototype.makeSpriteTexture = function (frame) {\n\tvar tex = this._baseTexture.clone()\n\tthis.setTextureFrame(tex, frame)\n\treturn tex\n}\n\n\n\n// Set a created texture's uv settings to the given frame\n\nAtlas.prototype.setTextureFrame = function (tex, frame) {\n\t// defer if needed\n\tif (!this._ready) {\n\t\tvar self = this\n\t\tsetTimeout(function () { self.setTextureFrame(tex, frame) }, 10)\n\t\treturn\n\t} else {\n\t\tvar frameDat = getFrameData(this, frame)\n\t\tsetTextureUVs(this, tex, frameDat)\n\t}\n}\n\n\n\n\n// dispose method - disposes babylon objects\n\nAtlas.prototype.dispose = function () {\n\tthis._baseTexture.dispose()\n\tthis._data = null\n\tthis._scene = null\n\tthis._BABYLON = null\n\tthis.frames.length = 0\n}\n\n\n\n\n\n/*\n* \n*      Internals\n* \n*/\n\n\n// interpret string or number frame value, and return frame data from JSON\n\nfunction getFrameData(self, frame) {\n\tvar framestr = ''\n\tif (typeof frame === 'number') {\n\t\tframestr = self.frames[frame]\n\t} else {\n\t\tframestr = frame\n\t}\n\tvar dat = self._data.frames[framestr]\n\tif (!dat) {\n\t\tthrow new Error('babylon-atlas: frame \"' + framestr + '\" not found in atlas')\n\t}\n\n\treturn dat\n}\n\n\n\n\n// This is where the magic happens - for a given frame's x/y/width/height, \n// set the plane mesh's UVs to display that part of the texture\n\nfunction setMeshUVs(self, mesh, frameDat) {\n\tvar sw = self._data.meta.size.w\n\tvar sh = self._data.meta.size.h\n\tvar x = frameDat.frame.x / sw\n\tvar y = frameDat.frame.y / sh\n\tvar w = frameDat.frame.w / sw\n\tvar h = frameDat.frame.h / sh\n\n\tvar uvs = mesh.getVerticesData(BABYLON.VertexBuffer.UVKind)\n\tuvs[0] = x\n\tuvs[1] = 1 - y - h\n\tuvs[2] = x + w\n\tuvs[3] = 1 - y - h\n\tuvs[4] = x + w\n\tuvs[5] = 1 - y\n\tuvs[6] = x\n\tuvs[7] = 1 - y\n\tmesh.updateVerticesData(BABYLON.VertexBuffer.UVKind, uvs)\n}\n\n\n// Same thing but for textures\n\nfunction setTextureUVs(self, tex, frameDat) {\n\tvar sw = self._data.meta.size.w\n\tvar sh = self._data.meta.size.h\n\tvar x = frameDat.frame.x\n\tvar y = frameDat.frame.y\n\tvar w = frameDat.frame.w\n\tvar h = frameDat.frame.h\n\t\n\t// in Babylon 2.2 and below:\n\t// tex.uScale = w/sw\n\t// tex.vScale = h/sh\n\t// tex.uOffset = ( sw /2 - x)/w - 0.5\n\t// tex.vOffset = (-sh/2 + y)/h + 0.5\n\t\n\t// Babylon 2.3 and above:\n\ttex.uScale = w / sw\n\ttex.vScale = h / sh\n\ttex.uOffset = x / sw\n\ttex.vOffset = (sh - y - h) / sh\n}\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/babylon-atlas/index.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack:///./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/binary-search-bounds/search-bounds.js":
/*!************************************************************!*\
  !*** ./node_modules/binary-search-bounds/search-bounds.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction compileSearch(funcName, predicate, reversed, extraArgs, useNdarray, earlyOut) {\n  var code = [\n    \"function \", funcName, \"(a,l,h,\", extraArgs.join(\",\"),  \"){\",\nearlyOut ? \"\" : \"var i=\", (reversed ? \"l-1\" : \"h+1\"),\n\";while(l<=h){\\\nvar m=(l+h)>>>1,x=a\", useNdarray ? \".get(m)\" : \"[m]\"]\n  if(earlyOut) {\n    if(predicate.indexOf(\"c\") < 0) {\n      code.push(\";if(x===y){return m}else if(x<=y){\")\n    } else {\n      code.push(\";var p=c(x,y);if(p===0){return m}else if(p<=0){\")\n    }\n  } else {\n    code.push(\";if(\", predicate, \"){i=m;\")\n  }\n  if(reversed) {\n    code.push(\"l=m+1}else{h=m-1}\")\n  } else {\n    code.push(\"h=m-1}else{l=m+1}\")\n  }\n  code.push(\"}\")\n  if(earlyOut) {\n    code.push(\"return -1};\")\n  } else {\n    code.push(\"return i};\")\n  }\n  return code.join(\"\")\n}\n\nfunction compileBoundsSearch(predicate, reversed, suffix, earlyOut) {\n  var result = new Function([\n  compileSearch(\"A\", \"x\" + predicate + \"y\", reversed, [\"y\"], false, earlyOut),\n  compileSearch(\"B\", \"x\" + predicate + \"y\", reversed, [\"y\"], true, earlyOut),\n  compileSearch(\"P\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], false, earlyOut),\n  compileSearch(\"Q\", \"c(x,y)\" + predicate + \"0\", reversed, [\"y\", \"c\"], true, earlyOut),\n\"function dispatchBsearch\", suffix, \"(a,y,c,l,h){\\\nif(a.shape){\\\nif(typeof(c)==='function'){\\\nreturn Q(a,(l===undefined)?0:l|0,(h===undefined)?a.shape[0]-1:h|0,y,c)\\\n}else{\\\nreturn B(a,(c===undefined)?0:c|0,(l===undefined)?a.shape[0]-1:l|0,y)\\\n}}else{\\\nif(typeof(c)==='function'){\\\nreturn P(a,(l===undefined)?0:l|0,(h===undefined)?a.length-1:h|0,y,c)\\\n}else{\\\nreturn A(a,(c===undefined)?0:c|0,(l===undefined)?a.length-1:l|0,y)\\\n}}}\\\nreturn dispatchBsearch\", suffix].join(\"\"))\n  return result()\n}\n\nmodule.exports = {\n  ge: compileBoundsSearch(\">=\", false, \"GE\"),\n  gt: compileBoundsSearch(\">\", false, \"GT\"),\n  lt: compileBoundsSearch(\"<\", true, \"LT\"),\n  le: compileBoundsSearch(\"<=\", true, \"LE\"),\n  eq: compileBoundsSearch(\"-\", true, \"EQ\", true)\n}\n\n\n//# sourceURL=webpack:///./node_modules/binary-search-bounds/search-bounds.js?");

/***/ }),

/***/ "./node_modules/bit-twiddle/twiddle.js":
/*!*********************************************!*\
  !*** ./node_modules/bit-twiddle/twiddle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/**\n * Bit twiddling hacks for JavaScript.\n *\n * Author: Mikola Lysenko\n *\n * Ported from Stanford bit twiddling hack library:\n *    http://graphics.stanford.edu/~seander/bithacks.html\n */\n\n \"use restrict\";\n\n//Number of bits in an integer\nvar INT_BITS = 32;\n\n//Constants\nexports.INT_BITS  = INT_BITS;\nexports.INT_MAX   =  0x7fffffff;\nexports.INT_MIN   = -1<<(INT_BITS-1);\n\n//Returns -1, 0, +1 depending on sign of x\nexports.sign = function(v) {\n  return (v > 0) - (v < 0);\n}\n\n//Computes absolute value of integer\nexports.abs = function(v) {\n  var mask = v >> (INT_BITS-1);\n  return (v ^ mask) - mask;\n}\n\n//Computes minimum of integers x and y\nexports.min = function(x, y) {\n  return y ^ ((x ^ y) & -(x < y));\n}\n\n//Computes maximum of integers x and y\nexports.max = function(x, y) {\n  return x ^ ((x ^ y) & -(x < y));\n}\n\n//Checks if a number is a power of two\nexports.isPow2 = function(v) {\n  return !(v & (v-1)) && (!!v);\n}\n\n//Computes log base 2 of v\nexports.log2 = function(v) {\n  var r, shift;\n  r =     (v > 0xFFFF) << 4; v >>>= r;\n  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;\n  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;\n  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;\n  return r | (v >> 1);\n}\n\n//Computes log base 10 of v\nexports.log10 = function(v) {\n  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :\n          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :\n          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;\n}\n\n//Counts number of bits\nexports.popCount = function(v) {\n  v = v - ((v >>> 1) & 0x55555555);\n  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);\n  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\n}\n\n//Counts number of trailing zeros\nfunction countTrailingZeros(v) {\n  var c = 32;\n  v &= -v;\n  if (v) c--;\n  if (v & 0x0000FFFF) c -= 16;\n  if (v & 0x00FF00FF) c -= 8;\n  if (v & 0x0F0F0F0F) c -= 4;\n  if (v & 0x33333333) c -= 2;\n  if (v & 0x55555555) c -= 1;\n  return c;\n}\nexports.countTrailingZeros = countTrailingZeros;\n\n//Rounds to next power of 2\nexports.nextPow2 = function(v) {\n  v += v === 0;\n  --v;\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v + 1;\n}\n\n//Rounds down to previous power of 2\nexports.prevPow2 = function(v) {\n  v |= v >>> 1;\n  v |= v >>> 2;\n  v |= v >>> 4;\n  v |= v >>> 8;\n  v |= v >>> 16;\n  return v - (v>>>1);\n}\n\n//Computes parity of word\nexports.parity = function(v) {\n  v ^= v >>> 16;\n  v ^= v >>> 8;\n  v ^= v >>> 4;\n  v &= 0xf;\n  return (0x6996 >>> v) & 1;\n}\n\nvar REVERSE_TABLE = new Array(256);\n\n(function(tab) {\n  for(var i=0; i<256; ++i) {\n    var v = i, r = i, s = 7;\n    for (v >>>= 1; v; v >>>= 1) {\n      r <<= 1;\n      r |= v & 1;\n      --s;\n    }\n    tab[i] = (r << s) & 0xff;\n  }\n})(REVERSE_TABLE);\n\n//Reverse bits in a 32 bit word\nexports.reverse = function(v) {\n  return  (REVERSE_TABLE[ v         & 0xff] << 24) |\n          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |\n          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |\n           REVERSE_TABLE[(v >>> 24) & 0xff];\n}\n\n//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes\nexports.interleave2 = function(x, y) {\n  x &= 0xFFFF;\n  x = (x | (x << 8)) & 0x00FF00FF;\n  x = (x | (x << 4)) & 0x0F0F0F0F;\n  x = (x | (x << 2)) & 0x33333333;\n  x = (x | (x << 1)) & 0x55555555;\n\n  y &= 0xFFFF;\n  y = (y | (y << 8)) & 0x00FF00FF;\n  y = (y | (y << 4)) & 0x0F0F0F0F;\n  y = (y | (y << 2)) & 0x33333333;\n  y = (y | (y << 1)) & 0x55555555;\n\n  return x | (y << 1);\n}\n\n//Extracts the nth interleaved component\nexports.deinterleave2 = function(v, n) {\n  v = (v >>> n) & 0x55555555;\n  v = (v | (v >>> 1))  & 0x33333333;\n  v = (v | (v >>> 2))  & 0x0F0F0F0F;\n  v = (v | (v >>> 4))  & 0x00FF00FF;\n  v = (v | (v >>> 16)) & 0x000FFFF;\n  return (v << 16) >> 16;\n}\n\n\n//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes\nexports.interleave3 = function(x, y, z) {\n  x &= 0x3FF;\n  x  = (x | (x<<16)) & 4278190335;\n  x  = (x | (x<<8))  & 251719695;\n  x  = (x | (x<<4))  & 3272356035;\n  x  = (x | (x<<2))  & 1227133513;\n\n  y &= 0x3FF;\n  y  = (y | (y<<16)) & 4278190335;\n  y  = (y | (y<<8))  & 251719695;\n  y  = (y | (y<<4))  & 3272356035;\n  y  = (y | (y<<2))  & 1227133513;\n  x |= (y << 1);\n  \n  z &= 0x3FF;\n  z  = (z | (z<<16)) & 4278190335;\n  z  = (z | (z<<8))  & 251719695;\n  z  = (z | (z<<4))  & 3272356035;\n  z  = (z | (z<<2))  & 1227133513;\n  \n  return x | (z << 2);\n}\n\n//Extracts nth interleaved component of a 3-tuple\nexports.deinterleave3 = function(v, n) {\n  v = (v >>> n)       & 1227133513;\n  v = (v | (v>>>2))   & 3272356035;\n  v = (v | (v>>>4))   & 251719695;\n  v = (v | (v>>>8))   & 4278190335;\n  v = (v | (v>>>16))  & 0x3FF;\n  return (v<<22)>>22;\n}\n\n//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)\nexports.nextCombination = function(v) {\n  var t = v | (v - 1);\n  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/bit-twiddle/twiddle.js?");

/***/ }),

/***/ "./node_modules/box-intersect/index.js":
/*!*********************************************!*\
  !*** ./node_modules/box-intersect/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = boxIntersectWrapper\n\nvar pool = __webpack_require__(/*! typedarray-pool */ \"./node_modules/typedarray-pool/pool.js\")\nvar sweep = __webpack_require__(/*! ./lib/sweep */ \"./node_modules/box-intersect/lib/sweep.js\")\nvar boxIntersectIter = __webpack_require__(/*! ./lib/intersect */ \"./node_modules/box-intersect/lib/intersect.js\")\n\nfunction boxEmpty(d, box) {\n  for(var j=0; j<d; ++j) {\n    if(!(box[j] <= box[j+d])) {\n      return true\n    }\n  }\n  return false\n}\n\n//Unpack boxes into a flat typed array, remove empty boxes\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0\n  var count = 0\n  for(var i=0, n=boxes.length; i<n; ++i) {\n    var b = boxes[i]\n    if(boxEmpty(d, b)) {\n      continue\n    }\n    for(var j=0; j<2*d; ++j) {\n      data[ptr++] = b[j]\n    }\n    ids[count++] = i\n  }\n  return count\n}\n\n//Perform type conversions, check bounds\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length\n  var m = blue.length\n\n  //If either array is empty, then we can skip this whole thing\n  if(n <= 0 || m <= 0) {\n    return\n  }\n\n  //Compute dimension, if it is 0 then we skip\n  var d = (red[0].length)>>>1\n  if(d <= 0) {\n    return\n  }\n\n  var retval\n\n  //Convert red boxes\n  var redList  = pool.mallocDouble(2*d*n)\n  var redIds   = pool.mallocInt32(n)\n  n = convertBoxes(red, d, redList, redIds)\n\n  if(n > 0) {\n    if(d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n)\n      retval = sweep.sweepComplete(\n        d, visit, \n        0, n, redList, redIds,\n        0, n, redList, redIds)\n    } else {\n\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2*d*m)\n      var blueIds  = pool.mallocInt32(m)\n      m = convertBoxes(blue, d, blueList, blueIds)\n\n      if(m > 0) {\n        sweep.init(n+m)\n\n        if(d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(\n            d, visit, \n            0, n, redList,  redIds,\n            0, m, blueList, blueIds)\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(\n            d, visit,    full,\n            n, redList,  redIds,\n            m, blueList, blueIds)\n        }\n\n        pool.free(blueList)\n        pool.free(blueIds)\n      }\n    }\n\n    pool.free(redList)\n    pool.free(redIds)\n  }\n\n  return retval\n}\n\n\nvar RESULT\n\nfunction appendItem(i,j) {\n  RESULT.push([i,j])\n}\n\nfunction intersectFullArray(x) {\n  RESULT = []\n  boxIntersect(x, x, appendItem, true)\n  return RESULT\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = []\n  boxIntersect(x, y, appendItem, false)\n  return RESULT\n}\n\n//User-friendly wrapper, handle full input and no-visitor cases\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result\n  switch(arguments.length) {\n    case 1:\n      return intersectFullArray(arg0)\n    case 2:\n      if(typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true)\n      } else {\n        return intersectBipartiteArray(arg0, arg1)\n      }\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false)\n    default:\n      throw new Error('box-intersect: Invalid arguments')\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/box-intersect/index.js?");

/***/ }),

/***/ "./node_modules/box-intersect/lib/brute.js":
/*!*************************************************!*\
  !*** ./node_modules/box-intersect/lib/brute.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar DIMENSION   = 'd'\nvar AXIS        = 'ax'\nvar VISIT       = 'vv'\nvar FLIP        = 'fp'\n\nvar ELEM_SIZE   = 'es'\n\nvar RED_START   = 'rs'\nvar RED_END     = 're'\nvar RED_BOXES   = 'rb'\nvar RED_INDEX   = 'ri'\nvar RED_PTR     = 'rp'\n\nvar BLUE_START  = 'bs'\nvar BLUE_END    = 'be'\nvar BLUE_BOXES  = 'bb'\nvar BLUE_INDEX  = 'bi'\nvar BLUE_PTR    = 'bp'\n\nvar RETVAL      = 'rv'\n\nvar INNER_LABEL = 'Q'\n\nvar ARGS = [\n  DIMENSION,\n  AXIS,\n  VISIT,\n  RED_START,\n  RED_END,\n  RED_BOXES,\n  RED_INDEX,\n  BLUE_START,\n  BLUE_END,\n  BLUE_BOXES,\n  BLUE_INDEX\n]\n\nfunction generateBruteForce(redMajor, flip, full) {\n  var funcName = 'bruteForce' + \n    (redMajor ? 'Red' : 'Blue') + \n    (flip ? 'Flip' : '') +\n    (full ? 'Full' : '')\n\n  var code = ['function ', funcName, '(', ARGS.join(), '){',\n    'var ', ELEM_SIZE, '=2*', DIMENSION, ';']\n\n  var redLoop = \n    'for(var i=' + RED_START + ',' + RED_PTR + '=' + ELEM_SIZE + '*' + RED_START + ';' +\n        'i<' + RED_END +';' +\n        '++i,' + RED_PTR + '+=' + ELEM_SIZE + '){' +\n        'var x0=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '],' +\n            'x1=' + RED_BOXES + '[' + AXIS + '+' + RED_PTR + '+' + DIMENSION + '],' +\n            'xi=' + RED_INDEX + '[i];'\n\n  var blueLoop = \n    'for(var j=' + BLUE_START + ',' + BLUE_PTR + '=' + ELEM_SIZE + '*' + BLUE_START + ';' +\n        'j<' + BLUE_END + ';' +\n        '++j,' + BLUE_PTR + '+=' + ELEM_SIZE + '){' +\n        'var y0=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '],' +\n            (full ? 'y1=' + BLUE_BOXES + '[' + AXIS + '+' + BLUE_PTR + '+' + DIMENSION + '],' : '') +\n            'yi=' + BLUE_INDEX + '[j];'\n\n  if(redMajor) {\n    code.push(redLoop, INNER_LABEL, ':', blueLoop)\n  } else {\n    code.push(blueLoop, INNER_LABEL, ':', redLoop)\n  }\n\n  if(full) {\n    code.push('if(y1<x0||x1<y0)continue;')\n  } else if(flip) {\n    code.push('if(y0<=x0||x1<y0)continue;')\n  } else {\n    code.push('if(y0<x0||x1<y0)continue;')\n  }\n\n  code.push('for(var k='+AXIS+'+1;k<'+DIMENSION+';++k){'+\n    'var r0='+RED_BOXES+'[k+'+RED_PTR+'],'+\n        'r1='+RED_BOXES+'[k+'+DIMENSION+'+'+RED_PTR+'],'+\n        'b0='+BLUE_BOXES+'[k+'+BLUE_PTR+'],'+\n        'b1='+BLUE_BOXES+'[k+'+DIMENSION+'+'+BLUE_PTR+'];'+\n      'if(r1<b0||b1<r0)continue ' + INNER_LABEL + ';}' +\n      'var ' + RETVAL + '=' + VISIT + '(')\n\n  if(flip) {\n    code.push('yi,xi')\n  } else {\n    code.push('xi,yi')\n  }\n\n  code.push(');if(' + RETVAL + '!==void 0)return ' + RETVAL + ';}}}')\n\n  return {\n    name: funcName, \n    code: code.join('')\n  }\n}\n\nfunction bruteForcePlanner(full) {\n  var funcName = 'bruteForce' + (full ? 'Full' : 'Partial')\n  var prefix = []\n  var fargs = ARGS.slice()\n  if(!full) {\n    fargs.splice(3, 0, FLIP)\n  }\n\n  var code = ['function ' + funcName + '(' + fargs.join() + '){']\n\n  function invoke(redMajor, flip) {\n    var res = generateBruteForce(redMajor, flip, full)\n    prefix.push(res.code)\n    code.push('return ' + res.name + '(' + ARGS.join() + ');')\n  }\n\n  code.push('if(' + RED_END + '-' + RED_START + '>' +\n                    BLUE_END + '-' + BLUE_START + '){')\n\n  if(full) {\n    invoke(true, false)\n    code.push('}else{')\n    invoke(false, false)\n  } else {\n    code.push('if(' + FLIP + '){')\n    invoke(true, true)\n    code.push('}else{')\n    invoke(true, false)\n    code.push('}}else{if(' + FLIP + '){')\n    invoke(false, true)\n    code.push('}else{')\n    invoke(false, false)\n    code.push('}')\n  }\n  code.push('}}return ' + funcName)\n\n  var codeStr = prefix.join('') + code.join('')\n  var proc = new Function(codeStr)\n  return proc()\n}\n\n\nexports.partial = bruteForcePlanner(false)\nexports.full    = bruteForcePlanner(true)\n\n//# sourceURL=webpack:///./node_modules/box-intersect/lib/brute.js?");

/***/ }),

/***/ "./node_modules/box-intersect/lib/intersect.js":
/*!*****************************************************!*\
  !*** ./node_modules/box-intersect/lib/intersect.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = boxIntersectIter\n\nvar pool = __webpack_require__(/*! typedarray-pool */ \"./node_modules/typedarray-pool/pool.js\")\nvar bits = __webpack_require__(/*! bit-twiddle */ \"./node_modules/bit-twiddle/twiddle.js\")\nvar bruteForce = __webpack_require__(/*! ./brute */ \"./node_modules/box-intersect/lib/brute.js\")\nvar bruteForcePartial = bruteForce.partial\nvar bruteForceFull = bruteForce.full\nvar sweep = __webpack_require__(/*! ./sweep */ \"./node_modules/box-intersect/lib/sweep.js\")\nvar findMedian = __webpack_require__(/*! ./median */ \"./node_modules/box-intersect/lib/median.js\")\nvar genPartition = __webpack_require__(/*! ./partition */ \"./node_modules/box-intersect/lib/partition.js\")\n\n//Twiddle parameters\nvar BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search\nvar SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan\nvar SCAN_COMPLETE_CUTOFF  = (1<<22)  \n\n//Partition functions\nvar partitionInteriorContainsInterval = genPartition(\n  '!(lo>=p0)&&!(p1>=hi)', \n  ['p0', 'p1'])\n\nvar partitionStartEqual = genPartition(\n  'lo===p0',\n  ['p0'])\n\nvar partitionStartLessThan = genPartition(\n  'lo<p0',\n  ['p0'])\n\nvar partitionEndLessThanEqual = genPartition(\n  'hi<=p0',\n  ['p0'])\n\nvar partitionContainsPoint = genPartition(\n  'lo<=p0&&p0<=hi',\n  ['p0'])\n\nvar partitionContainsPointProper = genPartition(\n  'lo<p0&&p0<=hi',\n  ['p0'])\n\n//Frame size for iterative loop\nvar IFRAME_SIZE = 6\nvar DFRAME_SIZE = 2\n\n//Data for box statck\nvar INIT_CAPACITY = 1024\nvar BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)\nvar BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)\n\n//Initialize iterative loop queue\nfunction iterInit(d, count) {\n  var levels = (8 * bits.log2(count+1) * (d+1))|0\n  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)\n  if(BOX_ISTACK.length < maxInts) {\n    pool.free(BOX_ISTACK)\n    BOX_ISTACK = pool.mallocInt32(maxInts)\n  }\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)\n  if(BOX_DSTACK.length < maxDoubles) {\n    pool.free(BOX_DSTACK)\n    BOX_DSTACK = pool.mallocDouble(maxDoubles)\n  }\n}\n\n//Append item to queue\nfunction iterPush(ptr,\n  axis, \n  redStart, redEnd, \n  blueStart, blueEnd, \n  state, \n  lo, hi) {\n\n  var iptr = IFRAME_SIZE * ptr\n  BOX_ISTACK[iptr]   = axis\n  BOX_ISTACK[iptr+1] = redStart\n  BOX_ISTACK[iptr+2] = redEnd\n  BOX_ISTACK[iptr+3] = blueStart\n  BOX_ISTACK[iptr+4] = blueEnd\n  BOX_ISTACK[iptr+5] = state\n\n  var dptr = DFRAME_SIZE * ptr\n  BOX_DSTACK[dptr]   = lo\n  BOX_DSTACK[dptr+1] = hi\n}\n\n//Special case:  Intersect single point with list of intervals\nfunction onePointPartial(\n  d, axis, visit, flip,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    if(flip && blueX === r0) {\n      continue\n    }\n    var redId = redIndex[i]\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval\n    if(flip) {\n      retval = visit(blueId, redId)\n    } else {\n      retval = visit(redId, blueId)\n    }\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//Special case:  Intersect one point with list of intervals\nfunction onePointFull(\n  d, axis, visit,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var redId = redIndex[i]\n    if(redId === blueId) {\n      continue\n    }\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval = visit(redId, blueId)\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//The main box intersection routine\nfunction boxIntersectIter(\n  d, visit, initFull,\n  xSize, xBoxes, xIndex,\n  ySize, yBoxes, yIndex) {\n\n  //Reserve memory for stack\n  iterInit(d, xSize + ySize)\n\n  var top  = 0\n  var elemSize = 2 * d\n  var retval\n\n  iterPush(top++,\n      0,\n      0, xSize,\n      0, ySize,\n      initFull ? 16 : 0, \n      -Infinity, Infinity)\n  if(!initFull) {\n    iterPush(top++,\n      0,\n      0, ySize,\n      0, xSize,\n      1, \n      -Infinity, Infinity)\n  }\n\n  while(top > 0) {\n    top  -= 1\n\n    var iptr = top * IFRAME_SIZE\n    var axis      = BOX_ISTACK[iptr]\n    var redStart  = BOX_ISTACK[iptr+1]\n    var redEnd    = BOX_ISTACK[iptr+2]\n    var blueStart = BOX_ISTACK[iptr+3]\n    var blueEnd   = BOX_ISTACK[iptr+4]\n    var state     = BOX_ISTACK[iptr+5]\n\n    var dptr = top * DFRAME_SIZE\n    var lo        = BOX_DSTACK[dptr]\n    var hi        = BOX_DSTACK[dptr+1]\n\n    //Unpack state info\n    var flip      = (state & 1)\n    var full      = !!(state & 16)\n\n    //Unpack indices\n    var red       = xBoxes\n    var redIndex  = xIndex\n    var blue      = yBoxes\n    var blueIndex = yIndex\n    if(flip) {\n      red         = yBoxes\n      redIndex    = yIndex\n      blue        = xBoxes\n      blueIndex   = xIndex\n    }\n\n    if(state & 2) {\n      redEnd = partitionStartLessThan(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        hi)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    if(state & 4) {\n      redStart = partitionEndLessThanEqual(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        lo)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    \n    var redCount  = redEnd  - redStart\n    var blueCount = blueEnd - blueStart\n\n    if(full) {\n      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n        retval = sweep.scanComplete(\n          d, axis, visit, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    } else {\n      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n        //If input small, then use brute force\n        retval = bruteForcePartial(\n            d, axis, visit, flip,\n            redStart,  redEnd,  red,  redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      } else if(d * redCount * blueCount < SCAN_CUTOFF) {\n        //If input medium sized, then use sweep and prune\n        retval = sweep.scanBipartite(\n          d, axis, visit, flip, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    }\n    \n    //First, find all red intervals whose interior contains (lo,hi)\n    var red0 = partitionInteriorContainsInterval(\n      d, axis, \n      redStart, redEnd, red, redIndex,\n      lo, hi)\n\n    //Lower dimensional case\n    if(redStart < red0) {\n\n      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n        //Special case for small inputs: use brute force\n        retval = bruteForceFull(\n          d, axis+1, visit,\n          redStart, red0, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(axis === d-2) {\n        if(flip) {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            blueStart, blueEnd, blue, blueIndex,\n            redStart, red0, red, redIndex)\n        } else {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            redStart, red0, red, redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else {\n        iterPush(top++,\n          axis+1,\n          redStart, red0,\n          blueStart, blueEnd,\n          flip,\n          -Infinity, Infinity)\n        iterPush(top++,\n          axis+1,\n          blueStart, blueEnd,\n          redStart, red0,\n          flip^1,\n          -Infinity, Infinity)\n      }\n    }\n\n    //Divide and conquer phase\n    if(red0 < redEnd) {\n\n      //Cut blue into 3 parts:\n      //\n      //  Points < mid point\n      //  Points = mid point\n      //  Points > mid point\n      //\n      var blue0 = findMedian(\n        d, axis, \n        blueStart, blueEnd, blue, blueIndex)\n      var mid = blue[elemSize * blue0 + axis]\n      var blue1 = partitionStartEqual(\n        d, axis,\n        blue0, blueEnd, blue, blueIndex,\n        mid)\n\n      //Right case\n      if(blue1 < blueEnd) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blue1, blueEnd,\n          (flip|4) + (full ? 16 : 0),\n          mid, hi)\n      }\n\n      //Left case\n      if(blueStart < blue0) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blueStart, blue0,\n          (flip|2) + (full ? 16 : 0),\n          lo, mid)\n      }\n\n      //Center case (the hard part)\n      if(blue0 + 1 === blue1) {\n        //Optimization: Range with exactly 1 point, use a brute force scan\n        if(full) {\n          retval = onePointFull(\n            d, axis, visit,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        } else {\n          retval = onePointPartial(\n            d, axis, visit, flip,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(blue0 < blue1) {\n        var red1\n        if(full) {\n          //If full intersection, need to handle special case\n          red1 = partitionContainsPoint(\n            d, axis,\n            red0, redEnd, red, redIndex,\n            mid)\n          if(red0 < red1) {\n            var redX = partitionStartEqual(\n              d, axis,\n              red0, red1, red, redIndex,\n              mid)\n            if(axis === d-2) {\n              //Degenerate sweep intersection:\n              //  [red0, redX] with [blue0, blue1]\n              if(red0 < redX) {\n                retval = sweep.sweepComplete(\n                  d, visit,\n                  red0, redX, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n\n              //Normal sweep intersection:\n              //  [redX, red1] with [blue0, blue1]\n              if(redX < red1) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  redX, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n            } else {\n              if(red0 < redX) {\n                iterPush(top++,\n                  axis+1,\n                  red0, redX,\n                  blue0, blue1,\n                  16,\n                  -Infinity, Infinity)\n              }\n              if(redX < red1) {\n                iterPush(top++,\n                  axis+1,\n                  redX, red1,\n                  blue0, blue1,\n                  0,\n                  -Infinity, Infinity)\n                iterPush(top++,\n                  axis+1,\n                  blue0, blue1,\n                  redX, red1,\n                  1,\n                  -Infinity, Infinity)\n              }\n            }\n          }\n        } else {\n          if(flip) {\n            red1 = partitionContainsPointProper(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          } else {\n            red1 = partitionContainsPoint(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          }\n          if(red0 < red1) {\n            if(axis === d-2) {\n              if(flip) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  blue0, blue1, blue, blueIndex,\n                  red0, red1, red, redIndex)\n              } else {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  red0, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n              }\n            } else {\n              iterPush(top++,\n                axis+1,\n                red0, red1,\n                blue0, blue1,\n                flip,\n                -Infinity, Infinity)\n              iterPush(top++,\n                axis+1,\n                blue0, blue1,\n                red0, red1,\n                flip^1,\n                -Infinity, Infinity)\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/box-intersect/lib/intersect.js?");

/***/ }),

/***/ "./node_modules/box-intersect/lib/median.js":
/*!**************************************************!*\
  !*** ./node_modules/box-intersect/lib/median.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = findMedian\n\nvar genPartition = __webpack_require__(/*! ./partition */ \"./node_modules/box-intersect/lib/partition.js\")\n\nvar partitionStartLessThan = genPartition('lo<p0', ['p0'])\n\nvar PARTITION_THRESHOLD = 8   //Cut off for using insertion sort in findMedian\n\n//Base case for median finding:  Use insertion sort\nfunction insertionSort(d, axis, start, end, boxes, ids) {\n  var elemSize = 2 * d\n  var boxPtr = elemSize * (start+1) + axis\n  for(var i=start+1; i<end; ++i, boxPtr+=elemSize) {\n    var x = boxes[boxPtr]\n    for(var j=i, ptr=elemSize*(i-1); \n        j>start && boxes[ptr+axis] > x; \n        --j, ptr-=elemSize) {\n      //Swap\n      var aPtr = ptr\n      var bPtr = ptr+elemSize\n      for(var k=0; k<elemSize; ++k, ++aPtr, ++bPtr) {\n        var y = boxes[aPtr]\n        boxes[aPtr] = boxes[bPtr]\n        boxes[bPtr] = y\n      }\n      var tmp = ids[j]\n      ids[j] = ids[j-1]\n      ids[j-1] = tmp\n    }\n  }\n}\n\n//Find median using quick select algorithm\n//  takes O(n) time with high probability\nfunction findMedian(d, axis, start, end, boxes, ids) {\n  if(end <= start+1) {\n    return start\n  }\n\n  var lo       = start\n  var hi       = end\n  var mid      = ((end + start) >>> 1)\n  var elemSize = 2*d\n  var pivot    = mid\n  var value    = boxes[elemSize*mid+axis]\n  \n  while(lo < hi) {\n    if(hi - lo < PARTITION_THRESHOLD) {\n      insertionSort(d, axis, lo, hi, boxes, ids)\n      value = boxes[elemSize*mid+axis]\n      break\n    }\n    \n    //Select pivot using median-of-3\n    var count  = hi - lo\n    var pivot0 = (Math.random()*count+lo)|0\n    var value0 = boxes[elemSize*pivot0 + axis]\n    var pivot1 = (Math.random()*count+lo)|0\n    var value1 = boxes[elemSize*pivot1 + axis]\n    var pivot2 = (Math.random()*count+lo)|0\n    var value2 = boxes[elemSize*pivot2 + axis]\n    if(value0 <= value1) {\n      if(value2 >= value1) {\n        pivot = pivot1\n        value = value1\n      } else if(value0 >= value2) {\n        pivot = pivot0\n        value = value0\n      } else {\n        pivot = pivot2\n        value = value2\n      }\n    } else {\n      if(value1 >= value2) {\n        pivot = pivot1\n        value = value1\n      } else if(value2 >= value0) {\n        pivot = pivot0\n        value = value0\n      } else {\n        pivot = pivot2\n        value = value2\n      }\n    }\n\n    //Swap pivot to end of array\n    var aPtr = elemSize * (hi-1)\n    var bPtr = elemSize * pivot\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr]\n      boxes[aPtr] = boxes[bPtr]\n      boxes[bPtr] = x\n    }\n    var y = ids[hi-1]\n    ids[hi-1] = ids[pivot]\n    ids[pivot] = y\n\n    //Partition using pivot\n    pivot = partitionStartLessThan(\n      d, axis, \n      lo, hi-1, boxes, ids,\n      value)\n\n    //Swap pivot back\n    var aPtr = elemSize * (hi-1)\n    var bPtr = elemSize * pivot\n    for(var i=0; i<elemSize; ++i, ++aPtr, ++bPtr) {\n      var x = boxes[aPtr]\n      boxes[aPtr] = boxes[bPtr]\n      boxes[bPtr] = x\n    }\n    var y = ids[hi-1]\n    ids[hi-1] = ids[pivot]\n    ids[pivot] = y\n\n    //Swap pivot to last pivot\n    if(mid < pivot) {\n      hi = pivot-1\n      while(lo < hi && \n        boxes[elemSize*(hi-1)+axis] === value) {\n        hi -= 1\n      }\n      hi += 1\n    } else if(pivot < mid) {\n      lo = pivot + 1\n      while(lo < hi &&\n        boxes[elemSize*lo+axis] === value) {\n        lo += 1\n      }\n    } else {\n      break\n    }\n  }\n\n  //Make sure pivot is at start\n  return partitionStartLessThan(\n    d, axis, \n    start, mid, boxes, ids,\n    boxes[elemSize*mid+axis])\n}\n\n//# sourceURL=webpack:///./node_modules/box-intersect/lib/median.js?");

/***/ }),

/***/ "./node_modules/box-intersect/lib/partition.js":
/*!*****************************************************!*\
  !*** ./node_modules/box-intersect/lib/partition.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = genPartition\n\nvar code = 'for(var j=2*a,k=j*c,l=k,m=c,n=b,o=a+b,p=c;d>p;++p,k+=j){var _;if($)if(m===p)m+=1,l+=j;else{for(var s=0;j>s;++s){var t=e[k+s];e[k+s]=e[l],e[l++]=t}var u=f[p];f[p]=f[m],f[m++]=u}}return m'\n\nfunction genPartition(predicate, args) {\n  var fargs ='abcdef'.split('').concat(args)\n  var reads = []\n  if(predicate.indexOf('lo') >= 0) {\n    reads.push('lo=e[k+n]')\n  }\n  if(predicate.indexOf('hi') >= 0) {\n    reads.push('hi=e[k+o]')\n  }\n  fargs.push(\n    code.replace('_', reads.join())\n        .replace('$', predicate))\n  return Function.apply(void 0, fargs)\n}\n\n//# sourceURL=webpack:///./node_modules/box-intersect/lib/partition.js?");

/***/ }),

/***/ "./node_modules/box-intersect/lib/sort.js":
/*!************************************************!*\
  !*** ./node_modules/box-intersect/lib/sort.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n//This code is extracted from ndarray-sort\n//It is inlined here as a temporary workaround\n\nmodule.exports = wrapper;\n\nvar INSERT_SORT_CUTOFF = 32\n\nfunction wrapper(data, n0) {\n  if (n0 <= 4*INSERT_SORT_CUTOFF) {\n    insertionSort(0, n0 - 1, data);\n  } else {\n    quickSort(0, n0 - 1, data);\n  }\n}\n\nfunction insertionSort(left, right, data) {\n  var ptr = 2*(left+1)\n  for(var i=left+1; i<=right; ++i) {\n    var a = data[ptr++]\n    var b = data[ptr++]\n    var j = i\n    var jptr = ptr-2\n    while(j-- > left) {\n      var x = data[jptr-2]\n      var y = data[jptr-1]\n      if(x < a) {\n        break\n      } else if(x === a && y < b) {\n        break\n      }\n      data[jptr]   = x\n      data[jptr+1] = y\n      jptr -= 2\n    }\n    data[jptr]   = a\n    data[jptr+1] = b\n  }\n}\n\nfunction swap(i, j, data) {\n  i *= 2\n  j *= 2\n  var x = data[i]\n  var y = data[i+1]\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n  data[j] = x\n  data[j+1] = y\n}\n\nfunction move(i, j, data) {\n  i *= 2\n  j *= 2\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n}\n\nfunction rotate(i, j, k, data) {\n  i *= 2\n  j *= 2\n  k *= 2\n  var x = data[i]\n  var y = data[i+1]\n  data[i] = data[j]\n  data[i+1] = data[j+1]\n  data[j] = data[k]\n  data[j+1] = data[k+1]\n  data[k] = x\n  data[k+1] = y\n}\n\nfunction shufflePivot(i, j, px, py, data) {\n  i *= 2\n  j *= 2\n  data[i] = data[j]\n  data[j] = px\n  data[i+1] = data[j+1]\n  data[j+1] = py\n}\n\nfunction compare(i, j, data) {\n  i *= 2\n  j *= 2\n  var x = data[i],\n      y = data[j]\n  if(x < y) {\n    return false\n  } else if(x === y) {\n    return data[i+1] > data[j+1]\n  }\n  return true\n}\n\nfunction comparePivot(i, y, b, data) {\n  i *= 2\n  var x = data[i]\n  if(x < y) {\n    return true\n  } else if(x === y) {\n    return data[i+1] < b\n  }\n  return false\n}\n\nfunction quickSort(left, right, data) {\n  var sixth = (right - left + 1) / 6 | 0, \n      index1 = left + sixth, \n      index5 = right - sixth, \n      index3 = left + right >> 1, \n      index2 = index3 - sixth, \n      index4 = index3 + sixth, \n      el1 = index1, \n      el2 = index2, \n      el3 = index3, \n      el4 = index4, \n      el5 = index5, \n      less = left + 1, \n      great = right - 1, \n      tmp = 0\n  if(compare(el1, el2, data)) {\n    tmp = el1\n    el1 = el2\n    el2 = tmp\n  }\n  if(compare(el4, el5, data)) {\n    tmp = el4\n    el4 = el5\n    el5 = tmp\n  }\n  if(compare(el1, el3, data)) {\n    tmp = el1\n    el1 = el3\n    el3 = tmp\n  }\n  if(compare(el2, el3, data)) {\n    tmp = el2\n    el2 = el3\n    el3 = tmp\n  }\n  if(compare(el1, el4, data)) {\n    tmp = el1\n    el1 = el4\n    el4 = tmp\n  }\n  if(compare(el3, el4, data)) {\n    tmp = el3\n    el3 = el4\n    el4 = tmp\n  }\n  if(compare(el2, el5, data)) {\n    tmp = el2\n    el2 = el5\n    el5 = tmp\n  }\n  if(compare(el2, el3, data)) {\n    tmp = el2\n    el2 = el3\n    el3 = tmp\n  }\n  if(compare(el4, el5, data)) {\n    tmp = el4\n    el4 = el5\n    el5 = tmp\n  }\n\n  var pivot1X = data[2*el2]\n  var pivot1Y = data[2*el2+1]\n  var pivot2X = data[2*el4]\n  var pivot2Y = data[2*el4+1]\n\n  var ptr0 = 2 * el1;\n  var ptr2 = 2 * el3;\n  var ptr4 = 2 * el5;\n  var ptr5 = 2 * index1;\n  var ptr6 = 2 * index3;\n  var ptr7 = 2 * index5;\n  for (var i1 = 0; i1 < 2; ++i1) {\n    var x = data[ptr0+i1];\n    var y = data[ptr2+i1];\n    var z = data[ptr4+i1];\n    data[ptr5+i1] = x;\n    data[ptr6+i1] = y;\n    data[ptr7+i1] = z;\n  }\n\n  move(index2, left, data)\n  move(index4, right, data)\n  for (var k = less; k <= great; ++k) {\n    if (comparePivot(k, pivot1X, pivot1Y, data)) {\n      if (k !== less) {\n        swap(k, less, data)\n      }\n      ++less;\n    } else {\n      if (!comparePivot(k, pivot2X, pivot2Y, data)) {\n        while (true) {\n          if (!comparePivot(great, pivot2X, pivot2Y, data)) {\n            if (--great < k) {\n              break;\n            }\n            continue;\n          } else {\n            if (comparePivot(great, pivot1X, pivot1Y, data)) {\n              rotate(k, less, great, data)\n              ++less;\n              --great;\n            } else {\n              swap(k, great, data)\n              --great;\n            }\n            break;\n          }\n        }\n      }\n    }\n  }\n  shufflePivot(left, less-1, pivot1X, pivot1Y, data)\n  shufflePivot(right, great+1, pivot2X, pivot2Y, data)\n  if (less - 2 - left <= INSERT_SORT_CUTOFF) {\n    insertionSort(left, less - 2, data);\n  } else {\n    quickSort(left, less - 2, data);\n  }\n  if (right - (great + 2) <= INSERT_SORT_CUTOFF) {\n    insertionSort(great + 2, right, data);\n  } else {\n    quickSort(great + 2, right, data);\n  }\n  if (great - less <= INSERT_SORT_CUTOFF) {\n    insertionSort(less, great, data);\n  } else {\n    quickSort(less, great, data);\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/box-intersect/lib/sort.js?");

/***/ }),

/***/ "./node_modules/box-intersect/lib/sweep.js":
/*!*************************************************!*\
  !*** ./node_modules/box-intersect/lib/sweep.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = {\n  init:           sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete:  sweepComplete,\n  scanBipartite:  scanBipartite,\n  scanComplete:   scanComplete\n}\n\nvar pool  = __webpack_require__(/*! typedarray-pool */ \"./node_modules/typedarray-pool/pool.js\")\nvar bits  = __webpack_require__(/*! bit-twiddle */ \"./node_modules/bit-twiddle/twiddle.js\")\nvar isort = __webpack_require__(/*! ./sort */ \"./node_modules/box-intersect/lib/sort.js\")\n\n//Flag for blue\nvar BLUE_FLAG = (1<<28)\n\n//1D sweep event queue stuff (use pool to save space)\nvar INIT_CAPACITY      = 1024\nvar RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)\nvar RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)\nvar SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)\n\n//Reserves memory for the 1D sweep data structures\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count)\n  if(RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE)\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX)\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE)\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX)\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE)\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX)\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  var eventLength = 8 * rcount\n  if(SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS)\n    SWEEP_EVENTS = pool.mallocDouble(eventLength)\n  }\n}\n\n//Remove an item from the active queue in O(1)\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item]\n  var top = queue[count-1]\n  queue[idx] = top\n  index[top] = idx\n}\n\n//Insert an item into the active queue in O(1)\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item\n  index[item]  = count\n}\n\n//Recursion base case: use 1D sweep algorithm\nfunction sweepBipartite(\n    d, visit,\n    redStart,  redEnd, red, redIndex,\n    blueStart, blueEnd, blue, blueIndex) {\n\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = redIndex[i]\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -(idx+1)\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = blueIndex[i]+BLUE_FLAG\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive  = 0\n  var blueActive = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e >= BLUE_FLAG) {\n      //blue destroy event\n      e = (e-BLUE_FLAG)|0\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)\n    } else if(e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)\n    } else if(e <= -BLUE_FLAG) {\n      //blue create event\n      e = (-e-BLUE_FLAG)|0\n      for(var j=0; j<redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)\n    } else {\n      //red create event\n      e = (-e-1)|0\n      for(var j=0; j<blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j])\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)\n    }\n  }\n}\n\n//Complete sweep\nfunction sweepComplete(d, visit, \n  redStart, redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = (redIndex[i]+1)<<1\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = (blueIndex[i]+1)<<1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = (-idx)|1\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx|1\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  var blueActive   = 0\n  var commonActive = 0\n  for(var i=0; i<n; ++i) {\n    var e     = SWEEP_EVENTS[2*i+1]|0\n    var color = e&1\n    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {\n      color = 2\n      i += 1\n    }\n    \n    if(e < 0) {\n      //Create event\n      var id = -(e>>1) - 1\n\n      //Intersect with common\n      for(var j=0; j<commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n\n      if(color !== 0) {\n        //Intersect with red\n        for(var j=0; j<redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color !== 1) {\n        //Intersect with blue\n        for(var j=0; j<blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)\n      } else if(color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)\n      } else if(color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)\n      }\n    } else {\n      //Destroy event\n      var id = (e>>1) - 1\n      if(color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)\n      } else if(color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)\n      } else if(color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)\n      }\n    }\n  }\n}\n\n//Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\nfunction scanBipartite(\n  d, axis, visit, flip,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n  \n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  var redShift  = 1\n  var blueShift = 1\n  if(flip) {\n    blueShift = BLUE_FLAG\n  } else {\n    redShift  = BLUE_FLAG\n  }\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + redShift\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + blueShift\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      var isRed = false\n      if(idx >= BLUE_FLAG) {\n        isRed = !flip\n        idx -= BLUE_FLAG \n      } else {\n        isRed = !!flip\n        idx -= 1\n      }\n      if(isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)\n      } else {\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n        \n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redPtr = elemSize * oidx\n\n          if(b1 < red[redPtr+axis+1] || \n             red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var redId  = redIndex[oidx]\n          var retval\n          if(flip) {\n            retval = visit(blueId, redId)\n          } else {\n            retval = visit(redId, blueId)\n          }\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)\n    }\n  }\n}\n\nfunction scanComplete(\n  d, axis, visit,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + BLUE_FLAG\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + 1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      if(idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG\n      } else {\n        idx -= 1\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n\n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redId  = redIndex[oidx]\n\n          if(redId === blueId) {\n            break\n          }\n\n          var redPtr = elemSize * oidx\n          if(b1 < red[redPtr+axis+1] || \n            red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d]   < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var retval = visit(redId, blueId)\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG\n      for(var j=redActive-1; j>=0; --j) {\n        if(RED_SWEEP_QUEUE[j] === idx) {\n          for(var k=j+1; k<redActive; ++k) {\n            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]\n          }\n          break\n        }\n      }\n      --redActive\n    }\n  }\n}\n\n//# sourceURL=webpack:///./node_modules/box-intersect/lib/sweep.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/define-properties/index.js":
/*!*************************************************!*\
  !*** ./node_modules/define-properties/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar keys = __webpack_require__(/*! object-keys */ \"./node_modules/object-keys/index.js\");\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol('foo') === 'symbol';\n\nvar toStr = Object.prototype.toString;\nvar concat = Array.prototype.concat;\nvar origDefineProperty = Object.defineProperty;\n\nvar isFunction = function (fn) {\n\treturn typeof fn === 'function' && toStr.call(fn) === '[object Function]';\n};\n\nvar arePropertyDescriptorsSupported = function () {\n\tvar obj = {};\n\ttry {\n\t\torigDefineProperty(obj, 'x', { enumerable: false, value: obj });\n\t\t// eslint-disable-next-line no-unused-vars, no-restricted-syntax\n\t\tfor (var _ in obj) { // jscs:ignore disallowUnusedVariables\n\t\t\treturn false;\n\t\t}\n\t\treturn obj.x === obj;\n\t} catch (e) { /* this is IE 8. */\n\t\treturn false;\n\t}\n};\nvar supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();\n\nvar defineProperty = function (object, name, value, predicate) {\n\tif (name in object && (!isFunction(predicate) || !predicate())) {\n\t\treturn;\n\t}\n\tif (supportsDescriptors) {\n\t\torigDefineProperty(object, name, {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: false,\n\t\t\tvalue: value,\n\t\t\twritable: true\n\t\t});\n\t} else {\n\t\tobject[name] = value;\n\t}\n};\n\nvar defineProperties = function (object, map) {\n\tvar predicates = arguments.length > 2 ? arguments[2] : {};\n\tvar props = keys(map);\n\tif (hasSymbols) {\n\t\tprops = concat.call(props, Object.getOwnPropertySymbols(map));\n\t}\n\tfor (var i = 0; i < props.length; i += 1) {\n\t\tdefineProperty(object, props[i], map[props[i]], predicates[props[i]]);\n\t}\n};\n\ndefineProperties.supportsDescriptors = !!supportsDescriptors;\n\nmodule.exports = defineProperties;\n\n\n//# sourceURL=webpack:///./node_modules/define-properties/index.js?");

/***/ }),

/***/ "./node_modules/domready/ready.js":
/*!****************************************!*\
  !*** ./node_modules/domready/ready.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n  * domready (c) Dustin Diaz 2014 - License MIT\n  */\n!function (name, definition) {\n\n  if (true) module.exports = definition()\n  else {}\n\n}('domready', function () {\n\n  var fns = [], listener\n    , doc = document\n    , hack = doc.documentElement.doScroll\n    , domContentLoaded = 'DOMContentLoaded'\n    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)\n\n\n  if (!loaded)\n  doc.addEventListener(domContentLoaded, listener = function () {\n    doc.removeEventListener(domContentLoaded, listener)\n    loaded = 1\n    while (listener = fns.shift()) listener()\n  })\n\n  return function (fn) {\n    loaded ? setTimeout(fn, 0) : fns.push(fn)\n  }\n\n});\n\n\n//# sourceURL=webpack:///./node_modules/domready/ready.js?");

/***/ }),

/***/ "./node_modules/dup/dup.js":
/*!*********************************!*\
  !*** ./node_modules/dup/dup.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction dupe_array(count, value, i) {\n  var c = count[i]|0\n  if(c <= 0) {\n    return []\n  }\n  var result = new Array(c), j\n  if(i === count.length-1) {\n    for(j=0; j<c; ++j) {\n      result[j] = value\n    }\n  } else {\n    for(j=0; j<c; ++j) {\n      result[j] = dupe_array(count, value, i+1)\n    }\n  }\n  return result\n}\n\nfunction dupe_number(count, value) {\n  var result, i\n  result = new Array(count)\n  for(i=0; i<count; ++i) {\n    result[i] = value\n  }\n  return result\n}\n\nfunction dupe(count, value) {\n  if(typeof value === \"undefined\") {\n    value = 0\n  }\n  switch(typeof count) {\n    case \"number\":\n      if(count > 0) {\n        return dupe_number(count|0, value)\n      }\n    break\n    case \"object\":\n      if(typeof (count.length) === \"number\") {\n        return dupe_array(count, value, 0)\n      }\n    break\n  }\n  return []\n}\n\nmodule.exports = dupe\n\n//# sourceURL=webpack:///./node_modules/dup/dup.js?");

/***/ }),

/***/ "./node_modules/ent-comp/src/ECS.js":
/*!******************************************!*\
  !*** ./node_modules/ent-comp/src/ECS.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = ECS\nvar DataStore = __webpack_require__(/*! ./dataStore */ \"./node_modules/ent-comp/src/dataStore.js\")\n\n\n\n/**\n * \n * # ent-comp API Documentation:\n * \n*/\n\n\n\n/**\n * @class ECS\n * \n * Creates a new entity-component-system manager.\n * \n * ```js\n * var ECS = require('ent-comp')\n * var ecs = new ECS()\n * ```\n*/\n\nfunction ECS() {\n\tvar self = this\n\n\t/** \n\t * Hash of component definitions. Also aliased to `comps`.\n\t * \n\t * ```js\n\t * var comp = { name: 'foo' }\n\t * ecs.createComponent(comp)\n\t * ecs.components['foo'] === comp // true\n\t * ecs.comps['foo'] // same\n\t * ```\n\t*/\n\tthis.components = {}\n\tthis.comps = this.components\n\n\n\n\t/*\n\t * \n\t * \t\tinternals:\n\t * \n\t*/\n\n\tvar components = this.components\n\n\t// counter for entity IDs\n\tvar UID = 1\n\n\t// Storage for all component state data:\n\t// storage['component-name'] = { hash:{}, list:[] }\n\tvar storage = {}\n\n\t// flat arrays of names of components with systems\n\tvar systems = []\n\tvar renderSystems = []\n\n\t// queues for deferred operations\n\tvar deferredEntityRemovals = []\n\tvar deferredCompRemovals = []\n\tvar deferredMultiCompRemovals = []\n\n\n\n\t/*\n\t * \n\t * \n\t * \t\t\t\tPublic API\n\t * \n\t * \n\t*/\n\n\n\n\n\t/**\n\t * Creates a new entity id (currently just an incrementing integer).\n\t * \n\t * Optionally takes a list of component names to add to the entity (with default state data).\n\t * \n\t * ```js\n\t * var id1 = ecs.createEntity()\n\t * var id2 = ecs.createEntity([ 'some-component', 'other-component' ])\n\t * ```\n\t*/\n\tthis.createEntity = function (compList) {\n\t\tvar id = UID++\n\t\tif (compList && compList.length) {\n\t\t\tcompList.forEach(compName => self.addComponent(id, compName))\n\t\t}\n\t\treturn id\n\t}\n\n\n\n\t/**\n\t * Deletes an entity, which in practice just means removing all its components.\n\t * By default the actual removal is deferred (since entities will tend to \n\t * call this on themselves during event handlers, etc).\n\t * Pass a truthy second parameter to force immediate removal.\n\t * \n\t * ```js\n\t * ecs.deleteEntity(id)\n\t * ecs.deleteEntity(id2, true) // deletes immediately\n\t * ```\n\t * \n\t * Note that if you need to delete large numbers of entities at once,\n\t * and you know which components they have, this method will be a bit \n\t * slower than removing the components manually.\n\t*/\n\tthis.deleteEntity = function (entID, immediately) {\n\t\tif (immediately) {\n\t\t\tdeleteEntityNow(entID)\n\t\t} else {\n\t\t\tdeferredEntityRemovals.push(entID)\n\t\t\tmakeDeferralTimeout()\n\t\t}\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\t/**\n\t * Creates a new component from a definition object. \n\t * The definition must have a `name`; all other properties are optional.\n\t * \n\t * Returns the component name, to make it easy to grab when the component\n\t * is being `require`d from a module.\n\t * \n\t * ```js\n\t * var comp = {\n\t * \t name: 'some-unique-string',\n\t * \t state: {},\n\t * \t onAdd:        function(id, state){ },\n\t * \t onRemove:     function(id, state){ },\n\t * \t system:       function(dt, states){ },\n\t * \t renderSystem: function(dt, states){ },\n\t * \t multi: false,\n\t * }\n\t * \n\t * var name = ecs.createComponent( comp )\n\t * // name == 'a-unique-string'\n\t * ```\n\t * \n\t * Note the `multi` flag - for components where this is true, a given \n\t * entity can have multiple state objects for that component.\n\t * For multi-components, APIs that would normally return a state object \n\t * (like `getState`) will instead return an array of them.\n\t*/\n\tthis.createComponent = function (compDefn) {\n\t\tif (!compDefn) throw 'Missing component definition'\n\t\tvar name = compDefn.name\n\t\tif (!name) throw 'Component definition must have a name property.'\n\t\tif (typeof name !== 'string') throw 'Component name must be a string.'\n\t\tif (name === '') throw 'Component name must be a non-empty string.'\n\t\tif (storage[name]) throw `Component ${name} already exists.`\n\n\t\t// rebuild definition object for monomorphism\n\t\tvar internalDef = {}\n\t\tinternalDef.name = name\n\t\tinternalDef.state = compDefn.state || {}\n\t\tinternalDef.onAdd = compDefn.onAdd || null\n\t\tinternalDef.onRemove = compDefn.onRemove || null\n\t\tinternalDef.system = compDefn.system || null\n\t\tinternalDef.renderSystem = compDefn.renderSystem || null\n\t\tinternalDef.multi = !!compDefn.multi\n\n\t\tcomponents[name] = internalDef\n\t\tstorage[name] = DataStore.create()\n\n\t\tif (internalDef.system) systems.push(name)\n\t\tif (internalDef.renderSystem) renderSystems.push(name)\n\n\t\treturn name\n\t}\n\n\n\n\n\n\t/**\n\t * Deletes the component definition with the given name. \n\t * First removes the component from all entities that have it.\n\t * This probably shouldn't be called in real-world usage\n\t * (better to define all components when you begin and leave them be)\n\t * but it's here if you need it.\n\t * \n\t * ```js\n\t * ecs.deleteComponent( comp.name )\n\t * ```\n\t*/\n\tthis.deleteComponent = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}`\n\n\t\tdata.list.forEach(obj => {\n\t\t\tvar id = obj.__id || obj[0].__id\n\t\t\tself.removeComponent(id, compName, true)\n\t\t})\n\n\t\tvar i = systems.indexOf(compName)\n\t\tvar j = renderSystems.indexOf(compName)\n\t\tif (i > -1) systems.splice(i, 1)\n\t\tif (j > -1) renderSystems.splice(j, 1)\n\n\t\tdelete components[compName]\n\t\tdelete storage[compName]\n\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Adds a component to an entity, optionally initializing the state object.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'foo', {val:20})\n\t * ecs.getState(id, 'foo').val // 20\n\t * ```\n\t*/\n\tthis.addComponent = function (entID, compName, state) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\n\t\t// if the component is pending removal, remove it so it can be readded\n\t\tvar pendingRemoval = false\n\t\tdeferredCompRemovals.forEach(obj => {\n\t\t\tif (obj.id === entID && obj.compName === compName) pendingRemoval = true\n\t\t})\n\t\tif (pendingRemoval) doDeferredComponentRemovals()\n\n\t\tif (data.hash[entID] && !def.multi) throw `Entity ${entID} already has component: ${compName}.`\n\n\t\t// create new component state object for this entity\n\t\tvar newState = Object.assign({}, { __id: entID }, def.state, state)\n\n\t\t// just in case passed-in state object had an __id property\n\t\tnewState.__id = entID\n\n\t\t// add to dataStore - for multi components, may already be present\n\t\tif (def.multi) {\n\t\t\tvar statesArr = data.hash[entID]\n\t\t\tif (!statesArr) {\n\t\t\t\tstatesArr = []\n\t\t\t\tDataStore.add(data, entID, statesArr)\n\t\t\t}\n\t\t\tstatesArr.push(newState)\n\t\t} else {\n\t\t\tDataStore.add(data, entID, newState)\n\t\t}\n\n\t\t// call handler and return\n\t\tif (def.onAdd) def.onAdd(entID, newState)\n\n\t\treturn this\n\t}\n\n\n\n\t/**\n\t * Checks if an entity has a component.\n\t * \n\t * ```js\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.hasComponent(id, 'foo') // true\n\t * ```\n\t*/\n\n\tthis.hasComponent = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn (data.hash[entID] !== undefined)\n\t}\n\n\n\n\n\n\t/**\n\t * Removes a component from an entity, deleting any state data.\n\t * \n\t * ```js\n\t * ecs.removeComponent(id, 'foo', true) // final arg means \"immediately\"\n\t * ecs.hasComponent(id, 'foo') // false\n\t * ecs.removeComponent(id, 'bar')\n\t * ecs.hasComponent(id, 'bar') // true - by default the removal is asynchronous\n\t * ```\n\t*/\n\tthis.removeComponent = function (entID, compName, immediately) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\n\t\t// if comp isn't present, fail silently for multi or throw otherwise\n\t\tif (!data.hash[entID]) {\n\t\t\tif (def.multi) return self\n\t\t\telse throw `Entity ${entID} does not have component: ${compName} to remove.`\n\t\t}\n\n\t\t// defer or remove\n\t\tif (immediately) {\n\t\t\tremoveComponentNow(entID, compName)\n\t\t} else {\n\t\t\tdeferredCompRemovals.push({\n\t\t\t\tid: entID,\n\t\t\t\tcompName: compName,\n\t\t\t})\n\t\t\tmakeDeferralTimeout()\n\t\t}\n\n\t\treturn self\n\t}\n\n\n\n\n\n\t/**\n\t * Get the component state for a given entity.\n\t * It will automatically have an `__id` property for the entity id.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'foo')\n\t * ecs.getState(id, 'foo').val  // 0\n\t * ecs.getState(id, 'foo').__id // equals id\n\t * ```\n\t*/\n\n\tthis.getState = function (entID, compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn data.hash[entID]\n\t}\n\n\n\n\n\t/**\n\t * Get an array of state objects for every entity with the given component. \n\t * Each one will have an `__id` property for the entity id it refers to.\n\t * Don't add or remove elements from the returned list!\n\t * \n\t * ```js\n\t * var arr = ecs.getStatesList('foo')\n\t * // returns something shaped like:\n\t * //   [ {__id:0, x:1}, {__id:7, x:2}  ]\n\t * ```  \n\t*/\n\n\tECS.prototype.getStatesList = function (compName) {\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\treturn data.list\n\t}\n\n\n\n\n\t/**\n\t * Returns a `getState`-like accessor bound to a given component name. \n\t * The accessor is much faster than `getState`, so you should create an accessor \n\t * for any component whose state you'll be accessing a lot.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'size',\n\t * \tstate: { val: 0 }\n\t * })\n\t * ecs.addComponent(id, 'size')\n\t * var getSize = ecs.getStateAccessor('size')\n\t * getSize(id).val // 0\n\t * ```  \n\t*/\n\n\tthis.getStateAccessor = function (compName) {\n\t\tif (!storage[compName]) throw `Unknown component: ${compName}.`\n\t\tvar hash = storage[compName].hash\n\t\treturn function (entID) {\n\t\t\treturn hash[entID]\n\t\t}\n\t}\n\n\n\n\n\t/**\n\t * Returns a `hasComponent`-like accessor function bound to a given component name. \n\t * The accessor is much faster than `hasComponent`.\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: 'foo',\n\t * })\n\t * ecs.addComponent(id, 'foo')\n\t * var hasFoo = ecs.getComponentAccessor('foo')\n\t * hasFoo(id) // true\n\t * ```  \n\t*/\n\n\tthis.getComponentAccessor = function (compName) {\n\t\tif (!storage[compName]) throw `Unknown component: ${compName}.`\n\t\tvar hash = storage[compName].hash\n\t\treturn function (entID) {\n\t\t\treturn (hash[entID] !== undefined) // TODO\n\t\t}\n\t}\n\n\n\n\n\n\t/**\n\t * Tells the ECS that a game tick has occurred, causing component \n\t * `system` functions to get called.\n\t * \n\t * The optional parameter simply gets passed to the system functions. \n\t * It's meant to be a timestep, but can be used (or not used) as you like.    \n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \tsystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t\tstates.forEach(state => {\n\t * \t\t\tconsole.log('Entity ID: ', state.__id)\n\t * \t\t})\n\t * \t}\n\t * })\n\t * ecs.tick(30) // triggers log statements\n\t * ```\n\t*/\n\n\tthis.tick = function (dt) {\n\t\trunAllDeferredRemovals()\n\t\tsystems.forEach(compName => {\n\t\t\tvar list = storage[compName].list\n\t\t\tvar comp = components[compName]\n\t\t\tcomp.system(dt, list)\n\t\t})\n\t\trunAllDeferredRemovals()\n\t\treturn self\n\t}\n\n\n\n\t/**\n\t * Functions exactly like `tick`, but calls `renderSystem` functions.\n\t * this effectively gives you a second set of systems that are \n\t * called with separate timing, in case you want to \n\t * [tick and render in separate loops](http://gafferongames.com/game-physics/fix-your-timestep/)\n\t * (which you should!).\n\t * \n\t * ```js\n\t * ecs.createComponent({\n\t * \tname: foo,\n\t * \trenderSystem: function(dt, states) {\n\t * \t\t// states is the same array you'd get from #getStatesList()\n\t * \t}\n\t * })\n\t * ecs.render(16.666)\n\t * ```\n\t*/\n\n\tthis.render = function (dt) {\n\t\trunAllDeferredRemovals()\n\t\trenderSystems.forEach(compName => {\n\t\t\tvar list = storage[compName].list\n\t\t\tvar comp = components[compName]\n\t\t\tcomp.renderSystem(dt, list)\n\t\t})\n\t\trunAllDeferredRemovals()\n\t\treturn self\n\t}\n\n\n\n\n\t/**\n\t * Removes a particular state instance of a multi-component.\n\t * Pass a final truthy argument to make this happen synchronously - \n\t * but be careful, that will splice an element out of the multi-component array,\n\t * changing the indexes of subsequent elements.\n\t * \n\t * ```js\n\t * ecs.getState(id, 'foo')   // [ state1, state2, state3 ]\n\t * ecs.removeMultiComponent(id, 'foo', 1, true)  // true means: immediately\n\t * ecs.getState(id, 'foo')   // [ state1, state3 ]\n\t * ```\n\t */\n\tthis.removeMultiComponent = function (entID, compName, index, immediately) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) throw `Unknown component: ${compName}.`\n\t\tif (!def.multi) throw 'removeMultiComponent called on non-multi component'\n\n\t\t// throw if comp isn't present, or multicomp isn't present at index\n\t\tvar statesArr = data.hash[entID]\n\t\tif (!statesArr || !statesArr[index]) {\n\t\t\tthrow `Multicomponent ${compName} instance not found at index ${index}`\n\t\t}\n\n\t\t// index removals by object, in case indexes change later\n\t\tvar stateToRemove = statesArr[index]\n\t\tif (immediately) {\n\t\t\tremoveMultiCompNow(entID, compName, stateToRemove)\n\t\t} else {\n\t\t\tdeferredMultiCompRemovals.push({\n\t\t\t\tid: entID,\n\t\t\t\tcompName: compName,\n\t\t\t\tstate: stateToRemove,\n\t\t\t})\n\t\t}\n\n\t\treturn self\n\t}\n\n\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t *\t\tinternal implementation of various delete operations\n\t * \n\t * \n\t*/\n\n\n\t// delete entity - meaning simply remove all its components\n\tfunction deleteEntityNow(entID) {\n\t\t// For now loop over all components\n\t\t// Could speed this up by keeping a hash of components held by each entity?\n\t\tObject.keys(storage).forEach(compName => {\n\t\t\tvar data = storage[compName]\n\t\t\tif (data.hash[entID]) removeComponentNow(entID, compName)\n\t\t})\n\t}\n\n\n\t// remove given component from an entity\n\tfunction removeComponentNow(entID, compName) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tif (!data) return\n\t\tif (!data.hash[entID]) return // probably got removed twice during deferral\n\n\t\t// call onRemove handler - on each instance for multi components\n\t\tif (def.onRemove) {\n\t\t\tif (def.multi) {\n\t\t\t\tdata.hash[entID].forEach(state => {\n\t\t\t\t\tdef.onRemove(entID, state)\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\tdef.onRemove(entID, data.hash[entID])\n\t\t\t}\n\t\t}\n\n\t\t// if multi, kill the states array to hopefully free the objects\n\t\tif (def.multi) data.hash[entID].length = 0\n\n\t\t// actual removal from data store\n\t\tDataStore.remove(data, entID)\n\t}\n\n\n\n\t// remove one state from a multi component\n\tfunction removeMultiCompNow(entID, compName, stateObj) {\n\t\tvar def = components[compName]\n\t\tvar data = storage[compName]\n\t\tvar statesArr = data.hash[entID]\n\t\tif (!statesArr) return\n\n\t\tvar i = statesArr.indexOf(stateObj)\n\t\tif (i < 0) return\n\t\tif (def.onRemove) {\n\t\t\tdef.onRemove(entID, stateObj)\n\t\t}\n\t\tstatesArr.splice(i, 1)\n\n\t\t// if this leaves the states list empty, remove the whole component\n\t\tif (statesArr.length === 0) {\n\t\t\tremoveComponentNow(entID, compName)\n\t\t}\n\t}\n\n\n\n\n\n\n\t/*\n\t * \n\t * \n\t *\t\tinternals for handling deferrals\n\t * \n\t * \n\t*/\n\n\n\n\t// debouncer - called whenever a deferral is queued\n\tfunction makeDeferralTimeout() {\n\t\tif (deferralTimeoutPending) return\n\t\tdeferralTimeoutPending = true\n\t\tsetTimeout(function () {\n\t\t\tdeferralTimeoutPending = false\n\t\t\trunAllDeferredRemovals()\n\t\t}, 1)\n\t}\n\tvar deferralTimeoutPending = false\n\n\n\t// Ping all removal queues. \n\t// called before and after tick/render, and after deferrals are queued\n\tfunction runAllDeferredRemovals() {\n\t\tdoDeferredComponentRemovals()\n\t\tdoDeferredMultiComponentRemovals()\n\t\tdoDeferredEntityRemovals()\n\t}\n\n\n\t// entities - queue of entity IDs\n\tfunction doDeferredEntityRemovals() {\n\t\twhile (deferredEntityRemovals.length) {\n\t\t\tvar entID = deferredEntityRemovals.pop()\n\t\t\tdeleteEntityNow(entID)\n\t\t}\n\t}\n\n\n\t// components - queue of { id, compName }\n\tfunction doDeferredComponentRemovals() {\n\t\twhile (deferredCompRemovals.length) {\n\t\t\tvar obj = deferredCompRemovals.pop()\n\t\t\tremoveComponentNow(obj.id, obj.compName)\n\t\t}\n\t}\n\n\n\t// multi components - queue of { id, compName, state }\n\tfunction doDeferredMultiComponentRemovals(ecs) {\n\t\twhile (deferredMultiCompRemovals.length) {\n\t\t\tvar obj = deferredMultiCompRemovals.pop()\n\t\t\tremoveMultiCompNow(obj.id, obj.compName, obj.state)\n\t\t\tobj.state = null\n\t\t}\n\t}\n\n\n\n}\n\n\n\n//# sourceURL=webpack:///./node_modules/ent-comp/src/ECS.js?");

/***/ }),

/***/ "./node_modules/ent-comp/src/dataStore.js":
/*!************************************************!*\
  !*** ./node_modules/ent-comp/src/dataStore.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n/*\n * \n *      Encapsulates (mostly) a collection of objects, \n *      exposed both as a hash and as an array\n *      _map maps hash id to list index\n * \n *      Note this is a dumb store, it doesn't check any inputs at all.\n *      It also assumes every stored data object is stored like:\n *          DataStore.add(data, 37, {__id:37} )\n * \n*/\n\n\nmodule.exports = {\n\n    create: function () {\n        return {\n            list: [],\n            hash: {},\n            _map: {},\n        }\n    },\n\n\n    add: function (data, id, object) {\n        data.list.push(object)\n        data.hash[id] = object\n        data._map[id] = data.list.length - 1\n    },\n\n\n    remove: function (data, id) {\n        // splice out of list\n        var index = data._map[id]\n        if (index === data.list.length - 1) {\n            data.list.pop()\n        } else {\n            // replace element to be spliced with element from end\n            var movedItem = data.list.pop()\n            data.list[index] = movedItem\n            // watch out, this bit breaks encapsulation by assuming object's contents\n            // alternative would be to look through map for movedID's index\n            var movedID = movedItem.__id || movedItem[0].__id\n            data._map[movedID] = index\n        }\n        // finish\n        delete data.hash[id]\n        delete data._map[id]\n    },\n\n\n}\n\n\n\n\n//# sourceURL=webpack:///./node_modules/ent-comp/src/dataStore.js?");

/***/ }),

/***/ "./node_modules/es-abstract/GetIntrinsic.js":
/*!**************************************************!*\
  !*** ./node_modules/es-abstract/GetIntrinsic.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* globals\n\tSet,\n\tMap,\n\tWeakSet,\n\tWeakMap,\n\n\tPromise,\n\n\tSymbol,\n\tProxy,\n\n\tAtomics,\n\tSharedArrayBuffer,\n\n\tArrayBuffer,\n\tDataView,\n\tUint8Array,\n\tFloat32Array,\n\tFloat64Array,\n\tInt8Array,\n\tInt16Array,\n\tInt32Array,\n\tUint8ClampedArray,\n\tUint16Array,\n\tUint32Array,\n*/\n\nvar undefined; // eslint-disable-line no-shadow-restricted-names\n\nvar ThrowTypeError = Object.getOwnPropertyDescriptor\n\t? (function () { return Object.getOwnPropertyDescriptor(arguments, 'callee').get; }())\n\t: function () { throw new TypeError(); };\n\nvar hasSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol';\n\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\n\nvar generator; // = function * () {};\nvar generatorFunction = generator ? getProto(generator) : undefined;\nvar asyncFn; // async function() {};\nvar asyncFunction = asyncFn ? asyncFn.constructor : undefined;\nvar asyncGen; // async function * () {};\nvar asyncGenFunction = asyncGen ? getProto(asyncGen) : undefined;\nvar asyncGenIterator = asyncGen ? asyncGen() : undefined;\n\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\n\nvar INTRINSICS = {\n\t'$ %Array%': Array,\n\t'$ %ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\n\t'$ %ArrayBufferPrototype%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer.prototype,\n\t'$ %ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\n\t'$ %ArrayPrototype%': Array.prototype,\n\t'$ %ArrayProto_entries%': Array.prototype.entries,\n\t'$ %ArrayProto_forEach%': Array.prototype.forEach,\n\t'$ %ArrayProto_keys%': Array.prototype.keys,\n\t'$ %ArrayProto_values%': Array.prototype.values,\n\t'$ %AsyncFromSyncIteratorPrototype%': undefined,\n\t'$ %AsyncFunction%': asyncFunction,\n\t'$ %AsyncFunctionPrototype%': asyncFunction ? asyncFunction.prototype : undefined,\n\t'$ %AsyncGenerator%': asyncGen ? getProto(asyncGenIterator) : undefined,\n\t'$ %AsyncGeneratorFunction%': asyncGenFunction,\n\t'$ %AsyncGeneratorPrototype%': asyncGenFunction ? asyncGenFunction.prototype : undefined,\n\t'$ %AsyncIteratorPrototype%': asyncGenIterator && hasSymbols && Symbol.asyncIterator ? asyncGenIterator[Symbol.asyncIterator]() : undefined,\n\t'$ %Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\n\t'$ %Boolean%': Boolean,\n\t'$ %BooleanPrototype%': Boolean.prototype,\n\t'$ %DataView%': typeof DataView === 'undefined' ? undefined : DataView,\n\t'$ %DataViewPrototype%': typeof DataView === 'undefined' ? undefined : DataView.prototype,\n\t'$ %Date%': Date,\n\t'$ %DatePrototype%': Date.prototype,\n\t'$ %decodeURI%': decodeURI,\n\t'$ %decodeURIComponent%': decodeURIComponent,\n\t'$ %encodeURI%': encodeURI,\n\t'$ %encodeURIComponent%': encodeURIComponent,\n\t'$ %Error%': Error,\n\t'$ %ErrorPrototype%': Error.prototype,\n\t'$ %eval%': eval, // eslint-disable-line no-eval\n\t'$ %EvalError%': EvalError,\n\t'$ %EvalErrorPrototype%': EvalError.prototype,\n\t'$ %Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\n\t'$ %Float32ArrayPrototype%': typeof Float32Array === 'undefined' ? undefined : Float32Array.prototype,\n\t'$ %Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\n\t'$ %Float64ArrayPrototype%': typeof Float64Array === 'undefined' ? undefined : Float64Array.prototype,\n\t'$ %Function%': Function,\n\t'$ %FunctionPrototype%': Function.prototype,\n\t'$ %Generator%': generator ? getProto(generator()) : undefined,\n\t'$ %GeneratorFunction%': generatorFunction,\n\t'$ %GeneratorPrototype%': generatorFunction ? generatorFunction.prototype : undefined,\n\t'$ %Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\n\t'$ %Int8ArrayPrototype%': typeof Int8Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'$ %Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\n\t'$ %Int16ArrayPrototype%': typeof Int16Array === 'undefined' ? undefined : Int8Array.prototype,\n\t'$ %Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\n\t'$ %Int32ArrayPrototype%': typeof Int32Array === 'undefined' ? undefined : Int32Array.prototype,\n\t'$ %isFinite%': isFinite,\n\t'$ %isNaN%': isNaN,\n\t'$ %IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\n\t'$ %JSON%': JSON,\n\t'$ %JSONParse%': JSON.parse,\n\t'$ %Map%': typeof Map === 'undefined' ? undefined : Map,\n\t'$ %MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\n\t'$ %MapPrototype%': typeof Map === 'undefined' ? undefined : Map.prototype,\n\t'$ %Math%': Math,\n\t'$ %Number%': Number,\n\t'$ %NumberPrototype%': Number.prototype,\n\t'$ %Object%': Object,\n\t'$ %ObjectPrototype%': Object.prototype,\n\t'$ %ObjProto_toString%': Object.prototype.toString,\n\t'$ %ObjProto_valueOf%': Object.prototype.valueOf,\n\t'$ %parseFloat%': parseFloat,\n\t'$ %parseInt%': parseInt,\n\t'$ %Promise%': typeof Promise === 'undefined' ? undefined : Promise,\n\t'$ %PromisePrototype%': typeof Promise === 'undefined' ? undefined : Promise.prototype,\n\t'$ %PromiseProto_then%': typeof Promise === 'undefined' ? undefined : Promise.prototype.then,\n\t'$ %Promise_all%': typeof Promise === 'undefined' ? undefined : Promise.all,\n\t'$ %Promise_reject%': typeof Promise === 'undefined' ? undefined : Promise.reject,\n\t'$ %Promise_resolve%': typeof Promise === 'undefined' ? undefined : Promise.resolve,\n\t'$ %Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\n\t'$ %RangeError%': RangeError,\n\t'$ %RangeErrorPrototype%': RangeError.prototype,\n\t'$ %ReferenceError%': ReferenceError,\n\t'$ %ReferenceErrorPrototype%': ReferenceError.prototype,\n\t'$ %Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\n\t'$ %RegExp%': RegExp,\n\t'$ %RegExpPrototype%': RegExp.prototype,\n\t'$ %Set%': typeof Set === 'undefined' ? undefined : Set,\n\t'$ %SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\n\t'$ %SetPrototype%': typeof Set === 'undefined' ? undefined : Set.prototype,\n\t'$ %SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\n\t'$ %SharedArrayBufferPrototype%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer.prototype,\n\t'$ %String%': String,\n\t'$ %StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\n\t'$ %StringPrototype%': String.prototype,\n\t'$ %Symbol%': hasSymbols ? Symbol : undefined,\n\t'$ %SymbolPrototype%': hasSymbols ? Symbol.prototype : undefined,\n\t'$ %SyntaxError%': SyntaxError,\n\t'$ %SyntaxErrorPrototype%': SyntaxError.prototype,\n\t'$ %ThrowTypeError%': ThrowTypeError,\n\t'$ %TypedArray%': TypedArray,\n\t'$ %TypedArrayPrototype%': TypedArray ? TypedArray.prototype : undefined,\n\t'$ %TypeError%': TypeError,\n\t'$ %TypeErrorPrototype%': TypeError.prototype,\n\t'$ %Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\n\t'$ %Uint8ArrayPrototype%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array.prototype,\n\t'$ %Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\n\t'$ %Uint8ClampedArrayPrototype%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray.prototype,\n\t'$ %Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\n\t'$ %Uint16ArrayPrototype%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array.prototype,\n\t'$ %Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\n\t'$ %Uint32ArrayPrototype%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array.prototype,\n\t'$ %URIError%': URIError,\n\t'$ %URIErrorPrototype%': URIError.prototype,\n\t'$ %WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\n\t'$ %WeakMapPrototype%': typeof WeakMap === 'undefined' ? undefined : WeakMap.prototype,\n\t'$ %WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,\n\t'$ %WeakSetPrototype%': typeof WeakSet === 'undefined' ? undefined : WeakSet.prototype\n};\n\nmodule.exports = function GetIntrinsic(name, allowMissing) {\n\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\n\t\tthrow new TypeError('\"allowMissing\" argument must be a boolean');\n\t}\n\n\tvar key = '$ ' + name;\n\tif (!(key in INTRINSICS)) {\n\t\tthrow new SyntaxError('intrinsic ' + name + ' does not exist!');\n\t}\n\n\t// istanbul ignore if // hopefully this is impossible to test :-)\n\tif (typeof INTRINSICS[key] === 'undefined' && !allowMissing) {\n\t\tthrow new TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\n\t}\n\treturn INTRINSICS[key];\n};\n\n\n//# sourceURL=webpack:///./node_modules/es-abstract/GetIntrinsic.js?");

/***/ }),

/***/ "./node_modules/es-abstract/es5.js":
/*!*****************************************!*\
  !*** ./node_modules/es-abstract/es5.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! ./GetIntrinsic */ \"./node_modules/es-abstract/GetIntrinsic.js\");\n\nvar $Object = GetIntrinsic('%Object%');\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $String = GetIntrinsic('%String%');\n\nvar assertRecord = __webpack_require__(/*! ./helpers/assertRecord */ \"./node_modules/es-abstract/helpers/assertRecord.js\");\nvar $isNaN = __webpack_require__(/*! ./helpers/isNaN */ \"./node_modules/es-abstract/helpers/isNaN.js\");\nvar $isFinite = __webpack_require__(/*! ./helpers/isFinite */ \"./node_modules/es-abstract/helpers/isFinite.js\");\n\nvar sign = __webpack_require__(/*! ./helpers/sign */ \"./node_modules/es-abstract/helpers/sign.js\");\nvar mod = __webpack_require__(/*! ./helpers/mod */ \"./node_modules/es-abstract/helpers/mod.js\");\n\nvar IsCallable = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\nvar toPrimitive = __webpack_require__(/*! es-to-primitive/es5 */ \"./node_modules/es-to-primitive/es5.js\");\n\nvar has = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\n\n// https://es5.github.io/#x9\nvar ES5 = {\n\tToPrimitive: toPrimitive,\n\n\tToBoolean: function ToBoolean(value) {\n\t\treturn !!value;\n\t},\n\tToNumber: function ToNumber(value) {\n\t\treturn +value; // eslint-disable-line no-implicit-coercion\n\t},\n\tToInteger: function ToInteger(value) {\n\t\tvar number = this.ToNumber(value);\n\t\tif ($isNaN(number)) { return 0; }\n\t\tif (number === 0 || !$isFinite(number)) { return number; }\n\t\treturn sign(number) * Math.floor(Math.abs(number));\n\t},\n\tToInt32: function ToInt32(x) {\n\t\treturn this.ToNumber(x) >> 0;\n\t},\n\tToUint32: function ToUint32(x) {\n\t\treturn this.ToNumber(x) >>> 0;\n\t},\n\tToUint16: function ToUint16(value) {\n\t\tvar number = this.ToNumber(value);\n\t\tif ($isNaN(number) || number === 0 || !$isFinite(number)) { return 0; }\n\t\tvar posInt = sign(number) * Math.floor(Math.abs(number));\n\t\treturn mod(posInt, 0x10000);\n\t},\n\tToString: function ToString(value) {\n\t\treturn $String(value);\n\t},\n\tToObject: function ToObject(value) {\n\t\tthis.CheckObjectCoercible(value);\n\t\treturn $Object(value);\n\t},\n\tCheckObjectCoercible: function CheckObjectCoercible(value, optMessage) {\n\t\t/* jshint eqnull:true */\n\t\tif (value == null) {\n\t\t\tthrow new $TypeError(optMessage || 'Cannot call method on ' + value);\n\t\t}\n\t\treturn value;\n\t},\n\tIsCallable: IsCallable,\n\tSameValue: function SameValue(x, y) {\n\t\tif (x === y) { // 0 === -0, but they are not identical.\n\t\t\tif (x === 0) { return 1 / x === 1 / y; }\n\t\t\treturn true;\n\t\t}\n\t\treturn $isNaN(x) && $isNaN(y);\n\t},\n\n\t// https://www.ecma-international.org/ecma-262/5.1/#sec-8\n\tType: function Type(x) {\n\t\tif (x === null) {\n\t\t\treturn 'Null';\n\t\t}\n\t\tif (typeof x === 'undefined') {\n\t\t\treturn 'Undefined';\n\t\t}\n\t\tif (typeof x === 'function' || typeof x === 'object') {\n\t\t\treturn 'Object';\n\t\t}\n\t\tif (typeof x === 'number') {\n\t\t\treturn 'Number';\n\t\t}\n\t\tif (typeof x === 'boolean') {\n\t\t\treturn 'Boolean';\n\t\t}\n\t\tif (typeof x === 'string') {\n\t\t\treturn 'String';\n\t\t}\n\t},\n\n\t// https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n\tIsPropertyDescriptor: function IsPropertyDescriptor(Desc) {\n\t\tif (this.Type(Desc) !== 'Object') {\n\t\t\treturn false;\n\t\t}\n\t\tvar allowed = {\n\t\t\t'[[Configurable]]': true,\n\t\t\t'[[Enumerable]]': true,\n\t\t\t'[[Get]]': true,\n\t\t\t'[[Set]]': true,\n\t\t\t'[[Value]]': true,\n\t\t\t'[[Writable]]': true\n\t\t};\n\n\t\tfor (var key in Desc) { // eslint-disable-line\n\t\t\tif (has(Desc, key) && !allowed[key]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tvar isData = has(Desc, '[[Value]]');\n\t\tvar IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n\t\tif (isData && IsAccessor) {\n\t\t\tthrow new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n\t\t}\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.1\n\tIsAccessorDescriptor: function IsAccessorDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!has(Desc, '[[Get]]') && !has(Desc, '[[Set]]')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.2\n\tIsDataDescriptor: function IsDataDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!has(Desc, '[[Value]]') && !has(Desc, '[[Writable]]')) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.3\n\tIsGenericDescriptor: function IsGenericDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn false;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (!this.IsAccessorDescriptor(Desc) && !this.IsDataDescriptor(Desc)) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.4\n\tFromPropertyDescriptor: function FromPropertyDescriptor(Desc) {\n\t\tif (typeof Desc === 'undefined') {\n\t\t\treturn Desc;\n\t\t}\n\n\t\tassertRecord(this, 'Property Descriptor', 'Desc', Desc);\n\n\t\tif (this.IsDataDescriptor(Desc)) {\n\t\t\treturn {\n\t\t\t\tvalue: Desc['[[Value]]'],\n\t\t\t\twritable: !!Desc['[[Writable]]'],\n\t\t\t\tenumerable: !!Desc['[[Enumerable]]'],\n\t\t\t\tconfigurable: !!Desc['[[Configurable]]']\n\t\t\t};\n\t\t} else if (this.IsAccessorDescriptor(Desc)) {\n\t\t\treturn {\n\t\t\t\tget: Desc['[[Get]]'],\n\t\t\t\tset: Desc['[[Set]]'],\n\t\t\t\tenumerable: !!Desc['[[Enumerable]]'],\n\t\t\t\tconfigurable: !!Desc['[[Configurable]]']\n\t\t\t};\n\t\t} else {\n\t\t\tthrow new $TypeError('FromPropertyDescriptor must be called with a fully populated Property Descriptor');\n\t\t}\n\t},\n\n\t// https://ecma-international.org/ecma-262/5.1/#sec-8.10.5\n\tToPropertyDescriptor: function ToPropertyDescriptor(Obj) {\n\t\tif (this.Type(Obj) !== 'Object') {\n\t\t\tthrow new $TypeError('ToPropertyDescriptor requires an object');\n\t\t}\n\n\t\tvar desc = {};\n\t\tif (has(Obj, 'enumerable')) {\n\t\t\tdesc['[[Enumerable]]'] = this.ToBoolean(Obj.enumerable);\n\t\t}\n\t\tif (has(Obj, 'configurable')) {\n\t\t\tdesc['[[Configurable]]'] = this.ToBoolean(Obj.configurable);\n\t\t}\n\t\tif (has(Obj, 'value')) {\n\t\t\tdesc['[[Value]]'] = Obj.value;\n\t\t}\n\t\tif (has(Obj, 'writable')) {\n\t\t\tdesc['[[Writable]]'] = this.ToBoolean(Obj.writable);\n\t\t}\n\t\tif (has(Obj, 'get')) {\n\t\t\tvar getter = Obj.get;\n\t\t\tif (typeof getter !== 'undefined' && !this.IsCallable(getter)) {\n\t\t\t\tthrow new TypeError('getter must be a function');\n\t\t\t}\n\t\t\tdesc['[[Get]]'] = getter;\n\t\t}\n\t\tif (has(Obj, 'set')) {\n\t\t\tvar setter = Obj.set;\n\t\t\tif (typeof setter !== 'undefined' && !this.IsCallable(setter)) {\n\t\t\t\tthrow new $TypeError('setter must be a function');\n\t\t\t}\n\t\t\tdesc['[[Set]]'] = setter;\n\t\t}\n\n\t\tif ((has(desc, '[[Get]]') || has(desc, '[[Set]]')) && (has(desc, '[[Value]]') || has(desc, '[[Writable]]'))) {\n\t\t\tthrow new $TypeError('Invalid property descriptor. Cannot both specify accessors and a value or writable attribute');\n\t\t}\n\t\treturn desc;\n\t}\n};\n\nmodule.exports = ES5;\n\n\n//# sourceURL=webpack:///./node_modules/es-abstract/es5.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/assertRecord.js":
/*!**********************************************************!*\
  !*** ./node_modules/es-abstract/helpers/assertRecord.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar GetIntrinsic = __webpack_require__(/*! ../GetIntrinsic */ \"./node_modules/es-abstract/GetIntrinsic.js\");\n\nvar $TypeError = GetIntrinsic('%TypeError%');\nvar $SyntaxError = GetIntrinsic('%SyntaxError%');\n\nvar has = __webpack_require__(/*! has */ \"./node_modules/has/src/index.js\");\n\nvar predicates = {\n  // https://ecma-international.org/ecma-262/6.0/#sec-property-descriptor-specification-type\n  'Property Descriptor': function isPropertyDescriptor(ES, Desc) {\n    if (ES.Type(Desc) !== 'Object') {\n      return false;\n    }\n    var allowed = {\n      '[[Configurable]]': true,\n      '[[Enumerable]]': true,\n      '[[Get]]': true,\n      '[[Set]]': true,\n      '[[Value]]': true,\n      '[[Writable]]': true\n    };\n\n    for (var key in Desc) { // eslint-disable-line\n      if (has(Desc, key) && !allowed[key]) {\n        return false;\n      }\n    }\n\n    var isData = has(Desc, '[[Value]]');\n    var IsAccessor = has(Desc, '[[Get]]') || has(Desc, '[[Set]]');\n    if (isData && IsAccessor) {\n      throw new $TypeError('Property Descriptors may not be both accessor and data descriptors');\n    }\n    return true;\n  }\n};\n\nmodule.exports = function assertRecord(ES, recordType, argumentName, value) {\n  var predicate = predicates[recordType];\n  if (typeof predicate !== 'function') {\n    throw new $SyntaxError('unknown record type: ' + recordType);\n  }\n  if (!predicate(ES, value)) {\n    throw new $TypeError(argumentName + ' must be a ' + recordType);\n  }\n  console.log(predicate(ES, value), value);\n};\n\n\n//# sourceURL=webpack:///./node_modules/es-abstract/helpers/assertRecord.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/isFinite.js":
/*!******************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isFinite.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var $isNaN = Number.isNaN || function (a) { return a !== a; };\n\nmodule.exports = Number.isFinite || function (x) { return typeof x === 'number' && !$isNaN(x) && x !== Infinity && x !== -Infinity; };\n\n\n//# sourceURL=webpack:///./node_modules/es-abstract/helpers/isFinite.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/isNaN.js":
/*!***************************************************!*\
  !*** ./node_modules/es-abstract/helpers/isNaN.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Number.isNaN || function isNaN(a) {\n\treturn a !== a;\n};\n\n\n//# sourceURL=webpack:///./node_modules/es-abstract/helpers/isNaN.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/mod.js":
/*!*************************************************!*\
  !*** ./node_modules/es-abstract/helpers/mod.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function mod(number, modulo) {\n\tvar remain = number % modulo;\n\treturn Math.floor(remain >= 0 ? remain : remain + modulo);\n};\n\n\n//# sourceURL=webpack:///./node_modules/es-abstract/helpers/mod.js?");

/***/ }),

/***/ "./node_modules/es-abstract/helpers/sign.js":
/*!**************************************************!*\
  !*** ./node_modules/es-abstract/helpers/sign.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function sign(number) {\n\treturn number >= 0 ? 1 : -1;\n};\n\n\n//# sourceURL=webpack:///./node_modules/es-abstract/helpers/sign.js?");

/***/ }),

/***/ "./node_modules/es-to-primitive/es5.js":
/*!*********************************************!*\
  !*** ./node_modules/es-to-primitive/es5.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nvar isPrimitive = __webpack_require__(/*! ./helpers/isPrimitive */ \"./node_modules/es-to-primitive/helpers/isPrimitive.js\");\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\n\n// http://ecma-international.org/ecma-262/5.1/#sec-8.12.8\nvar ES5internalSlots = {\n\t'[[DefaultValue]]': function (O) {\n\t\tvar actualHint;\n\t\tif (arguments.length > 1) {\n\t\t\tactualHint = arguments[1];\n\t\t} else {\n\t\t\tactualHint = toStr.call(O) === '[object Date]' ? String : Number;\n\t\t}\n\n\t\tif (actualHint === String || actualHint === Number) {\n\t\t\tvar methods = actualHint === String ? ['toString', 'valueOf'] : ['valueOf', 'toString'];\n\t\t\tvar value, i;\n\t\t\tfor (i = 0; i < methods.length; ++i) {\n\t\t\t\tif (isCallable(O[methods[i]])) {\n\t\t\t\t\tvalue = O[methods[i]]();\n\t\t\t\t\tif (isPrimitive(value)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthrow new TypeError('No default value');\n\t\t}\n\t\tthrow new TypeError('invalid [[DefaultValue]] hint supplied');\n\t}\n};\n\n// http://ecma-international.org/ecma-262/5.1/#sec-9.1\nmodule.exports = function ToPrimitive(input) {\n\tif (isPrimitive(input)) {\n\t\treturn input;\n\t}\n\tif (arguments.length > 1) {\n\t\treturn ES5internalSlots['[[DefaultValue]]'](input, arguments[1]);\n\t}\n\treturn ES5internalSlots['[[DefaultValue]]'](input);\n};\n\n\n//# sourceURL=webpack:///./node_modules/es-to-primitive/es5.js?");

/***/ }),

/***/ "./node_modules/es-to-primitive/helpers/isPrimitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/es-to-primitive/helpers/isPrimitive.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isPrimitive(value) {\n\treturn value === null || (typeof value !== 'function' && typeof value !== 'object');\n};\n\n\n//# sourceURL=webpack:///./node_modules/es-to-primitive/helpers/isPrimitive.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n//# sourceURL=webpack:///./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/fast-voxel-raycast/index.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-voxel-raycast/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction traceRay_impl( getVoxel,\n\tpx, py, pz,\n\tdx, dy, dz,\n\tmax_d, hit_pos, hit_norm) {\n\t\n\t// consider raycast vector to be parametrized by t\n\t//   vec = [px,py,pz] + t * [dx,dy,dz]\n\t\n\t// algo below is as described by this paper:\n\t// http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n\t\n\tvar t = 0.0\n\t\t, floor = Math.floor\n\t\t, ix = floor(px) | 0\n\t\t, iy = floor(py) | 0\n\t\t, iz = floor(pz) | 0\n\n\t\t, stepx = (dx > 0) ? 1 : -1\n\t\t, stepy = (dy > 0) ? 1 : -1\n\t\t, stepz = (dz > 0) ? 1 : -1\n\t\t\n\t// dx,dy,dz are already normalized\n\t\t, txDelta = Math.abs(1 / dx)\n\t\t, tyDelta = Math.abs(1 / dy)\n\t\t, tzDelta = Math.abs(1 / dz)\n\n\t\t, xdist = (stepx > 0) ? (ix + 1 - px) : (px - ix)\n\t\t, ydist = (stepy > 0) ? (iy + 1 - py) : (py - iy)\n\t\t, zdist = (stepz > 0) ? (iz + 1 - pz) : (pz - iz)\n\t\t\n\t// location of nearest voxel boundary, in units of t \n\t\t, txMax = (txDelta < Infinity) ? txDelta * xdist : Infinity\n\t\t, tyMax = (tyDelta < Infinity) ? tyDelta * ydist : Infinity\n\t\t, tzMax = (tzDelta < Infinity) ? tzDelta * zdist : Infinity\n\n\t\t, steppedIndex = -1\n\t\n\t// main loop along raycast vector\n\twhile (t <= max_d) {\n\t\t\n\t\t// exit check\n\t\tvar b = getVoxel(ix, iy, iz)\n\t\tif (b) {\n\t\t\tif (hit_pos) {\n\t\t\t\thit_pos[0] = px + t * dx\n\t\t\t\thit_pos[1] = py + t * dy\n\t\t\t\thit_pos[2] = pz + t * dz\n\t\t\t}\n\t\t\tif (hit_norm) {\n\t\t\t\thit_norm[0] = hit_norm[1] = hit_norm[2] = 0\n\t\t\t\tif (steppedIndex === 0) hit_norm[0] = -stepx\n\t\t\t\tif (steppedIndex === 1) hit_norm[1] = -stepy\n\t\t\t\tif (steppedIndex === 2) hit_norm[2] = -stepz\n\t\t\t}\n\t\t\treturn b\n\t\t}\n\t\t\n\t\t// advance t to next nearest voxel boundary\n\t\tif (txMax < tyMax) {\n\t\t\tif (txMax < tzMax) {\n\t\t\t\tix += stepx\n\t\t\t\tt = txMax\n\t\t\t\ttxMax += txDelta\n\t\t\t\tsteppedIndex = 0\n\t\t\t} else {\n\t\t\t\tiz += stepz\n\t\t\t\tt = tzMax\n\t\t\t\ttzMax += tzDelta\n\t\t\t\tsteppedIndex = 2\n\t\t\t}\n\t\t} else {\n\t\t\tif (tyMax < tzMax) {\n\t\t\t\tiy += stepy\n\t\t\t\tt = tyMax\n\t\t\t\ttyMax += tyDelta\n\t\t\t\tsteppedIndex = 1\n\t\t\t} else {\n\t\t\t\tiz += stepz\n\t\t\t\tt = tzMax\n\t\t\t\ttzMax += tzDelta\n\t\t\t\tsteppedIndex = 2\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\t// no voxel hit found\n\tif (hit_pos) {\n\t\thit_pos[0] = px + t * dx\n\t\thit_pos[1] = py + t * dy\n\t\thit_pos[2] = pz + t * dz\n\t}\n\tif (hit_norm) {\n\t\thit_norm[0] = hit_norm[1] = hit_norm[2] = 0\n\t}\n\n\treturn 0\n\n}\n\n\n// conform inputs\n\nfunction traceRay(getVoxel, origin, direction, max_d, hit_pos, hit_norm) {\n\tvar px = +origin[0]\n\t\t, py = +origin[1]\n\t\t, pz = +origin[2]\n\t\t, dx = +direction[0]\n\t\t, dy = +direction[1]\n\t\t, dz = +direction[2]\n\t\t, ds = Math.sqrt(dx * dx + dy * dy + dz * dz)\n\n\tif (ds === 0) {\n\t\tthrow new Error(\"Can't raycast along a zero vector\")\n\t}\n\n\tdx /= ds\n\tdy /= ds\n\tdz /= ds\n\tif (typeof (max_d) === \"undefined\") {\n\t\tmax_d = 64.0\n\t} else {\n\t\tmax_d = +max_d\n\t}\n\treturn traceRay_impl(getVoxel, px, py, pz, dx, dy, dz, max_d, hit_pos, hit_norm)\n}\n\nmodule.exports = traceRay\n\n//# sourceURL=webpack:///./node_modules/fast-voxel-raycast/index.js?");

/***/ }),

/***/ "./node_modules/for-each/index.js":
/*!****************************************!*\
  !*** ./node_modules/for-each/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isCallable = __webpack_require__(/*! is-callable */ \"./node_modules/is-callable/index.js\");\n\nvar toStr = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar forEachArray = function forEachArray(array, iterator, receiver) {\n    for (var i = 0, len = array.length; i < len; i++) {\n        if (hasOwnProperty.call(array, i)) {\n            if (receiver == null) {\n                iterator(array[i], i, array);\n            } else {\n                iterator.call(receiver, array[i], i, array);\n            }\n        }\n    }\n};\n\nvar forEachString = function forEachString(string, iterator, receiver) {\n    for (var i = 0, len = string.length; i < len; i++) {\n        // no such thing as a sparse string.\n        if (receiver == null) {\n            iterator(string.charAt(i), i, string);\n        } else {\n            iterator.call(receiver, string.charAt(i), i, string);\n        }\n    }\n};\n\nvar forEachObject = function forEachObject(object, iterator, receiver) {\n    for (var k in object) {\n        if (hasOwnProperty.call(object, k)) {\n            if (receiver == null) {\n                iterator(object[k], k, object);\n            } else {\n                iterator.call(receiver, object[k], k, object);\n            }\n        }\n    }\n};\n\nvar forEach = function forEach(list, iterator, thisArg) {\n    if (!isCallable(iterator)) {\n        throw new TypeError('iterator must be a function');\n    }\n\n    var receiver;\n    if (arguments.length >= 3) {\n        receiver = thisArg;\n    }\n\n    if (toStr.call(list) === '[object Array]') {\n        forEachArray(list, iterator, receiver);\n    } else if (typeof list === 'string') {\n        forEachString(list, iterator, receiver);\n    } else {\n        forEachObject(list, iterator, receiver);\n    }\n};\n\nmodule.exports = forEach;\n\n\n//# sourceURL=webpack:///./node_modules/for-each/index.js?");

/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/* eslint no-invalid-this: 1 */\n\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\nvar slice = Array.prototype.slice;\nvar toStr = Object.prototype.toString;\nvar funcType = '[object Function]';\n\nmodule.exports = function bind(that) {\n    var target = this;\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\n        throw new TypeError(ERROR_MESSAGE + target);\n    }\n    var args = slice.call(arguments, 1);\n\n    var bound;\n    var binder = function () {\n        if (this instanceof bound) {\n            var result = target.apply(\n                this,\n                args.concat(slice.call(arguments))\n            );\n            if (Object(result) === result) {\n                return result;\n            }\n            return this;\n        } else {\n            return target.apply(\n                that,\n                args.concat(slice.call(arguments))\n            );\n        }\n    };\n\n    var boundLength = Math.max(0, target.length - args.length);\n    var boundArgs = [];\n    for (var i = 0; i < boundLength; i++) {\n        boundArgs.push('$' + i);\n    }\n\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\n\n    if (target.prototype) {\n        var Empty = function Empty() {};\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n    }\n\n    return bound;\n};\n\n\n//# sourceURL=webpack:///./node_modules/function-bind/implementation.js?");

/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/function-bind/implementation.js\");\n\nmodule.exports = Function.prototype.bind || implementation;\n\n\n//# sourceURL=webpack:///./node_modules/function-bind/index.js?");

/***/ }),

/***/ "./node_modules/game-inputs/inputs.js":
/*!********************************************!*\
  !*** ./node_modules/game-inputs/inputs.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vkey = __webpack_require__(/*! vkey */ \"./node_modules/vkey/index.js\")\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter\n// mousewheel polyfill borrowed directly from game-shell\nvar addMouseWheel = __webpack_require__(/*! ./lib/mousewheel-polyfill.js */ \"./node_modules/game-inputs/lib/mousewheel-polyfill.js\")\n\nmodule.exports = function (domElement, options) {\n    return new Inputs(domElement, options)\n}\n\n\n/*\n *   Simple inputs manager to abstract key/mouse inputs.\n *        Inspired by (and where applicable stealing code from) \n *        game-shell: https://github.com/mikolalysenko/game-shell\n *  \n *  inputs.bind( 'move-right', 'D', '<right>' )\n *  inputs.bind( 'move-left',  'A' )\n *  inputs.unbind( 'move-left' )\n *  \n *  inputs.down.on( 'move-right',  function( binding, event ) {})\n *  inputs.up.on(   'move-right',  function( binding, event ) {})\n *\n *  inputs.state['move-right']  // true when corresponding keys are down\n *  inputs.state.dx             // mouse x movement since tick() was last called\n *  inputs.getBindings()        // [ 'move-right', 'move-left', ... ]\n*/\n\n\nfunction Inputs(element, opts) {\n\n    // settings\n    this.element = element || document\n    opts = opts || {}\n    this.preventDefaults = !!opts.preventDefaults\n    this.stopPropagation = !!opts.stopPropagation\n\n    // emitters\n    this.down = new EventEmitter()\n    this.up = new EventEmitter()\n\n    // state object to be queried\n    this.state = {\n        dx: 0, dy: 0,\n        scrollx: 0, scrolly: 0, scrollz: 0\n    }\n\n    // internal state\n    this._keybindmap = {}       // { 'vkeycode' : [ 'binding', 'binding2' ] }\n    this._keyStates = {}        // { 'vkeycode' : boolean }\n    this._bindPressCounts = {}  // { 'binding' : int }\n\n    // needed to work around a bug in Mac Chrome 75\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=977093\n    this._ignoreMousemoveOnce = false\n\n    // register for dom events\n    this.initEvents()\n}\n\n\n/*\n *\n *   PUBLIC API \n *\n*/\n\nInputs.prototype.initEvents = function () {\n    // keys\n    window.addEventListener('keydown', onKeyEvent.bind(undefined, this, true), false)\n    window.addEventListener('keyup', onKeyEvent.bind(undefined, this, false), false)\n    // mouse buttons\n    this.element.addEventListener(\"mousedown\", onMouseEvent.bind(undefined, this, true), false)\n    this.element.addEventListener(\"mouseup\", onMouseEvent.bind(undefined, this, false), false)\n    this.element.oncontextmenu = onContextMenu.bind(undefined, this)\n    // treat dragstart like mouseup - idiotically, mouseup doesn't fire after a drag starts (!)\n    this.element.addEventListener(\"dragstart\", onMouseEvent.bind(undefined, this, false), false)\n    // touch/mouse movement\n    this.element.addEventListener(\"mousemove\", onMouseMove.bind(undefined, this), false)\n    this.element.addEventListener(\"touchmove\", onMouseMove.bind(undefined, this), false)\n    this.element.addEventListener(\"touchstart\", onTouchStart.bind(undefined, this), false)\n    // scroll/mousewheel\n    addMouseWheel(this.element, onMouseWheel.bind(undefined, this), false)\n    // temp bug workaround, see above\n    document.addEventListener(\"pointerlockchange\", onLockChange.bind(undefined, this), false)\n    document.addEventListener(\"mozpointerlockchange\", onLockChange.bind(undefined, this), false)\n}\n\n\n// Usage:  bind( bindingName, vkeyCode, vkeyCode.. )\n//    Note that inputs._keybindmap maps vkey codes to binding names\n//    e.g. this._keybindmap['a'] = 'move-left'\nInputs.prototype.bind = function (binding) {\n    for (var i = 1; i < arguments.length; ++i) {\n        var vkeyCode = arguments[i]\n        var arr = this._keybindmap[vkeyCode] || []\n        if (arr.indexOf(binding) == -1) {\n            arr.push(binding)\n        }\n        this._keybindmap[vkeyCode] = arr\n    }\n    this.state[binding] = !!this.state[binding]\n}\n\n// search out and remove all keycodes bound to a given binding\nInputs.prototype.unbind = function (binding) {\n    for (var b in this._keybindmap) {\n        var arr = this._keybindmap[b]\n        var i = arr.indexOf(binding)\n        if (i > -1) { arr.splice(i, 1) }\n    }\n}\n\n// tick function - clears out cumulative mouse movement state variables\nInputs.prototype.tick = function () {\n    this.state.dx = this.state.dy = 0\n    this.state.scrollx = this.state.scrolly = this.state.scrollz = 0\n}\n\n\n\nInputs.prototype.getBoundKeys = function () {\n    var arr = []\n    for (var b in this._keybindmap) { arr.push(b) }\n    return arr\n}\n\n\n\n/*\n *\n *\n *      INTERNALS - DOM EVENT HANDLERS\n *\n *\n*/\n\n\nfunction onKeyEvent(inputs, wasDown, ev) {\n    handleKeyEvent(ev.keyCode, vkey[ev.keyCode], wasDown, inputs, ev)\n}\n\nfunction onMouseEvent(inputs, wasDown, ev) {\n    // simulate a code out of range of vkey\n    var keycode = -1 - ev.button\n    var vkeycode = '<mouse ' + (ev.button + 1) + '>'\n    handleKeyEvent(keycode, vkeycode, wasDown, inputs, ev)\n    return false\n}\n\nfunction onContextMenu(inputs) {\n    // cancel context menu if there's a binding for right mousebutton\n    var arr = inputs._keybindmap['<mouse 3>']\n    if (arr) { return false }\n}\n\nfunction onMouseMove(inputs, ev) {\n    // bug workaround, see top of file\n    if (inputs._ignoreMousemoveOnce) {\n        inputs._ignoreMousemoveOnce = false\n        return\n    }\n    // for now, just populate the state object with mouse movement\n    var dx = ev.movementX || ev.mozMovementX || 0,\n        dy = ev.movementY || ev.mozMovementY || 0\n    // ad-hoc experimental touch support\n    if (ev.touches && (dx | dy) === 0) {\n        var xy = getTouchMovement(ev)\n        dx = xy[0]\n        dy = xy[1]\n    }\n    inputs.state.dx += dx\n    inputs.state.dy += dy\n}\n\n// experimental - for touch events, extract useful dx/dy\nvar lastTouchX = 0\nvar lastTouchY = 0\nvar lastTouchID = null\n\nfunction onTouchStart(inputs, ev) {\n    var touch = ev.changedTouches[0]\n    lastTouchX = touch.clientX\n    lastTouchY = touch.clientY\n    lastTouchID = touch.identifier\n}\n\nfunction getTouchMovement(ev) {\n    var touch\n    var touches = ev.changedTouches\n    for (var i = 0; i < touches.length; ++i) {\n        if (touches[i].identifier == lastTouchID) touch = touches[i]\n    }\n    if (!touch) return [0, 0]\n    var res = [touch.clientX - lastTouchX, touch.clientY - lastTouchY]\n    lastTouchX = touch.clientX\n    lastTouchY = touch.clientY\n    return res\n}\n\nfunction onMouseWheel(inputs, ev) {\n    // basically borrowed from game-shell\n    var scale = 1\n    switch (ev.deltaMode) {\n        case 0: scale = 1; break  // Pixel\n        case 1: scale = 12; break  // Line\n        case 2:  // page\n            // TODO: investigagte when this happens, what correct handling is\n            scale = inputs.element.clientHeight || window.innerHeight\n            break\n    }\n    // accumulate state\n    inputs.state.scrollx += ev.deltaX * scale\n    inputs.state.scrolly += ev.deltaY * scale\n    inputs.state.scrollz += (ev.deltaZ * scale) || 0\n    return false\n}\n\nfunction onLockChange(inputs, ev) {\n    var locked = document.pointerLockElement\n        || document.mozPointerLockElement\n        || null\n    if (locked) inputs._ignoreMousemoveOnce = true\n}\n\n\n\n\n/*\n *\n *\n *   KEY BIND HANDLING\n *\n *\n*/\n\n\nfunction handleKeyEvent(keycode, vcode, wasDown, inputs, ev) {\n    var arr = inputs._keybindmap[vcode]\n    // don't prevent defaults if there's no binding\n    if (!arr) { return }\n    if (inputs.preventDefaults) ev.preventDefault()\n    if (inputs.stopPropagation) ev.stopPropagation()\n\n    // if the key's state has changed, handle an event for all bindings\n    var currstate = inputs._keyStates[keycode]\n    if (XOR(currstate, wasDown)) {\n        // for each binding: emit an event, and update cached state information\n        for (var i = 0; i < arr.length; ++i) {\n            handleBindingEvent(arr[i], wasDown, inputs, ev)\n        }\n    }\n    inputs._keyStates[keycode] = wasDown\n}\n\n\nfunction handleBindingEvent(binding, wasDown, inputs, ev) {\n    // keep count of presses mapped by binding\n    // (to handle two keys with the same binding pressed at once)\n    var ct = inputs._bindPressCounts[binding] || 0\n    ct += wasDown ? 1 : -1\n    if (ct < 0) { ct = 0 } // shouldn't happen\n    inputs._bindPressCounts[binding] = ct\n\n    // emit event if binding's state has changed\n    var currstate = inputs.state[binding]\n    if (XOR(currstate, ct)) {\n        var emitter = wasDown ? inputs.down : inputs.up\n        emitter.emit(binding, ev)\n    }\n    inputs.state[binding] = !!ct\n}\n\n\n\n\n/*\n *\n *\n *    HELPERS\n *\n *\n*/\n\n\n// how is this not part of Javascript?\nfunction XOR(a, b) {\n    return a ? !b : b\n}\n\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/game-inputs/inputs.js?");

/***/ }),

/***/ "./node_modules/game-inputs/lib/mousewheel-polyfill.js":
/*!*************************************************************!*\
  !*** ./node_modules/game-inputs/lib/mousewheel-polyfill.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\n\nvar prefix = \"\", _addEventListener, onwheel, support;\n\n// detect event model\nif ( window.addEventListener ) {\n  _addEventListener = \"addEventListener\";\n} else {\n  _addEventListener = \"attachEvent\";\n  prefix = \"on\";\n}\n\n// detect available wheel event\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\n\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\n  elem[ _addEventListener ]( prefix + eventName, support == \"wheel\" ? callback : function( originalEvent ) {\n    !originalEvent && ( originalEvent = window.event );\n\n    // create a normalized event object\n    var event = {\n      // keep a ref to the original event object\n      originalEvent: originalEvent,\n      target: originalEvent.target || originalEvent.srcElement,\n      type: \"wheel\",\n      deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\n      deltaX: 0,\n      delatZ: 0,\n      preventDefault: function() {\n        originalEvent.preventDefault ?\n          originalEvent.preventDefault() :\n          originalEvent.returnValue = false;\n      }\n    };\n    \n    // calculate deltaY (and deltaX) according to the event\n    if ( support == \"mousewheel\" ) {\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\n      // Webkit also support wheelDeltaX\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\n    } else {\n      event.deltaY = originalEvent.detail;\n    }\n\n    // it's time to fire the callback\n    return callback( event );\n  }, useCapture || false );\n}\n\nmodule.exports = function( elem, callback, useCapture ) {\n  _addWheelListener( elem, support, callback, useCapture );\n\n  // handle MozMousePixelScroll in older Firefox\n  if( support == \"DOMMouseScroll\" ) {\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/game-inputs/lib/mousewheel-polyfill.js?");

/***/ }),

/***/ "./node_modules/game-shell/lib/hrtime-polyfill.js":
/*!********************************************************!*\
  !*** ./node_modules/game-shell/lib/hrtime-polyfill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if(typeof window.performance === \"object\") {\r\n  if(window.performance.now) {\r\n    module.exports = function() { return window.performance.now() }\r\n  } else if(window.performance.webkitNow) {\r\n    module.exports = function() { return window.performance.webkitNow() }\r\n  }\r\n} else if(Date.now) {\r\n  module.exports = Date.now\r\n} else {\r\n  module.exports = function() { return (new Date()).getTime() }\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/game-shell/lib/hrtime-polyfill.js?");

/***/ }),

/***/ "./node_modules/game-shell/lib/mousewheel-polyfill.js":
/*!************************************************************!*\
  !*** ./node_modules/game-shell/lib/mousewheel-polyfill.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//Adapted from here: https://developer.mozilla.org/en-US/docs/Web/Reference/Events/wheel?redirectlocale=en-US&redirectslug=DOM%2FMozilla_event_reference%2Fwheel\r\n\r\nvar prefix = \"\", _addEventListener, onwheel, support;\r\n\r\n// detect event model\r\nif ( window.addEventListener ) {\r\n  _addEventListener = \"addEventListener\";\r\n} else {\r\n  _addEventListener = \"attachEvent\";\r\n  prefix = \"on\";\r\n}\r\n\r\n// detect available wheel event\r\nsupport = \"onwheel\" in document.createElement(\"div\") ? \"wheel\" : // Modern browsers support \"wheel\"\r\n          document.onmousewheel !== undefined ? \"mousewheel\" : // Webkit and IE support at least \"mousewheel\"\r\n          \"DOMMouseScroll\"; // let's assume that remaining browsers are older Firefox\r\n\r\nfunction _addWheelListener( elem, eventName, callback, useCapture ) {\r\n  elem[ _addEventListener ]( prefix + eventName, support == \"wheel\" ? callback : function( originalEvent ) {\r\n    !originalEvent && ( originalEvent = window.event );\r\n\r\n    // create a normalized event object\r\n    var event = {\r\n      // keep a ref to the original event object\r\n      originalEvent: originalEvent,\r\n      target: originalEvent.target || originalEvent.srcElement,\r\n      type: \"wheel\",\r\n      deltaMode: originalEvent.type == \"MozMousePixelScroll\" ? 0 : 1,\r\n      deltaX: 0,\r\n      delatZ: 0,\r\n      preventDefault: function() {\r\n        originalEvent.preventDefault ?\r\n          originalEvent.preventDefault() :\r\n          originalEvent.returnValue = false;\r\n      }\r\n    };\r\n    \r\n    // calculate deltaY (and deltaX) according to the event\r\n    if ( support == \"mousewheel\" ) {\r\n      event.deltaY = - 1/40 * originalEvent.wheelDelta;\r\n      // Webkit also support wheelDeltaX\r\n      originalEvent.wheelDeltaX && ( event.deltaX = - 1/40 * originalEvent.wheelDeltaX );\r\n    } else {\r\n      event.deltaY = originalEvent.detail;\r\n    }\r\n\r\n    // it's time to fire the callback\r\n    return callback( event );\r\n  }, useCapture || false );\r\n}\r\n\r\nmodule.exports = function( elem, callback, useCapture ) {\r\n  _addWheelListener( elem, support, callback, useCapture );\r\n\r\n  // handle MozMousePixelScroll in older Firefox\r\n  if( support == \"DOMMouseScroll\" ) {\r\n    _addWheelListener( elem, \"MozMousePixelScroll\", callback, useCapture );\r\n  }\r\n};\n\n//# sourceURL=webpack:///./node_modules/game-shell/lib/mousewheel-polyfill.js?");

/***/ }),

/***/ "./node_modules/game-shell/lib/raf-polyfill.js":
/*!*****************************************************!*\
  !*** ./node_modules/game-shell/lib/raf-polyfill.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating\r\n \r\n// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel\r\n \r\n// MIT license\r\nvar lastTime = 0;\r\nvar vendors = ['ms', 'moz', 'webkit', 'o'];\r\nfor(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {\r\n    window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\r\n    window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] \r\n                               || window[vendors[x]+'CancelRequestAnimationFrame'];\r\n}\r\n\r\nif (!window.requestAnimationFrame)\r\n    window.requestAnimationFrame = function(callback, element) {\r\n        var currTime = new Date().getTime();\r\n        var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n        var id = window.setTimeout(function() { callback(currTime + timeToCall); }, \r\n          timeToCall);\r\n        lastTime = currTime + timeToCall;\r\n        return id;\r\n    };\r\n\r\nif (!window.cancelAnimationFrame)\r\n    window.cancelAnimationFrame = function(id) {\r\n        clearTimeout(id);\r\n    };\r\n\n\n//# sourceURL=webpack:///./node_modules/game-shell/lib/raf-polyfill.js?");

/***/ }),

/***/ "./node_modules/game-shell/node_modules/vkey/index.js":
/*!************************************************************!*\
  !*** ./node_modules/game-shell/node_modules/vkey/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 27: '<escape>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n\n\n//# sourceURL=webpack:///./node_modules/game-shell/node_modules/vkey/index.js?");

/***/ }),

/***/ "./node_modules/game-shell/shell.js":
/*!******************************************!*\
  !*** ./node_modules/game-shell/shell.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter\r\n  , util         = __webpack_require__(/*! util */ \"./node_modules/util/util.js\")\r\n  , domready     = __webpack_require__(/*! domready */ \"./node_modules/domready/ready.js\")\r\n  , vkey         = __webpack_require__(/*! vkey */ \"./node_modules/game-shell/node_modules/vkey/index.js\")\r\n  , invert       = __webpack_require__(/*! invert-hash */ \"./node_modules/invert-hash/invert.js\")\r\n  , uniq         = __webpack_require__(/*! uniq */ \"./node_modules/uniq/uniq.js\")\r\n  , bsearch      = __webpack_require__(/*! binary-search-bounds */ \"./node_modules/binary-search-bounds/search-bounds.js\")\r\n  , iota         = __webpack_require__(/*! iota-array */ \"./node_modules/iota-array/iota.js\")\r\n  , min          = Math.min\r\n\r\n//Browser compatibility hacks\r\n__webpack_require__(/*! ./lib/raf-polyfill.js */ \"./node_modules/game-shell/lib/raf-polyfill.js\")\r\nvar addMouseWheel = __webpack_require__(/*! ./lib/mousewheel-polyfill.js */ \"./node_modules/game-shell/lib/mousewheel-polyfill.js\")\r\nvar hrtime = __webpack_require__(/*! ./lib/hrtime-polyfill.js */ \"./node_modules/game-shell/lib/hrtime-polyfill.js\")\r\n\r\n//Remove angle braces and other useless crap\r\nvar filtered_vkey = (function() {\r\n  var result = new Array(256)\r\n    , i, j, k\r\n  for(i=0; i<256; ++i) {\r\n    result[i] = \"UNK\"\r\n  }\r\n  for(i in vkey) {\r\n    k = vkey[i]\r\n    if(k.charAt(0) === '<' && k.charAt(k.length-1) === '>') {\r\n      k = k.substring(1, k.length-1)\r\n    }\r\n    k = k.replace(/\\s/g, \"-\")\r\n    result[parseInt(i)] = k\r\n  }\r\n  return result\r\n})()\r\n\r\n//Compute minimal common set of keyboard functions\r\nvar keyNames = uniq(Object.keys(invert(filtered_vkey)))\r\n\r\n//Translates a virtual keycode to a normalized keycode\r\nfunction virtualKeyCode(key) {\r\n  return bsearch.eq(keyNames, key)\r\n}\r\n\r\n//Maps a physical keycode to a normalized keycode\r\nfunction physicalKeyCode(key) {\r\n  return virtualKeyCode(filtered_vkey[key])\r\n}\r\n\r\n//Game shell\r\nfunction GameShell() {\r\n  EventEmitter.call(this)\r\n  this._curKeyState  = new Array(keyNames.length)\r\n  this._pressCount   = new Array(keyNames.length)\r\n  this._releaseCount = new Array(keyNames.length)\r\n  \r\n  this._tickInterval = null\r\n  this._rafHandle = null\r\n  this._tickRate = 0\r\n  this._lastTick = hrtime()\r\n  this._frameTime = 0.0\r\n  this._paused = true\r\n  this._width = 0\r\n  this._height = 0\r\n  \r\n  this._wantFullscreen = false\r\n  this._wantPointerLock = false\r\n  this._fullscreenActive = false\r\n  this._pointerLockActive = false\r\n  \r\n  this._rafFunction = tickOrRender.bind(undefined, this, true)\r\n\r\n  this.preventDefaults = true\r\n  this.stopPropagation = false\r\n  \r\n  for(var i=0; i<keyNames.length; ++i) {\r\n    this._curKeyState[i] = false\r\n    this._pressCount[i] = this._releaseCount[i] = 0\r\n  }\r\n  \r\n  //Public members\r\n  this.element = null\r\n  this.bindings = {}\r\n  this.frameSkip = 100.0\r\n  this.tickCount = 0\r\n  this.frameCount = 0\r\n  this.startTime = hrtime()\r\n  this.tickTime = this._tickRate\r\n  this.frameTime = 10.0\r\n  this.stickyFullscreen = false\r\n  this.stickyPointerLock = false\r\n  \r\n  //Scroll stuff\r\n  this.scroll = [0,0,0]\r\n    \r\n  //Mouse state\r\n  this.mouseX = 0\r\n  this.mouseY = 0\r\n  this.prevMouseX = 0\r\n  this.prevMouseY = 0\r\n}\r\n\r\nutil.inherits(GameShell, EventEmitter)\r\n\r\nvar proto = GameShell.prototype\r\n\r\n//Bind keynames\r\nproto.keyNames = keyNames\r\n\r\n//Binds a virtual keyboard event to a physical key\r\nproto.bind = function(virtual_key) {\r\n  //Look up previous key bindings\r\n  var arr\r\n  if(virtual_key in this.bindings) {\r\n    arr = this.bindings[virtual_key]\r\n  } else {\r\n    arr = []\r\n  }\r\n  //Add keys to list\r\n  var physical_key\r\n  for(var i=1, n=arguments.length; i<n; ++i) {\r\n    physical_key = arguments[i]\r\n    if(virtualKeyCode(physical_key) >= 0) {\r\n      arr.push(physical_key)\r\n    } else if(physical_key in this.bindings) {\r\n      var keybinds = this.bindings[physical_key]\r\n      for(var j=0; j<keybinds.length; ++j) {\r\n        arr.push(keybinds[j])\r\n      }\r\n    }\r\n  }\r\n  //Remove any duplicate keys\r\n  arr = uniq(arr)\r\n  if(arr.length > 0) {\r\n    this.bindings[virtual_key] = arr\r\n  }\r\n  this.emit('bind', virtual_key, arr)\r\n}\r\n\r\n//Unbinds a virtual keyboard event\r\nproto.unbind = function(virtual_key) {\r\n  if(virtual_key in this.bindings) {\r\n    delete this.bindings[virtual_key]\r\n  }\r\n  this.emit('unbind', virtual_key)\r\n}\r\n\r\n//Checks if a key is set in a given state\r\nfunction lookupKey(state, bindings, key) {\r\n  if(key in bindings) {\r\n    var arr = bindings[key]\r\n    for(var i=0, n=arr.length; i<n; ++i) {\r\n      if(state[virtualKeyCode(arr[i])]) {\r\n        return true\r\n      }\r\n    }\r\n    return false\r\n  }\r\n  var kc = virtualKeyCode(key)\r\n  if(kc >= 0) {\r\n    return state[kc]\r\n  }\r\n  return false\r\n}\r\n\r\n//Checks if a key is set in a given state\r\nfunction lookupCount(state, bindings, key) {\r\n  if(key in bindings) {\r\n    var arr = bindings[key], r = 0\r\n    for(var i=0, n=arr.length; i<n; ++i) {\r\n      r += state[virtualKeyCode(arr[i])]\r\n    }\r\n    return r\r\n  }\r\n  var kc = virtualKeyCode(key)\r\n  if(kc >= 0) {\r\n    return state[kc]\r\n  }\r\n  return 0\r\n}\r\n\r\n//Checks if a key (either physical or virtual) is currently held down\r\nproto.down = function(key) {\r\n  return lookupKey(this._curKeyState, this.bindings, key)\r\n}\r\n\r\n//Checks if a key was ever down\r\nproto.wasDown = function(key) {\r\n  return this.down(key) || !!this.press(key)\r\n}\r\n\r\n//Opposite of down\r\nproto.up = function(key) {\r\n  return !this.down(key)\r\n}\r\n\r\n//Checks if a key was released during previous frame\r\nproto.wasUp = function(key) {\r\n  return this.up(key) || !!this.release(key)\r\n}\r\n\r\n//Returns the number of times a key was pressed since last tick\r\nproto.press = function(key) {\r\n  return lookupCount(this._pressCount, this.bindings, key)\r\n}\r\n\r\n//Returns the number of times a key was released since last tick\r\nproto.release = function(key) {\r\n  return lookupCount(this._releaseCount, this.bindings, key)\r\n}\r\n\r\n//Pause/unpause the game loop\r\nObject.defineProperty(proto, \"paused\", {\r\n  get: function() {\r\n    return this._paused\r\n  },\r\n  set: function(state) {\r\n    var ns = !!state\r\n    if(ns !== this._paused) {\r\n      if(!this._paused) {\r\n        this._paused = true\r\n        this._frameTime = min(1.0, (hrtime() - this._lastTick) / this._tickRate)\r\n        clearInterval(this._tickInterval)\r\n        //cancelAnimationFrame(this._rafHandle)\r\n      } else {\r\n        this._paused = false\r\n        this._lastTick = hrtime() - Math.floor(this._frameTime * this._tickRate)\r\n        this._tickInterval = setInterval(tickOrRender, this._tickRate, this, false)\r\n        this._rafHandle = requestAnimationFrame(this._rafFunction)\r\n      }\r\n    }\r\n  }\r\n})\r\n\r\n//Fullscreen state toggle\r\n\r\nfunction tryFullscreen(shell) {\r\n  //Request full screen\r\n  var elem = shell.element\r\n  \r\n  if(shell._wantFullscreen && !shell._fullscreenActive) {\r\n    var fs = elem.requestFullscreen ||\r\n             elem.requestFullScreen ||\r\n             elem.webkitRequestFullscreen ||\r\n             elem.webkitRequestFullScreen ||\r\n             elem.mozRequestFullscreen ||\r\n             elem.mozRequestFullScreen ||\r\n             function() {}\r\n    fs.call(elem)\r\n  }\r\n  if(shell._wantPointerLock && !shell._pointerLockActive) {\r\n    var pl =  elem.requestPointerLock ||\r\n              elem.webkitRequestPointerLock ||\r\n              elem.mozRequestPointerLock ||\r\n              elem.msRequestPointerLock ||\r\n              elem.oRequestPointerLock ||\r\n              function() {}\r\n    pl.call(elem)\r\n  }\r\n}\r\n\r\nvar cancelFullscreen = document.exitFullscreen ||\r\n                       document.cancelFullscreen ||  //Why can no one agree on this?\r\n                       document.cancelFullScreen ||\r\n                       document.webkitCancelFullscreen ||\r\n                       document.webkitCancelFullScreen ||\r\n                       document.mozCancelFullscreen ||\r\n                       document.mozCancelFullScreen ||\r\n                       function(){}\r\n\r\nObject.defineProperty(proto, \"fullscreen\", {\r\n  get: function() {\r\n    return this._fullscreenActive\r\n  },\r\n  set: function(state) {\r\n    var ns = !!state\r\n    if(!ns) {\r\n      this._wantFullscreen = false\r\n      var hasFS = document.fullscreen ||\r\n                  document.mozFullScreen ||\r\n                  document.webkitIsFullScreen ||\r\n                  false\r\n      if (hasFS) cancelFullscreen.call(document)\r\n    } else {\r\n      this._wantFullscreen = true\r\n      tryFullscreen(this)\r\n    }\r\n    return this._fullscreenActive\r\n  }\r\n})\r\n\r\nfunction handleFullscreen(shell) {\r\n  shell._fullscreenActive = document.fullscreen ||\r\n                            document.mozFullScreen ||\r\n                            document.webkitIsFullScreen ||\r\n                            false\r\n  if(!shell.stickyFullscreen && shell._fullscreenActive) {\r\n    shell._wantFullscreen = false\r\n  }\r\n}\r\n\r\n//Pointer lock state toggle\r\nvar exitPointerLock = document.exitPointerLock ||\r\n                      document.webkitExitPointerLock ||\r\n                      document.mozExitPointerLock ||\r\n                      function() {}\r\n\r\nObject.defineProperty(proto, \"pointerLock\", {\r\n  get: function() {\r\n    return this._pointerLockActive\r\n  },\r\n  set: function(state) {\r\n    var ns = !!state\r\n    if(!ns) {\r\n      this._wantPointerLock = false\r\n      exitPointerLock.call(document)\r\n    } else {\r\n      this._wantPointerLock = true\r\n      tryFullscreen(this)\r\n    }\r\n    return this._pointerLockActive\r\n  }\r\n})\r\n\r\nfunction handlePointerLockChange(shell, event) {\r\n  shell._pointerLockActive = shell.element === (\r\n      document.pointerLockElement ||\r\n      document.mozPointerLockElement ||\r\n      document.webkitPointerLockElement ||\r\n      null)\r\n  if(!shell.stickyPointerLock && shell._pointerLockActive) {\r\n    shell._wantPointerLock = false\r\n  }\r\n}\r\n\r\n//Width and height\r\nObject.defineProperty(proto, \"width\", {\r\n  get: function() {\r\n    return this.element.clientWidth\r\n  }\r\n})\r\nObject.defineProperty(proto, \"height\", {\r\n  get: function() {\r\n    return this.element.clientHeight\r\n  }\r\n})\r\n\r\n//Set key state\r\nfunction setKeyState(shell, key, state) {\r\n  var ps = shell._curKeyState[key]\r\n  if(ps !== state) {\r\n    if(state) {\r\n      shell._pressCount[key]++\r\n    } else {\r\n      shell._releaseCount[key]++\r\n    }\r\n    shell._curKeyState[key] = state\r\n  }\r\n}\r\n\r\nfunction tickOrRender(shell, doRender) {\r\n  tick(shell)\r\n  if (doRender) {\r\n    render(shell)\r\n  }\r\n}\r\n\r\n//Ticks the game state one update\r\nfunction tick(shell) {\r\n  var skip = hrtime() + shell.frameSkip\r\n    , pCount = shell._pressCount\r\n    , rCount = shell._releaseCount\r\n    , i, s, t\r\n    , tr = shell._tickRate\r\n    , n = keyNames.length\r\n  while(!shell._paused &&\r\n        hrtime() >= shell._lastTick + tr) {\r\n    \r\n    //Skip frames if we are over budget\r\n    if(hrtime() > skip) {\r\n      shell._lastTick = hrtime() + tr\r\n      return\r\n    }\r\n    \r\n    //Tick the game\r\n    s = hrtime()\r\n    shell.emit(\"tick\")\r\n    t = hrtime()\r\n    shell.tickTime = t - s\r\n    \r\n    //Update counters and time\r\n    ++shell.tickCount\r\n    shell._lastTick += tr\r\n    \r\n    //Shift input state\r\n    for(i=0; i<n; ++i) {\r\n      pCount[i] = rCount[i] = 0\r\n    }\r\n    if(shell._pointerLockActive) {\r\n      shell.prevMouseX = shell.mouseX = shell.width>>1\r\n      shell.prevMouseY = shell.mouseY = shell.height>>1\r\n    } else {\r\n      shell.prevMouseX = shell.mouseX\r\n      shell.prevMouseY = shell.mouseY\r\n    }\r\n    shell.scroll[0] = shell.scroll[1] = shell.scroll[2] = 0\r\n  }\r\n}\r\n\r\n//Render stuff\r\nfunction render(shell) {\r\n\r\n  //Request next frame\r\n  shell._rafHandle = requestAnimationFrame(shell._rafFunction)\r\n\r\n  //Compute frame time\r\n  var dt\r\n  if(shell._paused) {\r\n    dt = shell._frameTime\r\n  } else {\r\n    dt = min(1.0, (hrtime() - shell._lastTick) / shell._tickRate)\r\n  }\r\n  \r\n  //Draw a frame\r\n  ++shell.frameCount\r\n  var s = hrtime()\r\n  shell.emit(\"render\", dt)\r\n  var t = hrtime()\r\n  shell.frameTime = t - s\r\n  \r\n}\r\n\r\nfunction isFocused(shell) {\r\n  return (document.activeElement === document.body) ||\r\n         (document.activeElement === shell.element)\r\n}\r\n\r\nfunction handleEvent(shell, ev) {\r\n  if(shell.preventDefaults) {\r\n    ev.preventDefault()\r\n  }\r\n  if(shell.stopPropagation) {\r\n    ev.stopPropagation()\r\n  }\r\n}\r\n\r\n//Set key up\r\nfunction handleKeyUp(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  var kc = physicalKeyCode(ev.keyCode || ev.char || ev.which || ev.charCode)\r\n  if(kc >= 0) {\r\n    setKeyState(shell, kc, false)\r\n  }\r\n}\r\n\r\n//Set key down\r\nfunction handleKeyDown(shell, ev) {\r\n  if(!isFocused(shell)) {\r\n    return\r\n  }\r\n  handleEvent(shell, ev)\r\n  if(ev.metaKey) {\r\n    //Hack: Clear key state when meta gets pressed to prevent keys sticking\r\n    handleBlur(shell, ev)\r\n  } else {\r\n    var kc = physicalKeyCode(ev.keyCode || ev.char || ev.which || ev.charCode)\r\n    if(kc >= 0) {\r\n      setKeyState(shell, kc, true)\r\n    }\r\n  }\r\n}\r\n\r\n//Mouse events are really annoying\r\nvar mouseCodes = iota(32).map(function(n) {\r\n  return virtualKeyCode(\"mouse-\" + (n+1))\r\n})\r\n\r\nfunction setMouseButtons(shell, buttons) {\r\n  for(var i=0; i<32; ++i) {\r\n    setKeyState(shell, mouseCodes[i], !!(buttons & (1<<i)))\r\n  }\r\n}\r\n\r\nfunction handleMouseMove(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  if(shell._pointerLockActive) {\r\n    var movementX = ev.movementX       ||\r\n                    ev.mozMovementX    ||\r\n                    ev.webkitMovementX ||\r\n                    0,\r\n        movementY = ev.movementY       ||\r\n                    ev.mozMovementY    ||\r\n                    ev.webkitMovementY ||\r\n                    0\r\n    shell.mouseX += movementX\r\n    shell.mouseY += movementY\r\n  } else {\r\n    shell.mouseX = ev.clientX - shell.element.offsetLeft\r\n    shell.mouseY = ev.clientY - shell.element.offsetTop\r\n  }\r\n  return false\r\n}\r\n\r\nfunction handleMouseDown(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  setKeyState(shell, mouseCodes[ev.button], true)\r\n  return false\r\n}\r\n\r\nfunction handleMouseUp(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  setKeyState(shell, mouseCodes[ev.button], false)\r\n  return false\r\n}\r\n\r\nfunction handleMouseEnter(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  if(shell._pointerLockActive) {\r\n    shell.prevMouseX = shell.mouseX = shell.width>>1\r\n    shell.prevMouseY = shell.mouseY = shell.height>>1\r\n  } else {\r\n    shell.prevMouseX = shell.mouseX = ev.clientX - shell.element.offsetLeft\r\n    shell.prevMouseY = shell.mouseY = ev.clientY - shell.element.offsetTop\r\n  }\r\n  return false\r\n}\r\n\r\nfunction handleMouseLeave(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  setMouseButtons(shell, 0)\r\n  return false\r\n}\r\n\r\n//Handle mouse wheel events\r\nfunction handleMouseWheel(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  var scale = 1\r\n  switch(ev.deltaMode) {\r\n    case 0: //Pixel\r\n      scale = 1\r\n    break\r\n    case 1: //Line\r\n      scale = 12\r\n    break\r\n    case 2: //Page\r\n       scale = shell.height\r\n    break\r\n  }\r\n  //Add scroll\r\n  shell.scroll[0] +=  ev.deltaX * scale\r\n  shell.scroll[1] +=  ev.deltaY * scale\r\n  shell.scroll[2] += (ev.deltaZ * scale)||0.0\r\n  return false\r\n}\r\n\r\nfunction handleContexMenu(shell, ev) {\r\n  handleEvent(shell, ev)\r\n  return false\r\n}\r\n\r\nfunction handleBlur(shell, ev) {\r\n  var n = keyNames.length\r\n    , c = shell._curKeyState\r\n    , r = shell._releaseCount\r\n    , i\r\n  for(i=0; i<n; ++i) {\r\n    if(c[i]) {\r\n      ++r[i]\r\n    }\r\n    c[i] = false\r\n  }\r\n  return false\r\n}\r\n\r\nfunction handleResizeElement(shell, ev) {\r\n  var w = shell.element.clientWidth|0\r\n  var h = shell.element.clientHeight|0\r\n  if((w !== shell._width) || (h !== shell._height)) {\r\n    shell._width = w\r\n    shell._height = h\r\n    shell.emit(\"resize\", w, h)\r\n  }\r\n}\r\n\r\nfunction makeDefaultContainer() {\r\n  var container = document.createElement(\"div\")\r\n  container.tabindex = 1\r\n  container.style.position = \"absolute\"\r\n  container.style.left = \"0px\"\r\n  container.style.right = \"0px\"\r\n  container.style.top = \"0px\"\r\n  container.style.bottom = \"0px\"\r\n  container.style.height = \"100%\"\r\n  container.style.overflow = \"hidden\"\r\n  document.body.appendChild(container)\r\n  document.body.style.overflow = \"hidden\" //Prevent bounce\r\n  document.body.style.height = \"100%\"\r\n  return container\r\n}\r\n\r\nfunction createShell(options) {\r\n  options = options || {}\r\n  \r\n  //Check fullscreen and pointer lock flags\r\n  var useFullscreen = !!options.fullscreen\r\n  var usePointerLock = useFullscreen\r\n  if(typeof options.pointerLock !== undefined) {\r\n    usePointerLock = !!options.pointerLock\r\n  }\r\n  \r\n  //Create initial shell\r\n  var shell = new GameShell()\r\n  shell._tickRate = options.tickRate || 30\r\n  shell.frameSkip = options.frameSkip || (shell._tickRate+5) * 5\r\n  shell.stickyFullscreen = !!options.stickyFullscreen || !!options.sticky\r\n  shell.stickyPointerLock = !!options.stickyPointerLock || !!options.sticky\r\n  \r\n  //Set bindings\r\n  if(options.bindings) {\r\n    shell.bindings = options.bindings\r\n  }\r\n  \r\n  //Wait for dom to intiailize\r\n  setTimeout(function() { domready(function initGameShell() {\r\n    \r\n    //Retrieve element\r\n    var element = options.element\r\n    if(typeof element === \"string\") {\r\n      var e = document.querySelector(element)\r\n      if(!e) {\r\n        e = document.getElementById(element)\r\n      }\r\n      if(!e) {\r\n        e = document.getElementByClass(element)[0]\r\n      }\r\n      if(!e) {\r\n        e = makeDefaultContainer()\r\n      }\r\n      shell.element = e\r\n    } else if(typeof element === \"object\" && !!element) {\r\n      shell.element = element\r\n    } else if(typeof element === \"function\") {\r\n      shell.element = element()\r\n    } else {\r\n      shell.element = makeDefaultContainer()\r\n    }\r\n    \r\n    //Disable user-select\r\n    if(shell.element.style) {\r\n      shell.element.style[\"-webkit-touch-callout\"] = \"none\"\r\n      shell.element.style[\"-webkit-user-select\"] = \"none\"\r\n      shell.element.style[\"-khtml-user-select\"] = \"none\"\r\n      shell.element.style[\"-moz-user-select\"] = \"none\"\r\n      shell.element.style[\"-ms-user-select\"] = \"none\"\r\n      shell.element.style[\"user-select\"] = \"none\"\r\n    }\r\n    \r\n    //Hook resize handler\r\n    shell._width = shell.element.clientWidth\r\n    shell._height = shell.element.clientHeight\r\n    var handleResize = handleResizeElement.bind(undefined, shell)\r\n    if(typeof MutationObserver !== \"undefined\") {\r\n      var observer = new MutationObserver(handleResize)\r\n      observer.observe(shell.element, {\r\n        attributes: true,\r\n        subtree: true\r\n      })\r\n    } else {\r\n      shell.element.addEventListener(\"DOMSubtreeModified\", handleResize, false)\r\n    }\r\n    window.addEventListener(\"resize\", handleResize, false)\r\n    \r\n    //Hook keyboard listener\r\n    window.addEventListener(\"keydown\", handleKeyDown.bind(undefined, shell), false)\r\n    window.addEventListener(\"keyup\", handleKeyUp.bind(undefined, shell), false)\r\n    \r\n    //Disable right click\r\n    shell.element.oncontextmenu = handleContexMenu.bind(undefined, shell)\r\n    \r\n    //Hook mouse listeners\r\n    shell.element.addEventListener(\"mousedown\", handleMouseDown.bind(undefined, shell), false)\r\n    shell.element.addEventListener(\"mouseup\", handleMouseUp.bind(undefined, shell), false)\r\n    shell.element.addEventListener(\"mousemove\", handleMouseMove.bind(undefined, shell), false)\r\n    shell.element.addEventListener(\"mouseenter\", handleMouseEnter.bind(undefined, shell), false)\r\n    \r\n    //Mouse leave\r\n    var leave = handleMouseLeave.bind(undefined, shell)\r\n    shell.element.addEventListener(\"mouseleave\", leave, false)\r\n    shell.element.addEventListener(\"mouseout\", leave, false)\r\n    window.addEventListener(\"mouseleave\", leave, false)\r\n    window.addEventListener(\"mouseout\", leave, false)\r\n    \r\n    //Blur event \r\n    var blur = handleBlur.bind(undefined, shell)\r\n    shell.element.addEventListener(\"blur\", blur, false)\r\n    shell.element.addEventListener(\"focusout\", blur, false)\r\n    shell.element.addEventListener(\"focus\", blur, false)\r\n    window.addEventListener(\"blur\", blur, false)\r\n    window.addEventListener(\"focusout\", blur, false)\r\n    window.addEventListener(\"focus\", blur, false)\r\n\r\n    //Mouse wheel handler\r\n    addMouseWheel(shell.element, handleMouseWheel.bind(undefined, shell), false)\r\n\r\n    //Fullscreen handler\r\n    var fullscreenChange = handleFullscreen.bind(undefined, shell)\r\n    document.addEventListener(\"fullscreenchange\", fullscreenChange, false)\r\n    document.addEventListener(\"mozfullscreenchange\", fullscreenChange, false)\r\n    document.addEventListener(\"webkitfullscreenchange\", fullscreenChange, false)\r\n\r\n    //Stupid fullscreen hack\r\n    shell.element.addEventListener(\"click\", tryFullscreen.bind(undefined, shell), false)\r\n\r\n    //Pointer lock change handler\r\n    var pointerLockChange = handlePointerLockChange.bind(undefined, shell)\r\n    document.addEventListener(\"pointerlockchange\", pointerLockChange, false)\r\n    document.addEventListener(\"mozpointerlockchange\", pointerLockChange, false)\r\n    document.addEventListener(\"webkitpointerlockchange\", pointerLockChange, false)\r\n    document.addEventListener(\"pointerlocklost\", pointerLockChange, false)\r\n    document.addEventListener(\"webkitpointerlocklost\", pointerLockChange, false)\r\n    document.addEventListener(\"mozpointerlocklost\", pointerLockChange, false)\r\n    \r\n    //Update flags\r\n    shell.fullscreen = useFullscreen\r\n    shell.pointerLock = usePointerLock\r\n  \r\n    //Default mouse button aliases\r\n    shell.bind(\"mouse-left\",   \"mouse-1\")\r\n    shell.bind(\"mouse-right\",  \"mouse-3\")\r\n    shell.bind(\"mouse-middle\", \"mouse-2\")\r\n    \r\n    //Initialize tick counter\r\n    shell._lastTick = hrtime()\r\n    shell.startTime = hrtime()\r\n\r\n    //Unpause shell\r\n    shell.paused = false\r\n    \r\n    //Emit initialize event\r\n    shell.emit(\"init\")\r\n  })}, 0)\r\n  \r\n  return shell\r\n}\r\n\r\nmodule.exports = createShell\r\n\n\n//# sourceURL=webpack:///./node_modules/game-shell/shell.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/add.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/add.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/add.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/angle.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/angle.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = angle\n\nvar fromValues = __webpack_require__(/*! ./fromValues */ \"./node_modules/gl-vec3/fromValues.js\")\nvar normalize = __webpack_require__(/*! ./normalize */ \"./node_modules/gl-vec3/normalize.js\")\nvar dot = __webpack_require__(/*! ./dot */ \"./node_modules/gl-vec3/dot.js\")\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/angle.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/ceil.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/ceil.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ceil\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0])\n  out[1] = Math.ceil(a[1])\n  out[2] = Math.ceil(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/ceil.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/clone.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/clone.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = clone;\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n    var out = new Float32Array(3)\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/clone.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/copy.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/copy.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/copy.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/create.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/create.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = create;\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n    var out = new Float32Array(3)\n    out[0] = 0\n    out[1] = 0\n    out[2] = 0\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/create.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/cross.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/cross.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/cross.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/dist.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/dist.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./distance */ \"./node_modules/gl-vec3/distance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/dist.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/distance.js":
/*!******************************************!*\
  !*** ./node_modules/gl-vec3/distance.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = distance;\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/distance.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/div.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/div.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./divide */ \"./node_modules/gl-vec3/divide.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/div.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/divide.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/divide.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = divide;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n    out[0] = a[0] / b[0]\n    out[1] = a[1] / b[1]\n    out[2] = a[2] / b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/divide.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/dot.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/dot.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/dot.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/epsilon.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/epsilon.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 0.000001\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/epsilon.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/equals.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/equals.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = equals\n\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/gl-vec3/epsilon.js\")\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/equals.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/exactEquals.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-vec3/exactEquals.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exactEquals\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/exactEquals.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/floor.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/floor.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = floor\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0])\n  out[1] = Math.floor(a[1])\n  out[2] = Math.floor(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/floor.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/forEach.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/forEach.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = forEach;\n\nvar vec = __webpack_require__(/*! ./create */ \"./node_modules/gl-vec3/create.js\")()\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nfunction forEach(a, stride, offset, count, fn, arg) {\n        var i, l\n        if(!stride) {\n            stride = 3\n        }\n\n        if(!offset) {\n            offset = 0\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length)\n        } else {\n            l = a.length\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i] \n            vec[1] = a[i+1] \n            vec[2] = a[i+2]\n            fn(vec, vec, arg)\n            a[i] = vec[0] \n            a[i+1] = vec[1] \n            a[i+2] = vec[2]\n        }\n        \n        return a\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/forEach.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/fromValues.js":
/*!********************************************!*\
  !*** ./node_modules/gl-vec3/fromValues.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/fromValues.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/index.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  EPSILON: __webpack_require__(/*! ./epsilon */ \"./node_modules/gl-vec3/epsilon.js\")\n  , create: __webpack_require__(/*! ./create */ \"./node_modules/gl-vec3/create.js\")\n  , clone: __webpack_require__(/*! ./clone */ \"./node_modules/gl-vec3/clone.js\")\n  , angle: __webpack_require__(/*! ./angle */ \"./node_modules/gl-vec3/angle.js\")\n  , fromValues: __webpack_require__(/*! ./fromValues */ \"./node_modules/gl-vec3/fromValues.js\")\n  , copy: __webpack_require__(/*! ./copy */ \"./node_modules/gl-vec3/copy.js\")\n  , set: __webpack_require__(/*! ./set */ \"./node_modules/gl-vec3/set.js\")\n  , equals: __webpack_require__(/*! ./equals */ \"./node_modules/gl-vec3/equals.js\")\n  , exactEquals: __webpack_require__(/*! ./exactEquals */ \"./node_modules/gl-vec3/exactEquals.js\")\n  , add: __webpack_require__(/*! ./add */ \"./node_modules/gl-vec3/add.js\")\n  , subtract: __webpack_require__(/*! ./subtract */ \"./node_modules/gl-vec3/subtract.js\")\n  , sub: __webpack_require__(/*! ./sub */ \"./node_modules/gl-vec3/sub.js\")\n  , multiply: __webpack_require__(/*! ./multiply */ \"./node_modules/gl-vec3/multiply.js\")\n  , mul: __webpack_require__(/*! ./mul */ \"./node_modules/gl-vec3/mul.js\")\n  , divide: __webpack_require__(/*! ./divide */ \"./node_modules/gl-vec3/divide.js\")\n  , div: __webpack_require__(/*! ./div */ \"./node_modules/gl-vec3/div.js\")\n  , min: __webpack_require__(/*! ./min */ \"./node_modules/gl-vec3/min.js\")\n  , max: __webpack_require__(/*! ./max */ \"./node_modules/gl-vec3/max.js\")\n  , floor: __webpack_require__(/*! ./floor */ \"./node_modules/gl-vec3/floor.js\")\n  , ceil: __webpack_require__(/*! ./ceil */ \"./node_modules/gl-vec3/ceil.js\")\n  , round: __webpack_require__(/*! ./round */ \"./node_modules/gl-vec3/round.js\")\n  , scale: __webpack_require__(/*! ./scale */ \"./node_modules/gl-vec3/scale.js\")\n  , scaleAndAdd: __webpack_require__(/*! ./scaleAndAdd */ \"./node_modules/gl-vec3/scaleAndAdd.js\")\n  , distance: __webpack_require__(/*! ./distance */ \"./node_modules/gl-vec3/distance.js\")\n  , dist: __webpack_require__(/*! ./dist */ \"./node_modules/gl-vec3/dist.js\")\n  , squaredDistance: __webpack_require__(/*! ./squaredDistance */ \"./node_modules/gl-vec3/squaredDistance.js\")\n  , sqrDist: __webpack_require__(/*! ./sqrDist */ \"./node_modules/gl-vec3/sqrDist.js\")\n  , length: __webpack_require__(/*! ./length */ \"./node_modules/gl-vec3/length.js\")\n  , len: __webpack_require__(/*! ./len */ \"./node_modules/gl-vec3/len.js\")\n  , squaredLength: __webpack_require__(/*! ./squaredLength */ \"./node_modules/gl-vec3/squaredLength.js\")\n  , sqrLen: __webpack_require__(/*! ./sqrLen */ \"./node_modules/gl-vec3/sqrLen.js\")\n  , negate: __webpack_require__(/*! ./negate */ \"./node_modules/gl-vec3/negate.js\")\n  , inverse: __webpack_require__(/*! ./inverse */ \"./node_modules/gl-vec3/inverse.js\")\n  , normalize: __webpack_require__(/*! ./normalize */ \"./node_modules/gl-vec3/normalize.js\")\n  , dot: __webpack_require__(/*! ./dot */ \"./node_modules/gl-vec3/dot.js\")\n  , cross: __webpack_require__(/*! ./cross */ \"./node_modules/gl-vec3/cross.js\")\n  , lerp: __webpack_require__(/*! ./lerp */ \"./node_modules/gl-vec3/lerp.js\")\n  , random: __webpack_require__(/*! ./random */ \"./node_modules/gl-vec3/random.js\")\n  , transformMat4: __webpack_require__(/*! ./transformMat4 */ \"./node_modules/gl-vec3/transformMat4.js\")\n  , transformMat3: __webpack_require__(/*! ./transformMat3 */ \"./node_modules/gl-vec3/transformMat3.js\")\n  , transformQuat: __webpack_require__(/*! ./transformQuat */ \"./node_modules/gl-vec3/transformQuat.js\")\n  , rotateX: __webpack_require__(/*! ./rotateX */ \"./node_modules/gl-vec3/rotateX.js\")\n  , rotateY: __webpack_require__(/*! ./rotateY */ \"./node_modules/gl-vec3/rotateY.js\")\n  , rotateZ: __webpack_require__(/*! ./rotateZ */ \"./node_modules/gl-vec3/rotateZ.js\")\n  , forEach: __webpack_require__(/*! ./forEach */ \"./node_modules/gl-vec3/forEach.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/index.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/inverse.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/inverse.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = inverse;\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0]\n  out[1] = 1.0 / a[1]\n  out[2] = 1.0 / a[2]\n  return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/inverse.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/len.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/len.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./length */ \"./node_modules/gl-vec3/length.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/len.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/length.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/length.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = length;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/length.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/lerp.js":
/*!**************************************!*\
  !*** ./node_modules/gl-vec3/lerp.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = lerp;\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2]\n    out[0] = ax + t * (b[0] - ax)\n    out[1] = ay + t * (b[1] - ay)\n    out[2] = az + t * (b[2] - az)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/lerp.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/max.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/max.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = max;\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n    out[0] = Math.max(a[0], b[0])\n    out[1] = Math.max(a[1], b[1])\n    out[2] = Math.max(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/max.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/min.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/min.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = min;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n    out[0] = Math.min(a[0], b[0])\n    out[1] = Math.min(a[1], b[1])\n    out[2] = Math.min(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/min.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/mul.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/mul.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./multiply */ \"./node_modules/gl-vec3/multiply.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/mul.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/multiply.js":
/*!******************************************!*\
  !*** ./node_modules/gl-vec3/multiply.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = multiply;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n    out[0] = a[0] * b[0]\n    out[1] = a[1] * b[1]\n    out[2] = a[2] * b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/multiply.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/negate.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/negate.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = negate;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n    out[0] = -a[0]\n    out[1] = -a[1]\n    out[2] = -a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/negate.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/normalize.js":
/*!*******************************************!*\
  !*** ./node_modules/gl-vec3/normalize.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/normalize.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/random.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/random.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = random;\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n    scale = scale || 1.0\n\n    var r = Math.random() * 2.0 * Math.PI\n    var z = (Math.random() * 2.0) - 1.0\n    var zScale = Math.sqrt(1.0-z*z) * scale\n\n    out[0] = Math.cos(r) * zScale\n    out[1] = Math.sin(r) * zScale\n    out[2] = z * scale\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/random.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateX.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateX.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/rotateX.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateY.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateY.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/rotateY.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/rotateZ.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/rotateZ.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/rotateZ.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/round.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/round.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = round\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0])\n  out[1] = Math.round(a[1])\n  out[2] = Math.round(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/round.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/scale.js":
/*!***************************************!*\
  !*** ./node_modules/gl-vec3/scale.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scale;\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n    out[0] = a[0] * b\n    out[1] = a[1] * b\n    out[2] = a[2] * b\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/scale.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/scaleAndAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/gl-vec3/scaleAndAdd.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/scaleAndAdd.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/set.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/set.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/set.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/sqrDist.js":
/*!*****************************************!*\
  !*** ./node_modules/gl-vec3/sqrDist.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredDistance */ \"./node_modules/gl-vec3/squaredDistance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/sqrDist.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/sqrLen.js":
/*!****************************************!*\
  !*** ./node_modules/gl-vec3/sqrLen.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredLength */ \"./node_modules/gl-vec3/squaredLength.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/sqrLen.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/squaredDistance.js":
/*!*************************************************!*\
  !*** ./node_modules/gl-vec3/squaredDistance.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredDistance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/squaredDistance.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/squaredLength.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/squaredLength.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredLength;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/squaredLength.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/sub.js":
/*!*************************************!*\
  !*** ./node_modules/gl-vec3/sub.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./subtract */ \"./node_modules/gl-vec3/subtract.js\")\n\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/sub.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/subtract.js":
/*!******************************************!*\
  !*** ./node_modules/gl-vec3/subtract.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = subtract;\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n    out[0] = a[0] - b[0]\n    out[1] = a[1] - b[1]\n    out[2] = a[2] - b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/subtract.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/transformMat3.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/transformMat3.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat3;\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n    var x = a[0], y = a[1], z = a[2]\n    out[0] = x * m[0] + y * m[3] + z * m[6]\n    out[1] = x * m[1] + y * m[4] + z * m[7]\n    out[2] = x * m[2] + y * m[5] + z * m[8]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/transformMat3.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/transformMat4.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/transformMat4.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/transformMat4.js?");

/***/ }),

/***/ "./node_modules/gl-vec3/transformQuat.js":
/*!***********************************************!*\
  !*** ./node_modules/gl-vec3/transformQuat.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformQuat;\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/gl-vec3/transformQuat.js?");

/***/ }),

/***/ "./node_modules/global/window.js":
/*!***************************************!*\
  !*** ./node_modules/global/window.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/global/window.js?");

/***/ }),

/***/ "./node_modules/has/src/index.js":
/*!***************************************!*\
  !*** ./node_modules/has/src/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\n\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\n\n\n//# sourceURL=webpack:///./node_modules/has/src/index.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack:///./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/invert-hash/invert.js":
/*!********************************************!*\
  !*** ./node_modules/invert-hash/invert.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction invert(hash) {\n  var result = {}\n  for(var i in hash) {\n    if(hash.hasOwnProperty(i)) {\n      result[hash[i]] = i\n    }\n  }\n  return result\n}\n\nmodule.exports = invert\n\n//# sourceURL=webpack:///./node_modules/invert-hash/invert.js?");

/***/ }),

/***/ "./node_modules/iota-array/iota.js":
/*!*****************************************!*\
  !*** ./node_modules/iota-array/iota.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction iota(n) {\n  var result = new Array(n)\n  for(var i=0; i<n; ++i) {\n    result[i] = i\n  }\n  return result\n}\n\nmodule.exports = iota\n\n//# sourceURL=webpack:///./node_modules/iota-array/iota.js?");

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n\n//# sourceURL=webpack:///./node_modules/is-buffer/index.js?");

/***/ }),

/***/ "./node_modules/is-callable/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-callable/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar fnToStr = Function.prototype.toString;\n\nvar constructorRegex = /^\\s*class\\b/;\nvar isES6ClassFn = function isES6ClassFunction(value) {\n\ttry {\n\t\tvar fnStr = fnToStr.call(value);\n\t\treturn constructorRegex.test(fnStr);\n\t} catch (e) {\n\t\treturn false; // not a function\n\t}\n};\n\nvar tryFunctionObject = function tryFunctionToStr(value) {\n\ttry {\n\t\tif (isES6ClassFn(value)) { return false; }\n\t\tfnToStr.call(value);\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nvar toStr = Object.prototype.toString;\nvar fnClass = '[object Function]';\nvar genClass = '[object GeneratorFunction]';\nvar hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nmodule.exports = function isCallable(value) {\n\tif (!value) { return false; }\n\tif (typeof value !== 'function' && typeof value !== 'object') { return false; }\n\tif (typeof value === 'function' && !value.prototype) { return true; }\n\tif (hasToStringTag) { return tryFunctionObject(value); }\n\tif (isES6ClassFn(value)) { return false; }\n\tvar strClass = toStr.call(value);\n\treturn strClass === fnClass || strClass === genClass;\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-callable/index.js?");

/***/ }),

/***/ "./node_modules/is-function/index.js":
/*!*******************************************!*\
  !*** ./node_modules/is-function/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = isFunction\n\nvar toString = Object.prototype.toString\n\nfunction isFunction (fn) {\n  var string = toString.call(fn)\n  return string === '[object Function]' ||\n    (typeof fn === 'function' && string !== '[object RegExp]') ||\n    (typeof window !== 'undefined' &&\n     // IE8 and below\n     (fn === window.setTimeout ||\n      fn === window.alert ||\n      fn === window.confirm ||\n      fn === window.prompt))\n};\n\n\n//# sourceURL=webpack:///./node_modules/is-function/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack:///./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/load-json-xhr/index.js":
/*!*********************************************!*\
  !*** ./node_modules/load-json-xhr/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var xhr = __webpack_require__(/*! xhr */ \"./node_modules/xhr/index.js\");\n\nmodule.exports = function getJSON(opt, cb) {\n  cb = typeof cb === 'function' ? cb : noop;\n\n  if (typeof opt === 'string')\n    opt = { uri: opt };\n  else if (!opt)\n    opt = { };\n\n  // if (!opt.headers)\n  //   opt.headers = { \"Content-Type\": \"application/json\" };\n\n  var jsonResponse = /^json$/i.test(opt.responseType);\n  return xhr(opt, function(err, res, body) {\n    if (err)\n      return cb(err);\n    if (!/^2/.test(res.statusCode))\n      return cb(new Error('http status code: ' + res.statusCode));\n\n    if (jsonResponse) { \n      cb(null, body);\n    } else {\n      var data;\n      try {\n        data = JSON.parse(body);\n      } catch (e) {\n        cb(new Error('cannot parse json: ' + e));\n      }\n      if(data) cb(null, data);\n    }\n  })\n}\n\nfunction noop() {}\n\n//# sourceURL=webpack:///./node_modules/load-json-xhr/index.js?");

/***/ }),

/***/ "./node_modules/mesh-particle-system/index.js":
/*!****************************************************!*\
  !*** ./node_modules/mesh-particle-system/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* global BABYLON */\n\nmodule.exports = MeshParticleSystem;\n\n\nvar vec3 = BABYLON.Vector3;\nvar col3 = BABYLON.Color3;\n\n\n\n\n/*\n *    particle data structure\n*/\n\nfunction ParticleData () {\n  this.position = vec3.Zero()\n  this.velocity = vec3.Zero()\n  this.size = 1.0\n  this.age = 0.0\n  this.lifetime = 1.0 // seconds\n}\n\n\n/*\n *    Over-writeable user functions\n*/\n\nfunction initParticle(pdata) {\n  pdata.position.copyFromFloats(0,0,0)\n  pdata.velocity.x = 5 * (Math.random() - 0.5);\n  pdata.velocity.y = 5 * (Math.random() * 0.5) + 2;\n  pdata.velocity.z = 5 * (Math.random() - 0.5);\n  pdata.size = 1*Math.random();\n  pdata.age = 0;\n  pdata.lifetime = 2;\n}\n\n\n\n\n/*\n *    system ctor\n*/\n\nfunction MeshParticleSystem(capacity, rate, texture, scene) {\n\n  // public\n  this.capacity = capacity;\n  this.rate = rate;\n  this.mesh = new BABYLON.Mesh('SPS-mesh', scene);\n  this.material = new BABYLON.StandardMaterial(\"SPS-mat\", scene);\n  this.texture = texture;\n  this.gravity = -1;\n  this.disposeOnEmpty = false;\n  this.stopOnEmpty = false;\n  this.parent = null;\n  this.onDispose = null;\n\n  // internal\n  this._scene = scene;\n  this._alive = 0;\n  this._data = new Float32Array(capacity*9) // pos*3, vel*3, size, age, lifetime\n  this._dummyParticle = new ParticleData()\n  this._color0 = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0)\n  this._color1 = new BABYLON.Color4(1.0, 1.0, 1.0, 1.0)\n  this._updateColors = true;\n  this._size0 = 1.0;\n  this._size1 = 1.0;\n  this._positions = [];\n  this._colors = [];\n  this._playing = false;\n  this._disposed = false;\n  this._lastPos = vec3.Zero();\n  this._startingThisFrame = false;\n  this._toEmit = 0;\n\n  // init mesh and vertex data\n  var positions = this._positions;\n  var colors = this._colors;\n  var indices = [];\n  var uvs = [];\n  // quads : 2 triangles per particle\n  for (var p = 0; p < capacity; p ++) {\n    positions.push(0,0,0,  0,0,0,  0,0,0,  0,0,0);\n    indices.push(p*4, p*4+1, p*4+2);\n    indices.push(p*4, p*4+2, p*4+3);\n    uvs.push(0,1, 1,1, 1,0, 0,0);\n    colors.push( 1,0,1,1,  1,0,1,1,  1,0,1,1,  1,0,1,1 );\n  }\n  var vertexData = new BABYLON.VertexData();\n  vertexData.positions = positions;\n  vertexData.indices = indices;\n  vertexData.uvs = uvs;\n  vertexData.colors = colors;\n\n  vertexData.applyToMesh(this.mesh, true);\n\n  // init material\n  this.mesh.material = this.material\n  this.material.specularColor = col3.Black();\n  this.material.checkReadyOnlyOnce = true;\n\n  // configurable functions\n  this.initParticle = initParticle;\n\n  // initialize mat/color/alpha settings\n  updateColorSettings(this)\n\n  // curried animate function\n  var self = this;\n  var lastTime = performance.now();\n  this.curriedAnimate = function curriedAnimate() {\n    var t = performance.now();    // ms\n    var s = (t-lastTime) / 1000;  // sec\n    self.animate(s);\n    lastTime = t;\n  }\n  \n  // debugging..\n  // this.mesh.showBoundingBox = true;\n}\n\nvar MPS = MeshParticleSystem;\n\n/*\n *    \n *    API\n *    \n*/\n\n\nMPS.prototype.start = function startMPS() {\n  if (this._playing) return;\n  if (this._disposed) throw new Error('Already disposed');\n  this._scene.registerBeforeRender( this.curriedAnimate );\n  recalculateBounds(this);\n  this._playing = true;\n  this._startingThisFrame = true;\n};\n\nMPS.prototype.stop = function stopMPS() {\n  if (!this._playing) return;\n  this._scene.unregisterBeforeRender( this.curriedAnimate );\n  this._playing = false;\n};\n\nMPS.prototype.setAlphaRange = function setAlphas(from, to) {\n  this._color0.a = from;\n  this._color1.a = to;\n  updateColorSettings(this);\n};\n\nMPS.prototype.setColorRange = function setColors(from, to) {\n  this._color0.r = from.r;\n  this._color0.g = from.g;\n  this._color0.b = from.b;\n  this._color1.r = to.r;\n  this._color1.g = to.g;\n  this._color1.b = to.b;\n  updateColorSettings(this);\n};\n\nMPS.prototype.setSizeRange = function setSizes(from, to) {\n  this._size0 = from;\n  this._size1 = to;\n};\n\nMPS.prototype.emit = function mpsEmit(count) {\n  this.start();\n  this._toEmit += count;\n};\n\nMPS.prototype.dispose = function mpsDispose() {\n  if (this.onDispose) this.onDispose()\n  disposeMPS(this);\n};\n\n\n\n/*\n *    \n *    Internals\n *    \n*/\n\n\n// set mesh/mat properties based on color/alpha parameters\nfunction updateColorSettings(sys) {\n  var c0 = sys._color0;\n  var c1 = sys._color1;\n  var doAlpha = !( equal(c0.a, 1) && equal(c0.a, c1.a) );\n  var doColor = !( equal(c0.r, c1.r) && equal(c0.g, c1.g) && equal(c0.b, c1.b) );\n\n  sys.mesh.hasVertexAlpha = doAlpha;\n  if (doColor || doAlpha) {\n    sys.material.ambientTexture = sys.texture;\n    sys.material.opacityTexture = sys.texture;\n    sys.material.diffuseTexture = null;\n    sys.texture.hasAlpha = false;\n    sys.material.useAlphaFromDiffuseTexture = true;\n    sys.material.diffuseColor = col3.White();\n  } else {\n    sys.material.diffuseTexture = sys.texture;\n    sys.material.ambientTexture = null;\n    sys.material.opacityTexture = null;\n    sys.texture.hasAlpha = true;\n    sys.material.useAlphaFromDiffuseTexture = false;\n    sys.material.diffuseColor = c0;\n  }\n\n  sys._updateColors = doAlpha || doColor;\n}\nfunction equal(a,b) {\n  return (Math.abs(a-b) < 1e-5)\n}\n\n\nfunction recalculateBounds(system) {\n  // toooootal hack.\n  var reps = 30;\n  var p = system._dummyParticle;\n  var s = 0,\n      min = new vec3( Infinity, Infinity, Infinity ),\n      max = new vec3(-Infinity,-Infinity,-Infinity );\n  var halfg = system.gravity / 2;\n  for (var i=0; i<reps; ++i) {\n    system.initParticle(p);\n    updateMinMax(min, max, p.position.x, p.position.y, p.position.z)\n    // x1 = x0 + v*t + 1/2*a*t^2\n    var t = p.lifetime;\n    var x = p.position.x + t*p.velocity.x;\n    var y = p.position.y + t*p.velocity.y + t*t*halfg;\n    var z = p.position.z + t*p.velocity.z;\n    updateMinMax(min, max, x, y, z)\n    s = Math.max( s, p.size );\n  }\n  min.subtractFromFloatsToRef( s,  s,  s, min);\n  max.subtractFromFloatsToRef(-s, -s, -s, max);  // no addFromFloats, for some reason\n  system.mesh._boundingInfo = new BABYLON.BoundingInfo(min, max);\n}\nfunction updateMinMax(min, max, x, y, z) {\n  if (x<min.x) min.x = x; else if (x>max.x) max.x = x;\n  if (y<min.y) min.y = y; else if (y>max.y) max.y = y;\n  if (z<min.z) min.z = z; else if (z>max.z) max.z = z;\n}\n\n\n\nfunction addNewParticle(sys) {\n  // pass dummy data structure to user-definable init fcn\n  var part = sys._dummyParticle\n  sys.initParticle(part)\n  // copy particle data into internal Float32Array\n  var data = sys._data\n  var ix = sys._alive * 9\n  data[ix]   = part.position.x\n  data[ix+1] = part.position.y\n  data[ix+2] = part.position.z\n  data[ix+3] = part.velocity.x\n  data[ix+4] = part.velocity.y\n  data[ix+5] = part.velocity.z\n  data[ix+6] = part.size\n  data[ix+7] = part.age\n  data[ix+8] = part.lifetime\n  sys._alive += 1\n}\n\nfunction removeParticle(sys, n) {\n  // copy particle data from last live location to removed location\n  var data = sys._data\n  var from = (sys._alive-1) * 9\n  var to = n * 9\n  for (var i=0; i<9; ++i) {\n    data[to+i] = data[from+i]\n  }\n  sys._alive -= 1;\n}\n\n\n\n/*\n *    animate all the particles!\n*/\n\nMPS.prototype.animate = function animateSPS(dt) {\n  if (dt > 0.1) dt = 0.1;\n\n  // adjust particles if mesh has moved\n  adjustParticlesForMovement(this)\n  \n  // add/update/remove particles\n  spawnParticles(this, this.rate * dt)\n  updateAndRecycle(this, dt)\n\n  // write new position/color data\n  updatePositionsData(this)\n  if (this._updateColors) updateColorsArray(this)\n\n  // only draw active mesh positions\n  this.mesh.subMeshes[0].indexCount = this._alive*6\n\n  // possibly stop/dispose if no rate and no living particles\n  if (this._alive===0 && this.rate===0) {\n    if (this.disposeOnEmpty) this.dispose();\n    else if (this.stopOnEmpty) this.stop();\n  }\n};\n\n\nfunction spawnParticles(system, count) {\n  system._toEmit += count;\n  var toAdd = Math.floor(system._toEmit);\n  system._toEmit -= toAdd;\n  var ct = system._alive + toAdd;\n  if (ct > system.capacity) ct = system.capacity;\n  while (system._alive < ct) {\n    addNewParticle(system);\n  }\n}\n\nfunction updateAndRecycle(system, dt) {\n  // update particles and remove any that pass recycle check\n  var grav = system.gravity * dt\n  var data = system._data\n  for (var i=0; i<system._alive; ++i) {\n    var ix = i * 9\n    data[ix+4] += grav                  // vel.y += g * dt\n    data[ix]   += data[ix+3] * dt\n    data[ix+1] += data[ix+4] * dt       // pos += vel * dt\n    data[ix+2] += data[ix+5] * dt\n    var t = data[ix+7] + dt             // t = age + dt\n    if (t > data[ix+8]) {               // if (t>lifetime)..\n      removeParticle(system, i)\n      i--;\n    } else {\n      data[ix+7] = t;                   // age = dt\n    }\n  }\n}\n\n\n// if mesh system has moved since last frame, adjust particles to compensate\n\nfunction adjustParticlesForMovement(system) {\n  // relocate to parent if needed\n  if (system.parent) {\n    var p = system.parent.absolutePosition;\n    if (system._startingThisFrame) {\n      // bug workaround: on first frame parent may be newly created\n      p = system.parent.getAbsolutePosition();\n      system._startingThisFrame = false;\n    }\n    system.mesh.position.copyFrom(p)\n  }\n  var dx = system.mesh.position.x - system._lastPos.x;\n  var dy = system.mesh.position.y - system._lastPos.y;\n  var dz = system.mesh.position.z - system._lastPos.z;\n  system._lastPos.copyFrom( system.mesh.position );\n  if (Math.abs(dx) + Math.abs(dy) + Math.abs(dz) < .001) return;\n    \n  var alive = system._alive;\n  var data = system._data;\n  for (var i=0; i<alive; i++) {\n    var di = i*9;\n    data[di]   -= dx;\n    data[di+1] -= dy;\n    data[di+2] -= dz;\n  }\n}\n\n\nfunction updatePositionsData(system) {\n  var positions = system._positions;\n  var data = system._data;\n  var cam = system._scene.activeCamera;\n\n  // prepare transform\n  var mat = BABYLON.Matrix.Identity();\n  BABYLON.Matrix.LookAtLHToRef(cam.globalPosition,      // eye\n                               system.mesh.position,    // target\n                               vec3.Up(), mat);\n  mat.m[12] = mat.m[13] = mat.m[14] = 0;\n  mat.invert();\n  var m = mat.m\n\n  var alive = system._alive;\n  var s0 = system._size0;\n  var ds = system._size1 - s0;\n\n  for (var i=0; i<alive; i++) {\n    var di = i*9;\n    var scale = data[di+7] / data[di+8];\n    var size = data[di+6] * (s0 + ds*scale) / 2;\n\n    var idx = i*12;\n    for (var pt=0; pt<4; pt++) {\n\n      var vx = (pt===1 || pt===2) ? size : -size;\n      var vy = (pt>1) ? size : -size;\n      \n      // following is unrolled version of Vector3.TransformCoordinatesToRef\n      // minus the bits zeroed out due to having no z coord\n      \n      var w = (vx * m[3]) + (vy * m[7]) + m[15];\n      positions[idx]   = data[di]   + (vx * m[0] + vy * m[4])/w;\n      positions[idx+1] = data[di+1] + (vx * m[1] + vy * m[5])/w;\n      positions[idx+2] = data[di+2] + (vx * m[2] + vy * m[6])/w;\n\n      idx += 3;\n    }\n  }\n\n  system.mesh.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions, false, false);\n}\n\n\n\nfunction updateColorsArray(system) {\n  var alive = system._alive;\n  var data = system._data;\n  var colors = system._colors;\n\n  var r0 = system._color0.r;\n  var g0 = system._color0.g;\n  var b0 = system._color0.b;\n  var a0 = system._color0.a;\n  var dr = system._color1.r - r0;\n  var dg = system._color1.g - g0;\n  var db = system._color1.b - b0;\n  var da = system._color1.a - a0;\n\n  for (var i=0; i<alive; i++) {\n    var di = i*9;\n\n    var scale = data[di+7] / data[di+8];\n    // scale alpha from startAlpha to endAlpha by (age/lifespan)\n    var r = r0 + dr * scale;\n    var g = g0 + dg * scale;\n    var b = b0 + db * scale;\n    var a = a0 + da * scale;\n\n    var idx = i*16;\n    for (var pt=0; pt<4; pt++) {\n      colors[idx]   = r;\n      colors[idx+1] = g;\n      colors[idx+2] = b;\n      colors[idx+3] = a;\n      idx += 4;\n    }\n  }\n\n  system.mesh.updateVerticesData(BABYLON.VertexBuffer.ColorKind, colors, false, false);\n}\n\n\n\n// dispose function\n\nfunction disposeMPS(system) {\n  system.stop();\n  system.material.ambientTexture = null;\n  system.material.opacityTexture = null;\n  system.material.diffuseTexture = null;\n  system.material.dispose();\n  system.material = null;\n  system.mesh.geometry.dispose();\n  system.mesh.dispose();\n  system.mesh = null;\n  system.texture = null;\n  system.curriedAnimate = null;\n  system.initParticle = null;\n  system._scene = null;\n  system._dummyParticle = null;\n  system._color0 = null;\n  system._color1 = null;\n  system._data = null;\n  system._positions.length = 0;\n  system._colors.length = 0;\n  system._positions = null;\n  system._colors = null;\n  system.parent = null;\n  system._disposed = true;\n}\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/mesh-particle-system/index.js?");

/***/ }),

/***/ "./node_modules/ndarray/ndarray.js":
/*!*****************************************!*\
  !*** ./node_modules/ndarray/ndarray.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ \"./node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n\n\n//# sourceURL=webpack:///./node_modules/ndarray/ndarray.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/add.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/add.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/add.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/angle.js":
/*!***************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/angle.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = angle\n\nvar fromValues = __webpack_require__(/*! ./fromValues */ \"./node_modules/noa-engine/node_modules/gl-vec3/fromValues.js\")\nvar normalize = __webpack_require__(/*! ./normalize */ \"./node_modules/noa-engine/node_modules/gl-vec3/normalize.js\")\nvar dot = __webpack_require__(/*! ./dot */ \"./node_modules/noa-engine/node_modules/gl-vec3/dot.js\")\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/angle.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/ceil.js":
/*!**************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/ceil.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ceil\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0])\n  out[1] = Math.ceil(a[1])\n  out[2] = Math.ceil(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/ceil.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/clone.js":
/*!***************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/clone.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = clone;\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n    var out = new Float32Array(3)\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/clone.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/copy.js":
/*!**************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/copy.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/copy.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/create.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = create;\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n    var out = new Float32Array(3)\n    out[0] = 0\n    out[1] = 0\n    out[2] = 0\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/create.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/cross.js":
/*!***************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/cross.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/cross.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/dist.js":
/*!**************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/dist.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./distance */ \"./node_modules/noa-engine/node_modules/gl-vec3/distance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/dist.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/distance.js":
/*!******************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/distance.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = distance;\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/distance.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/div.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/div.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./divide */ \"./node_modules/noa-engine/node_modules/gl-vec3/divide.js\")\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/div.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/divide.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/divide.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = divide;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n    out[0] = a[0] / b[0]\n    out[1] = a[1] / b[1]\n    out[2] = a[2] / b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/divide.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/dot.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/dot.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/dot.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/epsilon.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/epsilon.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 0.000001\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/epsilon.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/equals.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/equals.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = equals\n\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/noa-engine/node_modules/gl-vec3/epsilon.js\")\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/equals.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/exactEquals.js":
/*!*********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/exactEquals.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exactEquals\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/exactEquals.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/floor.js":
/*!***************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/floor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = floor\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0])\n  out[1] = Math.floor(a[1])\n  out[2] = Math.floor(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/floor.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/forEach.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/forEach.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = forEach;\n\nvar vec = __webpack_require__(/*! ./create */ \"./node_modules/noa-engine/node_modules/gl-vec3/create.js\")()\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nfunction forEach(a, stride, offset, count, fn, arg) {\n        var i, l\n        if(!stride) {\n            stride = 3\n        }\n\n        if(!offset) {\n            offset = 0\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length)\n        } else {\n            l = a.length\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i] \n            vec[1] = a[i+1] \n            vec[2] = a[i+2]\n            fn(vec, vec, arg)\n            a[i] = vec[0] \n            a[i+1] = vec[1] \n            a[i+2] = vec[2]\n        }\n        \n        return a\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/forEach.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/fromValues.js":
/*!********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/fromValues.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/fromValues.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  EPSILON: __webpack_require__(/*! ./epsilon */ \"./node_modules/noa-engine/node_modules/gl-vec3/epsilon.js\")\n  , create: __webpack_require__(/*! ./create */ \"./node_modules/noa-engine/node_modules/gl-vec3/create.js\")\n  , clone: __webpack_require__(/*! ./clone */ \"./node_modules/noa-engine/node_modules/gl-vec3/clone.js\")\n  , angle: __webpack_require__(/*! ./angle */ \"./node_modules/noa-engine/node_modules/gl-vec3/angle.js\")\n  , fromValues: __webpack_require__(/*! ./fromValues */ \"./node_modules/noa-engine/node_modules/gl-vec3/fromValues.js\")\n  , copy: __webpack_require__(/*! ./copy */ \"./node_modules/noa-engine/node_modules/gl-vec3/copy.js\")\n  , set: __webpack_require__(/*! ./set */ \"./node_modules/noa-engine/node_modules/gl-vec3/set.js\")\n  , equals: __webpack_require__(/*! ./equals */ \"./node_modules/noa-engine/node_modules/gl-vec3/equals.js\")\n  , exactEquals: __webpack_require__(/*! ./exactEquals */ \"./node_modules/noa-engine/node_modules/gl-vec3/exactEquals.js\")\n  , add: __webpack_require__(/*! ./add */ \"./node_modules/noa-engine/node_modules/gl-vec3/add.js\")\n  , subtract: __webpack_require__(/*! ./subtract */ \"./node_modules/noa-engine/node_modules/gl-vec3/subtract.js\")\n  , sub: __webpack_require__(/*! ./sub */ \"./node_modules/noa-engine/node_modules/gl-vec3/sub.js\")\n  , multiply: __webpack_require__(/*! ./multiply */ \"./node_modules/noa-engine/node_modules/gl-vec3/multiply.js\")\n  , mul: __webpack_require__(/*! ./mul */ \"./node_modules/noa-engine/node_modules/gl-vec3/mul.js\")\n  , divide: __webpack_require__(/*! ./divide */ \"./node_modules/noa-engine/node_modules/gl-vec3/divide.js\")\n  , div: __webpack_require__(/*! ./div */ \"./node_modules/noa-engine/node_modules/gl-vec3/div.js\")\n  , min: __webpack_require__(/*! ./min */ \"./node_modules/noa-engine/node_modules/gl-vec3/min.js\")\n  , max: __webpack_require__(/*! ./max */ \"./node_modules/noa-engine/node_modules/gl-vec3/max.js\")\n  , floor: __webpack_require__(/*! ./floor */ \"./node_modules/noa-engine/node_modules/gl-vec3/floor.js\")\n  , ceil: __webpack_require__(/*! ./ceil */ \"./node_modules/noa-engine/node_modules/gl-vec3/ceil.js\")\n  , round: __webpack_require__(/*! ./round */ \"./node_modules/noa-engine/node_modules/gl-vec3/round.js\")\n  , scale: __webpack_require__(/*! ./scale */ \"./node_modules/noa-engine/node_modules/gl-vec3/scale.js\")\n  , scaleAndAdd: __webpack_require__(/*! ./scaleAndAdd */ \"./node_modules/noa-engine/node_modules/gl-vec3/scaleAndAdd.js\")\n  , distance: __webpack_require__(/*! ./distance */ \"./node_modules/noa-engine/node_modules/gl-vec3/distance.js\")\n  , dist: __webpack_require__(/*! ./dist */ \"./node_modules/noa-engine/node_modules/gl-vec3/dist.js\")\n  , squaredDistance: __webpack_require__(/*! ./squaredDistance */ \"./node_modules/noa-engine/node_modules/gl-vec3/squaredDistance.js\")\n  , sqrDist: __webpack_require__(/*! ./sqrDist */ \"./node_modules/noa-engine/node_modules/gl-vec3/sqrDist.js\")\n  , length: __webpack_require__(/*! ./length */ \"./node_modules/noa-engine/node_modules/gl-vec3/length.js\")\n  , len: __webpack_require__(/*! ./len */ \"./node_modules/noa-engine/node_modules/gl-vec3/len.js\")\n  , squaredLength: __webpack_require__(/*! ./squaredLength */ \"./node_modules/noa-engine/node_modules/gl-vec3/squaredLength.js\")\n  , sqrLen: __webpack_require__(/*! ./sqrLen */ \"./node_modules/noa-engine/node_modules/gl-vec3/sqrLen.js\")\n  , negate: __webpack_require__(/*! ./negate */ \"./node_modules/noa-engine/node_modules/gl-vec3/negate.js\")\n  , inverse: __webpack_require__(/*! ./inverse */ \"./node_modules/noa-engine/node_modules/gl-vec3/inverse.js\")\n  , normalize: __webpack_require__(/*! ./normalize */ \"./node_modules/noa-engine/node_modules/gl-vec3/normalize.js\")\n  , dot: __webpack_require__(/*! ./dot */ \"./node_modules/noa-engine/node_modules/gl-vec3/dot.js\")\n  , cross: __webpack_require__(/*! ./cross */ \"./node_modules/noa-engine/node_modules/gl-vec3/cross.js\")\n  , lerp: __webpack_require__(/*! ./lerp */ \"./node_modules/noa-engine/node_modules/gl-vec3/lerp.js\")\n  , random: __webpack_require__(/*! ./random */ \"./node_modules/noa-engine/node_modules/gl-vec3/random.js\")\n  , transformMat4: __webpack_require__(/*! ./transformMat4 */ \"./node_modules/noa-engine/node_modules/gl-vec3/transformMat4.js\")\n  , transformMat3: __webpack_require__(/*! ./transformMat3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/transformMat3.js\")\n  , transformQuat: __webpack_require__(/*! ./transformQuat */ \"./node_modules/noa-engine/node_modules/gl-vec3/transformQuat.js\")\n  , rotateX: __webpack_require__(/*! ./rotateX */ \"./node_modules/noa-engine/node_modules/gl-vec3/rotateX.js\")\n  , rotateY: __webpack_require__(/*! ./rotateY */ \"./node_modules/noa-engine/node_modules/gl-vec3/rotateY.js\")\n  , rotateZ: __webpack_require__(/*! ./rotateZ */ \"./node_modules/noa-engine/node_modules/gl-vec3/rotateZ.js\")\n  , forEach: __webpack_require__(/*! ./forEach */ \"./node_modules/noa-engine/node_modules/gl-vec3/forEach.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/index.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/inverse.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/inverse.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = inverse;\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0]\n  out[1] = 1.0 / a[1]\n  out[2] = 1.0 / a[2]\n  return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/inverse.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/len.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/len.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./length */ \"./node_modules/noa-engine/node_modules/gl-vec3/length.js\")\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/len.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/length.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/length.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = length;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/length.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/lerp.js":
/*!**************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/lerp.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = lerp;\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2]\n    out[0] = ax + t * (b[0] - ax)\n    out[1] = ay + t * (b[1] - ay)\n    out[2] = az + t * (b[2] - az)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/lerp.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/max.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/max.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = max;\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n    out[0] = Math.max(a[0], b[0])\n    out[1] = Math.max(a[1], b[1])\n    out[2] = Math.max(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/max.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/min.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/min.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = min;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n    out[0] = Math.min(a[0], b[0])\n    out[1] = Math.min(a[1], b[1])\n    out[2] = Math.min(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/min.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/mul.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/mul.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./multiply */ \"./node_modules/noa-engine/node_modules/gl-vec3/multiply.js\")\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/mul.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/multiply.js":
/*!******************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/multiply.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = multiply;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n    out[0] = a[0] * b[0]\n    out[1] = a[1] * b[1]\n    out[2] = a[2] * b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/multiply.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/negate.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/negate.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = negate;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n    out[0] = -a[0]\n    out[1] = -a[1]\n    out[2] = -a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/negate.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/normalize.js":
/*!*******************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/normalize.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/normalize.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/random.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/random.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = random;\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n    scale = scale || 1.0\n\n    var r = Math.random() * 2.0 * Math.PI\n    var z = (Math.random() * 2.0) - 1.0\n    var zScale = Math.sqrt(1.0-z*z) * scale\n\n    out[0] = Math.cos(r) * zScale\n    out[1] = Math.sin(r) * zScale\n    out[2] = z * scale\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/random.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/rotateX.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/rotateX.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/rotateX.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/rotateY.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/rotateY.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/rotateY.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/rotateZ.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/rotateZ.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/rotateZ.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/round.js":
/*!***************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/round.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = round\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0])\n  out[1] = Math.round(a[1])\n  out[2] = Math.round(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/round.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/scale.js":
/*!***************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/scale.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scale;\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n    out[0] = a[0] * b\n    out[1] = a[1] * b\n    out[2] = a[2] * b\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/scale.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/scaleAndAdd.js":
/*!*********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/scaleAndAdd.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/scaleAndAdd.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/set.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/set.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/set.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/sqrDist.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/sqrDist.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredDistance */ \"./node_modules/noa-engine/node_modules/gl-vec3/squaredDistance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/sqrDist.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/sqrLen.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/sqrLen.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredLength */ \"./node_modules/noa-engine/node_modules/gl-vec3/squaredLength.js\")\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/sqrLen.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/squaredDistance.js":
/*!*************************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/squaredDistance.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredDistance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/squaredDistance.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/squaredLength.js":
/*!***********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/squaredLength.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredLength;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/squaredLength.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/sub.js":
/*!*************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/sub.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./subtract */ \"./node_modules/noa-engine/node_modules/gl-vec3/subtract.js\")\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/sub.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/subtract.js":
/*!******************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/subtract.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = subtract;\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n    out[0] = a[0] - b[0]\n    out[1] = a[1] - b[1]\n    out[2] = a[2] - b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/subtract.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/transformMat3.js":
/*!***********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/transformMat3.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat3;\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n    var x = a[0], y = a[1], z = a[2]\n    out[0] = x * m[0] + y * m[3] + z * m[6]\n    out[1] = x * m[1] + y * m[4] + z * m[7]\n    out[2] = x * m[2] + y * m[5] + z * m[8]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/transformMat3.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/transformMat4.js":
/*!***********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/transformMat4.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/transformMat4.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/gl-vec3/transformQuat.js":
/*!***********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/gl-vec3/transformQuat.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformQuat;\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/gl-vec3/transformQuat.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js":
/*!*********************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nvar ndarray = __webpack_require__(/*! ndarray */ \"./node_modules/noa-engine/node_modules/ndarray/ndarray.js\")\r\nvar useMaps = !(typeof Map === \"undefined\")\r\n\r\nfunction HashMap(n) {\r\n  this.length = n\r\n  this.store = useMaps ? new Map() : {}\r\n}\r\n\r\nif (useMaps) {\r\n  HashMap.prototype.get = function(i) {\r\n    return this.store.get(i) || 0\r\n  }\r\n  HashMap.prototype.set = function(i,v) {\r\n    if (v===0) {\r\n      this.store.delete(i)\r\n    } else {\r\n      this.store.set(i, v)\r\n    }\r\n    return v\r\n  }\r\n} else { // Using a polyfill would be neater, but this works as well \r\n  HashMap.prototype.get = function(i) {\r\n    return this.store[i] || 0\r\n  }\r\n  HashMap.prototype.set = function(i,v) {\r\n    if (v===0) {\r\n      delete this.store[i]\r\n    } else {\r\n      this.store[i] = v\r\n    }\r\n    return v\r\n  }\r\n}\r\n\r\nfunction createNDHash(shape) {\r\n  var sz = 1\r\n  for(var i=0; i<shape.length; ++i) {\r\n    sz *= shape[i]\r\n  }\r\n  return ndarray(new HashMap(sz), shape)\r\n}\r\n\r\nmodule.exports = createNDHash\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js?");

/***/ }),

/***/ "./node_modules/noa-engine/node_modules/ndarray/ndarray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/node_modules/ndarray/ndarray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var iota = __webpack_require__(/*! iota-array */ \"./node_modules/iota-array/iota.js\")\nvar isBuffer = __webpack_require__(/*! is-buffer */ \"./node_modules/is-buffer/index.js\")\n\nvar hasTypedArrays  = ((typeof Float64Array) !== \"undefined\")\n\nfunction compare1st(a, b) {\n  return a[0] - b[0]\n}\n\nfunction order() {\n  var stride = this.stride\n  var terms = new Array(stride.length)\n  var i\n  for(i=0; i<terms.length; ++i) {\n    terms[i] = [Math.abs(stride[i]), i]\n  }\n  terms.sort(compare1st)\n  var result = new Array(terms.length)\n  for(i=0; i<result.length; ++i) {\n    result[i] = terms[i][1]\n  }\n  return result\n}\n\nfunction compileConstructor(dtype, dimension) {\n  var className = [\"View\", dimension, \"d\", dtype].join(\"\")\n  if(dimension < 0) {\n    className = \"View_Nil\" + dtype\n  }\n  var useGetters = (dtype === \"generic\")\n\n  if(dimension === -1) {\n    //Special case for trivial arrays\n    var code =\n      \"function \"+className+\"(a){this.data=a;};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return -1};\\\nproto.size=0;\\\nproto.dimension=-1;\\\nproto.shape=proto.stride=proto.order=[];\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\nfunction(){return new \"+className+\"(this.data);};\\\nproto.get=proto.set=function(){};\\\nproto.pick=function(){return null};\\\nreturn function construct_\"+className+\"(a){return new \"+className+\"(a);}\"\n    var procedure = new Function(code)\n    return procedure()\n  } else if(dimension === 0) {\n    //Special case for 0d arrays\n    var code =\n      \"function \"+className+\"(a,d) {\\\nthis.data = a;\\\nthis.offset = d\\\n};\\\nvar proto=\"+className+\".prototype;\\\nproto.dtype='\"+dtype+\"';\\\nproto.index=function(){return this.offset};\\\nproto.dimension=0;\\\nproto.size=1;\\\nproto.shape=\\\nproto.stride=\\\nproto.order=[];\\\nproto.lo=\\\nproto.hi=\\\nproto.transpose=\\\nproto.step=function \"+className+\"_copy() {\\\nreturn new \"+className+\"(this.data,this.offset)\\\n};\\\nproto.pick=function \"+className+\"_pick(){\\\nreturn TrivialArray(this.data);\\\n};\\\nproto.valueOf=proto.get=function \"+className+\"_get(){\\\nreturn \"+(useGetters ? \"this.data.get(this.offset)\" : \"this.data[this.offset]\")+\n\"};\\\nproto.set=function \"+className+\"_set(v){\\\nreturn \"+(useGetters ? \"this.data.set(this.offset,v)\" : \"this.data[this.offset]=v\")+\"\\\n};\\\nreturn function construct_\"+className+\"(a,b,c,d){return new \"+className+\"(a,d)}\"\n    var procedure = new Function(\"TrivialArray\", code)\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\n  }\n\n  var code = [\"'use strict'\"]\n\n  //Create constructor for view\n  var indices = iota(dimension)\n  var args = indices.map(function(i) { return \"i\"+i })\n  var index_str = \"this.offset+\" + indices.map(function(i) {\n        return \"this.stride[\" + i + \"]*i\" + i\n      }).join(\"+\")\n  var shapeArg = indices.map(function(i) {\n      return \"b\"+i\n    }).join(\",\")\n  var strideArg = indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")\n  code.push(\n    \"function \"+className+\"(a,\" + shapeArg + \",\" + strideArg + \",d){this.data=a\",\n      \"this.shape=[\" + shapeArg + \"]\",\n      \"this.stride=[\" + strideArg + \"]\",\n      \"this.offset=d|0}\",\n    \"var proto=\"+className+\".prototype\",\n    \"proto.dtype='\"+dtype+\"'\",\n    \"proto.dimension=\"+dimension)\n\n  //view.size:\n  code.push(\"Object.defineProperty(proto,'size',{get:function \"+className+\"_size(){\\\nreturn \"+indices.map(function(i) { return \"this.shape[\"+i+\"]\" }).join(\"*\"),\n\"}})\")\n\n  //view.order:\n  if(dimension === 1) {\n    code.push(\"proto.order=[0]\")\n  } else {\n    code.push(\"Object.defineProperty(proto,'order',{get:\")\n    if(dimension < 4) {\n      code.push(\"function \"+className+\"_order(){\")\n      if(dimension === 2) {\n        code.push(\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\")\n      } else if(dimension === 3) {\n        code.push(\n\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\nif(s0>s1){\\\nif(s1>s2){\\\nreturn [2,1,0];\\\n}else if(s0>s2){\\\nreturn [1,2,0];\\\n}else{\\\nreturn [1,0,2];\\\n}\\\n}else if(s0>s2){\\\nreturn [2,0,1];\\\n}else if(s2>s1){\\\nreturn [0,1,2];\\\n}else{\\\nreturn [0,2,1];\\\n}}})\")\n      }\n    } else {\n      code.push(\"ORDER})\")\n    }\n  }\n\n  //view.set(i0, ..., v):\n  code.push(\n\"proto.set=function \"+className+\"_set(\"+args.join(\",\")+\",v){\")\n  if(useGetters) {\n    code.push(\"return this.data.set(\"+index_str+\",v)}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]=v}\")\n  }\n\n  //view.get(i0, ...):\n  code.push(\"proto.get=function \"+className+\"_get(\"+args.join(\",\")+\"){\")\n  if(useGetters) {\n    code.push(\"return this.data.get(\"+index_str+\")}\")\n  } else {\n    code.push(\"return this.data[\"+index_str+\"]}\")\n  }\n\n  //view.index:\n  code.push(\n    \"proto.index=function \"+className+\"_index(\", args.join(), \"){return \"+index_str+\"}\")\n\n  //view.hi():\n  code.push(\"proto.hi=function \"+className+\"_hi(\"+args.join(\",\")+\"){return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return [\"(typeof i\",i,\"!=='number'||i\",i,\"<0)?this.shape[\", i, \"]:i\", i,\"|0\"].join(\"\")\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"this.stride[\"+i + \"]\"\n    }).join(\",\")+\",this.offset)}\")\n\n  //view.lo():\n  var a_vars = indices.map(function(i) { return \"a\"+i+\"=this.shape[\"+i+\"]\" })\n  var c_vars = indices.map(function(i) { return \"c\"+i+\"=this.stride[\"+i+\"]\" })\n  code.push(\"proto.lo=function \"+className+\"_lo(\"+args.join(\",\")+\"){var b=this.offset,d=0,\"+a_vars.join(\",\")+\",\"+c_vars.join(\",\"))\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){\\\nd=i\"+i+\"|0;\\\nb+=c\"+i+\"*d;\\\na\"+i+\"-=d}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\"+i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"c\"+i\n    }).join(\",\")+\",b)}\")\n\n  //view.step():\n  code.push(\"proto.step=function \"+className+\"_step(\"+args.join(\",\")+\"){var \"+\n    indices.map(function(i) {\n      return \"a\"+i+\"=this.shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\"+i+\"=this.stride[\"+i+\"]\"\n    }).join(\",\")+\",c=this.offset,d=0,ceil=Math.ceil\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\n\"if(typeof i\"+i+\"==='number'){\\\nd=i\"+i+\"|0;\\\nif(d<0){\\\nc+=b\"+i+\"*(a\"+i+\"-1);\\\na\"+i+\"=ceil(-a\"+i+\"/d)\\\n}else{\\\na\"+i+\"=ceil(a\"+i+\"/d)\\\n}\\\nb\"+i+\"*=d\\\n}\")\n  }\n  code.push(\"return new \"+className+\"(this.data,\"+\n    indices.map(function(i) {\n      return \"a\" + i\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"b\" + i\n    }).join(\",\")+\",c)}\")\n\n  //view.transpose():\n  var tShape = new Array(dimension)\n  var tStride = new Array(dimension)\n  for(var i=0; i<dimension; ++i) {\n    tShape[i] = \"a[i\"+i+\"]\"\n    tStride[i] = \"b[i\"+i+\"]\"\n  }\n  code.push(\"proto.transpose=function \"+className+\"_transpose(\"+args+\"){\"+\n    args.map(function(n,idx) { return n + \"=(\" + n + \"===undefined?\" + idx + \":\" + n + \"|0)\"}).join(\";\"),\n    \"var a=this.shape,b=this.stride;return new \"+className+\"(this.data,\"+tShape.join(\",\")+\",\"+tStride.join(\",\")+\",this.offset)}\")\n\n  //view.pick():\n  code.push(\"proto.pick=function \"+className+\"_pick(\"+args+\"){var a=[],b=[],c=this.offset\")\n  for(var i=0; i<dimension; ++i) {\n    code.push(\"if(typeof i\"+i+\"==='number'&&i\"+i+\">=0){c=(c+this.stride[\"+i+\"]*i\"+i+\")|0}else{a.push(this.shape[\"+i+\"]);b.push(this.stride[\"+i+\"])}\")\n  }\n  code.push(\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\")\n\n  //Add return statement\n  code.push(\"return function construct_\"+className+\"(data,shape,stride,offset){return new \"+className+\"(data,\"+\n    indices.map(function(i) {\n      return \"shape[\"+i+\"]\"\n    }).join(\",\")+\",\"+\n    indices.map(function(i) {\n      return \"stride[\"+i+\"]\"\n    }).join(\",\")+\",offset)}\")\n\n  //Compile procedure\n  var procedure = new Function(\"CTOR_LIST\", \"ORDER\", code.join(\"\\n\"))\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\n}\n\nfunction arrayDType(data) {\n  if(isBuffer(data)) {\n    return \"buffer\"\n  }\n  if(hasTypedArrays) {\n    switch(Object.prototype.toString.call(data)) {\n      case \"[object Float64Array]\":\n        return \"float64\"\n      case \"[object Float32Array]\":\n        return \"float32\"\n      case \"[object Int8Array]\":\n        return \"int8\"\n      case \"[object Int16Array]\":\n        return \"int16\"\n      case \"[object Int32Array]\":\n        return \"int32\"\n      case \"[object Uint8Array]\":\n        return \"uint8\"\n      case \"[object Uint16Array]\":\n        return \"uint16\"\n      case \"[object Uint32Array]\":\n        return \"uint32\"\n      case \"[object Uint8ClampedArray]\":\n        return \"uint8_clamped\"\n    }\n  }\n  if(Array.isArray(data)) {\n    return \"array\"\n  }\n  return \"generic\"\n}\n\nvar CACHED_CONSTRUCTORS = {\n  \"float32\":[],\n  \"float64\":[],\n  \"int8\":[],\n  \"int16\":[],\n  \"int32\":[],\n  \"uint8\":[],\n  \"uint16\":[],\n  \"uint32\":[],\n  \"array\":[],\n  \"uint8_clamped\":[],\n  \"buffer\":[],\n  \"generic\":[]\n}\n\n;(function() {\n  for(var id in CACHED_CONSTRUCTORS) {\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\n  }\n});\n\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\n  if(data === undefined) {\n    var ctor = CACHED_CONSTRUCTORS.array[0]\n    return ctor([])\n  } else if(typeof data === \"number\") {\n    data = [data]\n  }\n  if(shape === undefined) {\n    shape = [ data.length ]\n  }\n  var d = shape.length\n  if(stride === undefined) {\n    stride = new Array(d)\n    for(var i=d-1, sz=1; i>=0; --i) {\n      stride[i] = sz\n      sz *= shape[i]\n    }\n  }\n  if(offset === undefined) {\n    offset = 0\n    for(var i=0; i<d; ++i) {\n      if(stride[i] < 0) {\n        offset -= (shape[i]-1)*stride[i]\n      }\n    }\n  }\n  var dtype = arrayDType(data)\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\n  while(ctor_list.length <= d+1) {\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\n  }\n  var ctor = ctor_list[d+1]\n  return ctor(data, shape, stride, offset)\n}\n\nmodule.exports = wrappedNDArrayCtor\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/ndarray/ndarray.js?");

/***/ }),

/***/ "./node_modules/noa-engine/package.json":
/*!**********************************************!*\
  !*** ./node_modules/noa-engine/package.json ***!
  \**********************************************/
/*! exports provided: _args, _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _spec, _where, author, bugs, dependencies, description, devDependencies, files, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = JSON.parse(\"{\\\"_args\\\":[[\\\"noa-engine@0.25.4\\\",\\\"D:\\\\\\\\JX\\\\\\\\Eth\\\\\\\\BabylonJS\\\\\\\\noa-lt-master\\\\\\\\noa-lt-master\\\"]],\\\"_from\\\":\\\"noa-engine@0.25.4\\\",\\\"_id\\\":\\\"noa-engine@0.25.4\\\",\\\"_inBundle\\\":false,\\\"_integrity\\\":\\\"sha512-uzIST5EJ4Kow3GD3DQqzb/OpIYorFGC0cd0rem0isgpMcHzw+o/V2CZnCkKwruHSqa+Ch8f5uEHuwRA1xZxBDA==\\\",\\\"_location\\\":\\\"/noa-engine\\\",\\\"_phantomChildren\\\":{\\\"iota-array\\\":\\\"1.0.0\\\",\\\"is-buffer\\\":\\\"1.1.6\\\"},\\\"_requested\\\":{\\\"type\\\":\\\"version\\\",\\\"registry\\\":true,\\\"raw\\\":\\\"noa-engine@0.25.4\\\",\\\"name\\\":\\\"noa-engine\\\",\\\"escapedName\\\":\\\"noa-engine\\\",\\\"rawSpec\\\":\\\"0.25.4\\\",\\\"saveSpec\\\":null,\\\"fetchSpec\\\":\\\"0.25.4\\\"},\\\"_requiredBy\\\":[\\\"/\\\"],\\\"_resolved\\\":\\\"https://registry.npmjs.org/noa-engine/-/noa-engine-0.25.4.tgz\\\",\\\"_spec\\\":\\\"0.25.4\\\",\\\"_where\\\":\\\"D:\\\\\\\\JX\\\\\\\\Eth\\\\\\\\BabylonJS\\\\\\\\noa-lt-master\\\\\\\\noa-lt-master\\\",\\\"author\\\":{\\\"name\\\":\\\"Andy Hall\\\"},\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/andyhall/noa/issues\\\"},\\\"dependencies\\\":{\\\"aabb-3d\\\":\\\"github:andyhall/aabb-3d\\\",\\\"box-intersect\\\":\\\"^1.0.2\\\",\\\"ent-comp\\\":\\\"^0.7.0\\\",\\\"fast-voxel-raycast\\\":\\\"^0.1.1\\\",\\\"game-inputs\\\":\\\"^0.3.1\\\",\\\"game-shell\\\":\\\"github:andyhall/game-shell\\\",\\\"gl-vec3\\\":\\\"^1.1.3\\\",\\\"ndarray\\\":\\\"^1.0.16\\\",\\\"ndarray-hash\\\":\\\"^1.0.0\\\",\\\"voxel-aabb-sweep\\\":\\\"^0.5.0\\\",\\\"voxel-physics-engine\\\":\\\"^0.10.0\\\"},\\\"description\\\":\\\"Experimental voxel game engine\\\",\\\"devDependencies\\\":{\\\"eslint\\\":\\\"^5.16.0\\\",\\\"js-beautify\\\":\\\"^1.10.0\\\",\\\"webpack\\\":\\\"^4.32.0\\\",\\\"webpack-cli\\\":\\\"^3.3.2\\\",\\\"webpack-dev-server\\\":\\\"^3.4.1\\\"},\\\"files\\\":[\\\"/src\\\"],\\\"homepage\\\":\\\"https://github.com/andyhall/noa#readme\\\",\\\"keywords\\\":[\\\"voxel\\\",\\\"game\\\",\\\"engine\\\"],\\\"license\\\":\\\"MIT\\\",\\\"main\\\":\\\"src/index.js\\\",\\\"name\\\":\\\"noa-engine\\\",\\\"repository\\\":{\\\"type\\\":\\\"git\\\",\\\"url\\\":\\\"git+https://github.com/andyhall/noa.git\\\"},\\\"scripts\\\":{\\\"build\\\":\\\"cd docs/hello-world && webpack && cd ../test && webpack\\\",\\\"start\\\":\\\"cd docs/hello-world && webpack-dev-server\\\",\\\"test\\\":\\\"cd docs/test && webpack-dev-server\\\"},\\\"version\\\":\\\"0.25.4\\\"}\");\n\n//# sourceURL=webpack:///./node_modules/noa-engine/package.json?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/collideEntities.js":
/*!*******************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/collideEntities.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar boxIntersect = __webpack_require__(/*! box-intersect */ \"./node_modules/box-intersect/index.js\")\n\n\n/*\n * \tEvery frame, entities with this component will get mutually checked for colliions\n * \n *   * cylinder: flag for checking collisions as a vertical cylindar (rather than AABB)\n *   * collideBits: category for this entity\n *   * collideMask: categories this entity collides with\n *   * callback: function(other_id) - called when `own.collideBits & other.collideMask` is true\n * \n * \n * \t\tNotes:\n * \tSet collideBits=0 for entities like bullets, which can collide with things \n * \t\tbut are never the target of a collision.\n * \tSet collideMask=0 for things with no callback - things that get collided with,\n * \t\tbut don't themselves instigate collisions.\n * \n */\n\n\n\nmodule.exports = function (noa) {\n\n    return {\n\n        name: 'collideEntities',\n\n        state: {\n            cylinder: false,\n            collideBits: 1 | 0,\n            collideMask: 1 | 0,\n            callback: null,\n        },\n\n        onAdd: null,\n\n        onRemove: null,\n\n\n        system: function entityCollider(dt, states) {\n            var ents = noa.ents\n\n            // data struct that boxIntersect looks for\n            // - array of [lo, lo, lo, hi, hi, hi] extents\n            var intervals = []\n            for (var i = 0; i < states.length; i++) {\n                var id = states[i].__id\n                var dat = ents.getPositionData(id)\n                intervals[i] = dat._extents\n            }\n\n            // run the intersect library\n            boxIntersect(intervals, function (a, b) {\n                var stateA = states[a]\n                var stateB = states[b]\n                var intervalA = intervals[a]\n                var intervalB = intervals[b]\n                if (cylindricalHitTest(stateA, stateB, intervalA, intervalB)) {\n                    handleCollision(noa, stateA, stateB)\n                }\n            })\n\n        }\n    }\n\n\n\n    /*\n     * \n     * \t\tIMPLEMENTATION\n     * \n     */\n\n\n    function handleCollision(noa, stateA, stateB) {\n        var idA = stateA.__id\n        var idB = stateB.__id\n\n        // entities really do overlap, so check masks and call event handlers\n        if (stateA.collideMask & stateB.collideBits) {\n            if (stateA.callback) stateA.callback(idB)\n        }\n        if (stateB.collideMask & stateA.collideBits) {\n            if (stateB.callback) stateB.callback(idA)\n        }\n\n        // general pairwise handler\n        noa.ents.onPairwiseEntityCollision(idA, idB)\n    }\n\n\n\n    // For entities whose extents overlap, \n    // test if collision still happens when taking cylinder flags into account\n\n    function cylindricalHitTest(stateA, stateB, intervalA, intervalB) {\n        if (stateA.cylinder) {\n            if (stateB.cylinder) {\n                return cylinderCylinderTest(intervalA, intervalB)\n            } else {\n                return cylinderBoxTest(intervalA, intervalB)\n            }\n        } else if (stateB.cylinder) {\n            return cylinderBoxTest(intervalB, intervalA)\n        }\n        return true\n    }\n\n\n\n\n    // Cylinder-cylinder hit test (AABBs are known to overlap)\n    // given their extent arrays [lo, lo, lo, hi, hi, hi]\n\n    function cylinderCylinderTest(a, b) {\n        // distance between cylinder centers\n        var rada = (a[3] - a[0]) / 2\n        var radb = (b[3] - b[0]) / 2\n        var dx = a[0] + rada - (b[0] + radb)\n        var dz = a[2] + rada - (b[2] + radb)\n        // collide if dist <= sum of radii\n        var distsq = dx * dx + dz * dz\n        var radsum = rada + radb\n        return (distsq <= radsum * radsum)\n    }\n\n\n\n\n    // Cylinder-Box hit test (AABBs are known to overlap)\n    // given their extent arrays [lo, lo, lo, hi, hi, hi]\n\n    function cylinderBoxTest(cyl, cube) {\n        // X-z center of cylinder\n        var rad = (cyl[3] - cyl[0]) / 2\n        var cx = cyl[0] + rad\n        var cz = cyl[2] + rad\n        // point in X-Z square closest to cylinder\n        var px = clamp(cx, cube[0], cube[3])\n        var pz = clamp(cz, cube[2], cube[5])\n        // collision if distance from that point to circle <= cylinder radius\n        var dx = px - cx\n        var dz = pz - cz\n        var distsq = dx * dx + dz * dz\n        return (distsq <= rad * rad)\n    }\n\n    function clamp(val, lo, hi) {\n        return (val < lo) ? lo : (val > hi) ? hi : val\n    }\n\n\n\n\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/collideEntities.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/collideTerrain.js":
/*!******************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/collideTerrain.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function (noa) {\n    return {\n\n        name: 'collideTerrain',\n\n        state: {\n            callback: null\n        },\n\n        onAdd: function (eid, state) {\n            // add collide handler for physics engine to call\n            var ents = noa.entities\n            if (ents.hasPhysics(eid)) {\n                var body = ents.getPhysicsBody(eid)\n                body.onCollide = function bodyOnCollide(impulse) {\n                    var cb = noa.ents.getCollideTerrain(eid).callback\n                    if (cb) cb(impulse, eid)\n                }\n            }\n        },\n\n        onRemove: function (eid, state) {\n            var ents = noa.entities\n            if (ents.hasPhysics(eid)) {\n                ents.getPhysicsBody(eid).onCollide = null\n            }\n        },\n\n\n        system: null\n\n\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/collideTerrain.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/fadeOnZoom.js":
/*!**************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/fadeOnZoom.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Component for the player entity, when active hides the player's mesh \n * when camera zoom is less than a certain amount\n */\n\nmodule.exports = function (noa) {\n    return {\n\n        name: 'fadeOnZoom',\n\n        state: {\n            cutoff: 1.5,\n            _showing: true\n        },\n\n        onAdd: null,\n\n        onRemove: null,\n\n        system: function fadeOnZoomProc(dt, states) {\n            var zoom = noa.rendering._currentZoom\n            var ents = noa.entities\n            states.forEach(state => {\n                checkZoom(state, state.__id, zoom, ents)\n            })\n        }\n    }\n}\n\n\nfunction checkZoom(state, id, zoom, ents) {\n    if (!ents.hasMesh(id)) return\n\n    if (state._showing && zoom < state.cutoff || !state._showing && zoom > state.cutoff) {\n        var mesh = ents.getMeshData(id).mesh\n        mesh.visibility = state._showing = (zoom > state.cutoff)\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/fadeOnZoom.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/followsEntity.js":
/*!*****************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/followsEntity.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\n\n\n/*\n * Indicates that an entity should be moved to another entity's position each tick,\n * possibly by a fixed offset, and the same for renderPositions each render\n */\n\nmodule.exports = function (noa) {\n\n    return {\n\n        name: 'followsEntity',\n\n        state: {\n            entity: 0 | 0,\n            offset: null,\n        },\n\n        onAdd: function (eid, state) {\n            var off = vec3.create()\n            state.offset = (state.offset) ? vec3.copy(off, state.offset) : off\n            updatePosition(state)\n            updateRenderPosition(state)\n        },\n\n        onRemove: null,\n\n\n        // on tick, copy over regular positions\n        system: function followEntity(dt, states) {\n            states.forEach(state => {\n                updatePosition(state)\n            })\n        },\n\n\n        // on render, copy over render positions\n        renderSystem: function followEntityMesh(dt, states) {\n            states.forEach(state => {\n                updateRenderPosition(state)\n            })\n        }\n    }\n\n\n\n    function updatePosition(state) {\n        var id = state.__id\n        var self = noa.ents.getPositionData(id)\n        var other = noa.ents.getPositionData(state.entity)\n        if (other) {\n            vec3.add(self.position, other.position, state.offset)\n            self._extentsChanged = true\n        } else {\n            noa.ents.removeComponent(id, noa.ents.names.followsEntity)\n        }\n    }\n\n    function updateRenderPosition(state) {\n        var id = state.__id\n        var self = noa.ents.getPositionData(id)\n        var other = noa.ents.getPositionData(state.entity)\n        if (other) {\n            vec3.add(self.renderPosition, other.renderPosition, state.offset)\n        } else {\n            noa.ents.removeComponent(id, noa.ents.names.followsEntity)\n        }\n    }\n\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/followsEntity.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/mesh.js":
/*!********************************************************!*\
  !*** ./node_modules/noa-engine/src/components/mesh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\n\nmodule.exports = function (noa) {\n    return {\n\n        name: 'mesh',\n\n        state: {\n            mesh: null,\n            offset: null\n        },\n\n\n        onAdd: function (eid, state) {\n            if (state.mesh) {\n                noa.rendering.addMeshToScene(state.mesh)\n            } else {\n                throw new Error('Mesh component added without a mesh - probably a bug!')\n            }\n            if (!state.offset) {\n                state.offset = new vec3.create()\n            }\n\n            // initialize mesh to correct position\n            var pos = noa.ents.getPosition(eid)\n            var mpos = state.mesh.position\n            mpos.x = pos[0] + state.offset[0]\n            mpos.y = pos[1] + state.offset[1]\n            mpos.z = pos[2] + state.offset[2]\n        },\n\n\n        onRemove: function (eid, state) {\n            state.mesh.dispose()\n        },\n\n\n        system: null,\n\n\n\n        renderSystem: function (dt, states) {\n            // before render move each mesh to its render position, \n            // set by the physics engine or driving logic\n\n            states.forEach(state => {\n                var id = state.__id\n\n                var rpos = noa.ents.getPositionData(id).renderPosition\n                var x = rpos[0] + state.offset[0]\n                var y = rpos[1] + state.offset[1]\n                var z = rpos[2] + state.offset[2]\n\n                state.mesh.position.copyFromFloats(x, y, z)\n            })\n        }\n\n\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/mesh.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/movement.js":
/*!************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/movement.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\n\n/**\n * \n * Movement component. State stores settings like jump height, etc.,\n * as well as current state (running, jumping, heading angle).\n * Processor checks state and applies movement/friction/jump forces\n * to the entity's physics body. \n * \n */\n\nmodule.exports = function (noa) {\n    return {\n\n        name: 'movement',\n\n        state: {\n            // current state\n            heading: 0, // radians\n            running: false,\n            jumping: false,\n\n            // options:\n            maxSpeed: 10,\n            moveForce: 30,\n            responsiveness: 15,\n            runningFriction: 0,\n            standingFriction: 2,\n\n            airMoveMult: 0.5,\n            jumpImpulse: 10,\n            jumpForce: 12,\n            jumpTime: 500, // ms\n            airJumps: 1,\n\n            // internal state\n            _jumpCount: 0,\n            _isJumping: 0,\n            _currjumptime: 0,\n        },\n\n        onAdd: null,\n\n        onRemove: null,\n\n\n        system: function movementProcessor(dt, states) {\n            var ents = noa.entities\n\n            states.forEach(state => {\n                var body = ents.getPhysicsBody(state.__id)\n                applyMovementPhysics(dt, state, body)\n            })\n\n        }\n\n\n    }\n}\n\n\nvar tempvec = vec3.create()\nvar tempvec2 = vec3.create()\nvar zeroVec = vec3.create()\n\n\nfunction applyMovementPhysics(dt, state, body) {\n    // move implementation originally written as external module\n    //   see https://github.com/andyhall/voxel-fps-controller\n    //   for original code\n\n    // jumping\n    var onGround = (body.atRestY() < 0)\n    var canjump = (onGround || state._jumpCount < state.airJumps)\n    if (onGround) {\n        state._isJumping = false\n        state._jumpCount = 0\n    }\n\n    // process jump input\n    if (state.jumping) {\n        if (state._isJumping) { // continue previous jump\n            if (state._currjumptime > 0) {\n                var jf = state.jumpForce\n                if (state._currjumptime < dt) jf *= state._currjumptime / dt\n                body.applyForce([0, jf, 0])\n                state._currjumptime -= dt\n            }\n        } else if (canjump) { // start new jump\n            state._isJumping = true\n            if (!onGround) state._jumpCount++\n            state._currjumptime = state.jumpTime\n            body.applyImpulse([0, state.jumpImpulse, 0])\n            // clear downward velocity on airjump\n            if (!onGround && body.velocity[1] < 0) body.velocity[1] = 0\n        }\n    } else {\n        state._isJumping = false\n    }\n\n    // apply movement forces if entity is moving, otherwise just friction\n    var m = tempvec\n    var push = tempvec2\n    if (state.running) {\n\n        var speed = state.maxSpeed\n        // todo: add crouch/sprint modifiers if needed\n        // if (state.sprint) speed *= state.sprintMoveMult\n        // if (state.crouch) speed *= state.crouchMoveMult\n        vec3.set(m, 0, 0, speed)\n\n        // rotate move vector to entity's heading\n        vec3.rotateY(m, m, zeroVec, state.heading)\n\n        // push vector to achieve desired speed & dir\n        // following code to adjust 2D velocity to desired amount is patterned on Quake: \n        // https://github.com/id-Software/Quake-III-Arena/blob/master/code/game/bg_pmove.c#L275\n        vec3.subtract(push, m, body.velocity)\n        push[1] = 0\n        var pushLen = vec3.length(push)\n        vec3.normalize(push, push)\n\n        if (pushLen > 0) {\n            // pushing force vector\n            var canPush = state.moveForce\n            if (!onGround) canPush *= state.airMoveMult\n\n            // apply final force\n            var pushAmt = state.responsiveness * pushLen\n            if (canPush > pushAmt) canPush = pushAmt\n\n            vec3.scale(push, push, canPush)\n            body.applyForce(push)\n        }\n\n        // different friction when not moving\n        // idea from Sonic: http://info.sonicretro.org/SPG:Running\n        body.friction = state.runningFriction\n    } else {\n        body.friction = state.standingFriction\n    }\n\n\n\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/movement.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/physics.js":
/*!***********************************************************!*\
  !*** ./node_modules/noa-engine/src/components/physics.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\n\n\nmodule.exports = function (noa) {\n\n\n    return {\n\n        name: 'physics',\n\n\n        state: {\n            body: null,\n        },\n\n\n        onAdd: function (entID, state) {\n            state.body = noa.physics.addBody()\n            // implicitly assume body has a position component, to get size\n            var dat = noa.ents.getPositionData(state.__id)\n            noa.ents.setEntitySize(state.__id, dat.width, dat.height, dat.width)\n        },\n\n\n        onRemove: function (entID, state) {\n            // update position before removing\n            // this lets entity wind up at e.g. the result of a collision\n            // even if physics component is removed in collision handler\n            if (noa.ents.hasPosition(state.__id)) {\n                var pdat = noa.ents.getPositionData(state.__id)\n                updatePositionFromPhysics(state, pdat)\n                backtrackRenderPos(state, pdat, 0, false)\n            }\n            noa.physics.removeBody(state.body)\n        },\n\n\n        system: function (dt, states) {\n            states.forEach(state => {\n                var pdat = noa.ents.getPositionData(state.__id)\n                updatePositionFromPhysics(state, pdat)\n            })\n        },\n\n\n        renderSystem: function (dt, states) {\n\n            var tickPos = noa.positionInCurrentTick\n            var tickMS = tickPos * noa._tickRate\n\n            // tickMS is time since last physics engine tick\n            // to avoid temporal aliasing, render the state as if lerping between\n            // the last position and the next one \n            // since the entity data is the \"next\" position this amounts to \n            // offsetting each entity into the past by tickRate - dt\n            // http://gafferongames.com/game-physics/fix-your-timestep/\n\n            var backtrackAmt = (tickMS - noa._tickRate) / 1000\n            states.forEach(state => {\n                var id = state.__id\n                var pdat = noa.ents.getPositionData(id)\n                var smoothed = noa.ents.cameraSmoothed(id)\n                backtrackRenderPos(state, pdat, backtrackAmt, smoothed)\n            })\n        }\n\n    }\n\n}\n\n\n\nvar offset = vec3.create()\nvar pos = vec3.create()\n\n\n\nfunction updatePositionFromPhysics(state, posDat) {\n    offset[0] = offset[2] = posDat.width / 2\n    offset[1] = 0\n    var pos = posDat.position\n    var base = state.body.aabb.base\n    var max = state.body.aabb.max\n    var ext = posDat._extents\n    for (var j = 0; j < 3; j++) {\n        pos[j] = base[j] + offset[j]\n        ext[j] = base[j]\n        ext[j + 3] = max[j]\n    }\n}\n\n\nfunction backtrackRenderPos(state, posDat, backtrackAmt, smoothed) {\n    // pos = pos + backtrack * body.velocity\n    vec3.scaleAndAdd(pos, posDat.position, state.body.velocity, backtrackAmt)\n\n    // smooth out update if component is present\n    // (this is set after sudden movements like auto-stepping)\n    if (smoothed) vec3.lerp(pos, posDat.renderPosition, pos, 0.3)\n\n    // copy values over to renderPosition, \n    vec3.copy(posDat.renderPosition, pos)\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/physics.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/position.js":
/*!************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/position.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\n\n\n/**\n * \n * \tComponent holding entity's position, width, and height.\n *  By convention, \"position\" is the bottom center of the entity's AABB\n * \n */\n\n\nmodule.exports = function (noa) {\n\n    var hasWarned = false\n\n    return {\n\n        name: 'position',\n\n        state: {\n            position: null,\n            renderPosition: null,\n            width: +0,\n            height: +0,\n            _extents: null,\n            _extentsChanged: true,\n        },\n\n\n        onAdd: function (eid, state) {\n            if (state.position) {\n                if (!(state.position instanceof Float32Array) && !hasWarned) {\n                    console.warn('Better to set entity positions as instances of \"gl-vec3\"!')\n                    hasWarned = true\n                }\n            } else state.position = vec3.create()\n\n            state.renderPosition = vec3.create()\n            vec3.copy(state.renderPosition, state.position)\n\n            state._extents = new Float32Array(6)\n        },\n\n        onRemove: null,\n\n\n\n        system: function (dt, states) {\n            states.forEach(state => {\n                if (!state._extentsChanged) return\n                updateExtents(state._extents, state.position, state.height, state.width)\n                state._extentsChanged = false\n            })\n        },\n\n\n    }\n}\n\n\nfunction updateExtents(ext, pos, height, width) {\n    var hw = width / 2\n    ext[0] = pos[0] - hw\n    ext[1] = pos[1]\n    ext[2] = pos[2] - hw\n    ext[3] = pos[0] + hw\n    ext[4] = pos[1] + height\n    ext[5] = pos[2] + hw\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/position.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/receivesInputs.js":
/*!******************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/receivesInputs.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * \n * Input processing component - gets (key) input state and  \n * applies it to receiving entities by updating their movement \n * component state (heading, movespeed, jumping, etc.)\n * \n */\n\nmodule.exports = function (noa) {\n    return {\n\n        name: 'receivesInputs',\n\n        state: {},\n\n        onAdd: null,\n\n        onRemove: null,\n\n        system: function inputProcessor(dt, states) {\n            var ents = noa.entities\n            var inputState = noa.inputs.state\n            var camHeading = noa.rendering.getCameraRotation()[1]\n\n            states.forEach(state => {\n                var moveState = ents.getMovement(state.__id)\n                setMovementState(moveState, inputState, camHeading)\n            })\n        }\n\n    }\n}\n\n\n\nfunction setMovementState(state, inputs, camHeading) {\n    state.jumping = !!inputs.jump\n\n    var fb = inputs.forward ? (inputs.backward ? 0 : 1) : (inputs.backward ? -1 : 0)\n    var rl = inputs.right ? (inputs.left ? 0 : 1) : (inputs.left ? -1 : 0)\n\n    if ((fb | rl) === 0) {\n        state.running = false\n    } else {\n        state.running = true\n        if (fb) {\n            if (fb == -1) camHeading += Math.PI\n            if (rl) {\n                camHeading += Math.PI / 4 * fb * rl // didn't plan this but it works!\n            }\n        } else {\n            camHeading += rl * Math.PI / 2\n        }\n        state.heading = camHeading\n    }\n\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/receivesInputs.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/shadow.js":
/*!**********************************************************!*\
  !*** ./node_modules/noa-engine/src/components/shadow.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\nvar shadowDist\n\nmodule.exports = function (noa, dist) {\n\n    shadowDist = dist\n\n    // create a mesh to re-use for shadows\n    var scene = noa.rendering.getScene()\n    var disc = BABYLON.Mesh.CreateDisc('shadow', 0.75, 30, scene)\n    disc.rotation.x = Math.PI / 2\n    disc.material = noa.rendering.makeStandardMaterial('shadowMat')\n    disc.material.diffuseColor = BABYLON.Color3.Black()\n    disc.material.ambientColor = BABYLON.Color3.Black()\n    disc.material.alpha = 0.5\n    disc.setEnabled(false)\n\n    // source mesh needn't be in the scene graph\n    scene.removeMesh(disc)\n\n\n    return {\n\n        name: 'shadow',\n\n        state: {\n            size: 0.5,\n            _mesh: null,\n        },\n\n\n        onAdd: function (eid, state) {\n            state._mesh = noa.rendering.makeMeshInstance(disc, false)\n        },\n\n\n        onRemove: function (eid, state) {\n            state._mesh.dispose()\n        },\n\n\n        system: function shadowSystem(dt, states) {\n            var cpos = noa.rendering.getCameraPosition()\n            vec3.set(camPos, cpos.x, cpos.y, cpos.z)\n            var dist = shadowDist\n            states.forEach(state => {\n                updateShadowHeight(state.__id, state._mesh, state.size, dist, noa)\n            })\n        },\n\n\n        renderSystem: function (dt, states) {\n            // before render adjust shadow x/z to render positions\n            states.forEach(state => {\n                var rpos = noa.ents.getPositionData(state.__id).renderPosition\n                var spos = state._mesh.position\n                spos.x = rpos[0]\n                spos.z = rpos[2]\n            })\n        }\n\n\n\n\n    }\n}\n\nvar down = vec3.fromValues(0, -1, 0)\nvar camPos = vec3.fromValues(0, 0, 0)\nvar shadowPos = vec3.fromValues(0, 0, 0)\n\nfunction updateShadowHeight(id, mesh, size, shadowDist, noa) {\n    var ents = noa.entities\n    var dat = ents.getPositionData(id)\n    var loc = dat.position\n    var y\n\n    // find Y location, from physics if on ground, otherwise by raycast\n    if (ents.hasPhysics(id) && ents.getPhysicsBody(id).resting[1] < 0) {\n        y = dat.renderPosition[1]\n    } else {\n        var pick = noa.pick(loc, down, shadowDist)\n        if (pick) {\n            y = pick.position[1]\n        } else {\n            mesh.setEnabled(false)\n            return\n        }\n    }\n\n    y = Math.round(y) // pick results get slightly countersunk\n    // set shadow slightly above ground to avoid z-fighting\n    vec3.set(shadowPos, mesh.position.x, y, mesh.position.z)\n    var sqdist = vec3.squaredDistance(camPos, shadowPos)\n    // offset ~ 0.01 for nearby shadows, up to 0.1 at distance of ~40\n    var offset = 0.01 + 0.1 * (sqdist / 1600)\n    if (offset > 0.1) offset = 0.1\n    mesh.position.y = y + offset\n    // set shadow scale\n    var dist = loc[1] - y\n    var scale = size * 0.7 * (1 - dist / shadowDist)\n    mesh.scaling.copyFromFloats(scale, scale, scale)\n    mesh.setEnabled(true)\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/shadow.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/components/smoothCamera.js":
/*!****************************************************************!*\
  !*** ./node_modules/noa-engine/src/components/smoothCamera.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function (noa) {\n    return {\n\n        name: 'smooth-camera',\n\n        state: {\n            time: 100.1\n        },\n\n        onAdd: null,\n\n        onRemove: null,\n\n        system: function (dt, states) {\n            // remove self after time elapses\n            states.forEach(state => {\n                state.time -= dt\n                if (state.time < 0) noa.ents.removeComponent(state.__id, 'smooth-camera')\n            })\n        },\n\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/components/smoothCamera.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/index.js":
/*!**********************************************!*\
  !*** ./node_modules/noa-engine/src/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*!\n * noa: an experimental voxel game engine.\n * @url      github.com/andyhall/noa\n * @author   Andy Hall <andy@fenomas.com>\n * @license  MIT\n */\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\nvar ndarray = __webpack_require__(/*! ndarray */ \"./node_modules/noa-engine/node_modules/ndarray/ndarray.js\")\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter\nvar createContainer = __webpack_require__(/*! ./lib/container */ \"./node_modules/noa-engine/src/lib/container.js\")\nvar createRendering = __webpack_require__(/*! ./lib/rendering */ \"./node_modules/noa-engine/src/lib/rendering.js\")\nvar createWorld = __webpack_require__(/*! ./lib/world */ \"./node_modules/noa-engine/src/lib/world.js\")\nvar createInputs = __webpack_require__(/*! ./lib/inputs */ \"./node_modules/noa-engine/src/lib/inputs.js\")\nvar createPhysics = __webpack_require__(/*! ./lib/physics */ \"./node_modules/noa-engine/src/lib/physics.js\")\nvar createCamControls = __webpack_require__(/*! ./lib/camera */ \"./node_modules/noa-engine/src/lib/camera.js\")\nvar createRegistry = __webpack_require__(/*! ./lib/registry */ \"./node_modules/noa-engine/src/lib/registry.js\")\nvar createEntities = __webpack_require__(/*! ./lib/entities */ \"./node_modules/noa-engine/src/lib/entities.js\")\nvar raycast = __webpack_require__(/*! fast-voxel-raycast */ \"./node_modules/fast-voxel-raycast/index.js\")\n\n\nmodule.exports = Engine\n\n\n\n// profiling flag\nvar PROFILE = 0\nvar PROFILE_RENDER = 0\nvar DEBUG_QUEUES = 0\n\n\n\n\nvar defaults = {\n    debug: false,\n    silent: false,\n    playerHeight: 1.8,\n    playerWidth: 0.6,\n    playerStart: [0, 10, 0],\n    playerAutoStep: false,\n    tickRate: 33, // ms per tick - not ticks per second\n    blockTestDistance: 10,\n    stickyPointerLock: true,\n    dragCameraOutsidePointerLock: true,\n    skipDefaultHighlighting: false,\n}\n\n/**\n * Main engine object.  \n * Emits: *tick, beforeRender, afterRender, targetBlockChanged*\n * \n * ```js\n * var noaEngine = require('noa-engine')\n * var noa = noaEngine(opts)\n * ```\n * \n * @class noa\n */\n\nfunction Engine(opts) {\n    if (!(this instanceof Engine)) return new Engine(opts)\n\n    this.version = __webpack_require__(/*! ../package.json */ \"./node_modules/noa-engine/package.json\").version\n    if (!opts.silent) {\n        var debugstr = (opts.debug) ? ' (debug)' : ''\n        console.log(`noa-engine v${this.version}${debugstr}`)\n    }\n\n    opts = Object.assign({}, defaults, opts)\n    this._tickRate = opts.tickRate\n    this._paused = false\n    this._dragOutsideLock = opts.dragCameraOutsidePointerLock\n    var self = this\n\n    // container (html/div) manager\n    this.container = createContainer(this, opts)\n\n    // inputs manager - abstracts key/mouse input\n    this.inputs = createInputs(this, opts, this.container.element)\n\n    // create block/item property registry\n    this.registry = createRegistry(this, opts)\n\n    // create world manager\n    this.world = createWorld(this, opts)\n\n    // rendering manager - abstracts all draws to 3D context\n    this.rendering = createRendering(this, opts, this.container.canvas)\n\n    // Entity manager / Entity Component System (ECS)\n    this.entities = createEntities(this, opts)\n    // convenience\n    this.ents = this.entities\n\n    // how far engine is into the current tick. Updated each render.\n    this.positionInCurrentTick = 0\n\n    // physics engine - solves collisions, properties, etc.\n    this.physics = createPhysics(this, opts)\n\n    // camera controller\n    this.cameraControls = createCamControls(this, opts)\n\n\n    var ents = this.ents\n\n    /** Entity id for the player entity */\n    this.playerEntity = ents.add(\n        opts.playerStart, // starting location\n        opts.playerWidth, opts.playerHeight,\n        null, null, // no mesh for now, no meshOffset, \n        true, true\n    )\n\n    // make player entity it collide with terrain and other entities\n    ents.addComponent(this.playerEntity, ents.names.collideTerrain)\n    ents.addComponent(this.playerEntity, ents.names.collideEntities)\n\n    // adjust default physics parameters\n    var body = ents.getPhysicsBody(this.playerEntity)\n    body.gravityMultiplier = 2 // less floaty\n    body.autoStep = opts.playerAutoStep // auto step onto blocks\n\n    /** reference to player entity's physics body */\n    this.playerBody = body\n\n    // input component - sets entity's movement state from key inputs\n    ents.addComponent(this.playerEntity, ents.names.receivesInputs)\n\n    // add a component to make player mesh fade out when zooming in\n    ents.addComponent(this.playerEntity, ents.names.fadeOnZoom)\n\n    // movement component - applies movement forces\n    // todo: populate movement settings from options\n    var moveOpts = {\n        airJumps: 1\n    }\n    ents.addComponent(this.playerEntity, ents.names.movement, moveOpts)\n\n    // how high above the player's position the eye is (for picking, camera tracking)  \n    this.playerEyeOffset = 0.9 * opts.playerHeight\n\n\n\n\n    // set up block targeting\n    this.blockTestDistance = opts.blockTestDistance\n\n    /** function for which block IDs are targetable. \n     * Defaults to a solidity check, but can be overridden */\n    this.blockTargetIdCheck = this.registry.getBlockSolidity\n\n    /** Dynamically updated object describing the currently targeted block */\n    this.targetedBlock = null\n\n    // add a default block highlighting function\n    if (!opts.skipDefaultHighlighting) {\n        // the default listener, defined onto noa in case people want to remove it later\n        this.defaultBlockHighlightFunction = function (tgt) {\n            if (tgt) {\n                self.rendering.highlightBlockFace(true, tgt.position, tgt.normal)\n            } else {\n                self.rendering.highlightBlockFace(false)\n            }\n        }\n        this.on('targetBlockChanged', this.defaultBlockHighlightFunction)\n    }\n\n    // init rendering stuff that needed to wait for engine internals\n    this.rendering.initScene()\n\n    // expose constants, for HACKING™\n    this._constants = __webpack_require__(/*! ./lib/constants */ \"./node_modules/noa-engine/src/lib/constants.js\")\n\n    // temp hacks for development\n    if (opts.debug) {\n        window.noa = this\n        window.scene = this.rendering._scene\n        window.ndarray = ndarray\n        window.vec3 = vec3\n        var debug = false\n        this.inputs.bind('debug', 'Z')\n        this.inputs.down.on('debug', function onDebug() {\n            debug = !debug\n            if (debug) window.scene.debugLayer.show()\n            else window.scene.debugLayer.hide()\n        })\n    }\n\n\n\n}\n\nEngine.prototype = Object.create(EventEmitter.prototype)\n\n\n/*\n *   Core Engine API\n */\n\n\n\n\n/*\n * Tick function, called by container module at a fixed timestep. Emits #tick(dt),\n * where dt is the tick rate in ms (default 16.6)\n */\n\nEngine.prototype.tick = function () {\n    if (this._paused) return\n    profile_hook('start')\n    var dt = this._tickRate // fixed timesteps!\n    this.world.tick(dt) // chunk creation/removal\n    profile_hook('world')\n    if (!this.world.playerChunkLoaded) {\n        // when waiting on worldgen, just tick the meshing queue and exit\n        this.rendering.tick(dt)\n        return\n    }\n    this.physics.tick(dt) // iterates physics\n    profile_hook('physics')\n    this.rendering.tick(dt) // zooms camera, does deferred chunk meshing\n    profile_hook('rendering')\n    updateBlockTargets(this) // finds targeted blocks, and highlights one if needed\n    profile_hook('targets')\n    this.emit('tick', dt)\n    profile_hook('tick event')\n    profile_hook('end')\n    this.inputs.tick() // clears accumulated tick/mouseMove data\n    if (DEBUG_QUEUES) debugQueues(this)\n}\n\n\nvar __qwasDone = true,\n    __qstart\n\nfunction debugQueues(self) {\n    var a = self.world._chunkIDsToAdd.length\n    var b = self.world._chunkIDsToCreate.length\n    var c = self.rendering._chunksToMesh.length\n    var d = self.rendering._numMeshedChunks\n    if (a + b + c > 0) console.log([\n        'Chunks:', 'unmade', a,\n        'pending creation', b,\n        'to mesh', c,\n        'meshed', d,\n    ].join('   \\t'))\n    if (__qwasDone && a + b + c > 0) {\n        __qwasDone = false\n        __qstart = performance.now()\n    }\n    if (!__qwasDone && a + b + c === 0) {\n        __qwasDone = true\n        console.log('Queue empty after ' + Math.round(performance.now() - __qstart) + 'ms')\n    }\n}\n\n\n\n\n\n\n/*\n * Render function, called every animation frame. Emits #beforeRender(dt), #afterRender(dt) \n * where dt is the time in ms *since the last tick*.\n */\n\nEngine.prototype.render = function (framePart) {\n    if (this._paused) return\n    // update frame position property and calc dt\n    var framesAdvanced = framePart - this.positionInCurrentTick\n    if (framesAdvanced<0) framesAdvanced += 1\n    this.positionInCurrentTick = framePart\n    var dt = framesAdvanced * this._tickRate // ms since last tick\n    // core render:\n    profile_hook_render('start')\n    // only move camera during pointerlock or mousedown, or if pointerlock is unsupported\n    if (this.container.hasPointerLock ||\n        !this.container.supportsPointerLock ||\n        (this._dragOutsideLock && this.inputs.state.fire)) {\n        this.cameraControls.updateForRender()\n    }\n    // clear cumulative mouse inputs\n    this.inputs.state.dx = this.inputs.state.dy = 0\n    // events and render\n    this.emit('beforeRender', dt)\n    profile_hook_render('before render')\n    this.rendering.render(dt)\n    profile_hook_render('render')\n    this.emit('afterRender', dt)\n    profile_hook_render('after render')\n    profile_hook_render('end')\n}\n\n\n\n/*\n *   Utility APIs\n */\n\n/** \n * Pausing the engine will also stop render/tick events, etc.\n * @param paused\n */\nEngine.prototype.setPaused = function (paused) {\n    this._paused = !!paused\n    // when unpausing, clear any built-up mouse inputs\n    if (!paused) {\n        this.inputs.state.dx = this.inputs.state.dy = 0\n    }\n}\n\n/** @param x,y,z */\nEngine.prototype.getBlock = function (x, y, z) {\n    if (x.length) {\n        return this.world.getBlockID(x[0], x[1], x[2])\n    } else {\n        return this.world.getBlockID(x, y, z)\n    }\n}\n\n/** @param x,y,z */\nEngine.prototype.setBlock = function (id, x, y, z) {\n    // skips the entity collision check\n    if (x.length) {\n        return this.world.setBlockID(id, x[0], x[1], x[2])\n    } else {\n        return this.world.setBlockID(id, x, y, z)\n    }\n}\n\n/**\n * Adds a block unless obstructed by entities \n * @param id,x,y,z */\nEngine.prototype.addBlock = function (id, x, y, z) {\n    // add a new terrain block, if nothing blocks the terrain there\n    if (x.length) {\n        if (this.entities.isTerrainBlocked(x[0], x[1], x[2])) return\n        this.world.setBlockID(id, x[0], x[1], x[2])\n        return id\n    } else {\n        if (this.entities.isTerrainBlocked(x, y, z)) return\n        this.world.setBlockID(id, x, y, z)\n        return id\n    }\n}\n\n\n\n/** */\nEngine.prototype.getPlayerPosition = function () {\n    return this.entities.getPosition(this.playerEntity)\n}\n\n/** */\nEngine.prototype.getPlayerMesh = function () {\n    return this.entities.getMeshData(this.playerEntity).mesh\n}\n\n/** */\nEngine.prototype.setPlayerEyeOffset = function (y) {\n    this.playerEyeOffset = y\n    var state = this.ents.getState(this.rendering.cameraTarget, this.ents.names.followsEntity)\n    state.offset[1] = y\n}\n\n/** */\nEngine.prototype.getPlayerEyePosition = function () {\n    var pos = this.entities.getPosition(this.playerEntity)\n    vec3.copy(_eyeLoc, pos)\n    _eyeLoc[1] += this.playerEyeOffset\n    return _eyeLoc\n}\nvar _eyeLoc = vec3.create()\n\n/** */\nEngine.prototype.getCameraVector = function () {\n    // rendering works with babylon's xyz vectors\n    var v = this.rendering.getCameraVector()\n    vec3.set(_camVec, v.x, v.y, v.z)\n    return _camVec\n}\nvar _camVec = vec3.create()\n\n\n\n/**\n * Raycast through the world, returning a result object for any non-air block\n * @param pos\n * @param vec\n * @param dist\n */\nEngine.prototype.pick = function (pos, vec, dist, blockIdTestFunction) {\n    if (dist === 0) return null\n    // if no block ID function is specified default to solidity check\n    var testFn = blockIdTestFunction || this.registry.getBlockSolidity\n    var world = this.world\n    var testVoxel = function (x, y, z) {\n        var id = world.getBlockID(x, y, z)\n        return testFn(id)\n    }\n    pos = pos || this.getPlayerEyePosition()\n    vec = vec || this.getCameraVector()\n    dist = dist || this.blockTestDistance\n    var rpos = _hitResult.position\n    var rnorm = _hitResult.normal\n    var hit = raycast(testVoxel, pos, vec, dist, rpos, rnorm)\n    if (!hit) return null\n    // position is right on a voxel border - adjust it so flooring will work as expected\n    for (var i = 0; i < 3; i++) rpos[i] -= 0.01 * rnorm[i]\n    return _hitResult\n}\nvar _hitResult = {\n    position: vec3.create(),\n    normal: vec3.create(),\n}\n\n\n\n\n\n\n\n// Each frame, by default pick along the player's view vector \n// and tell rendering to highlight the struck block face\nfunction updateBlockTargets(noa) {\n    var newhash = ''\n    var blockIdFn = noa.blockTargetIdCheck || noa.registry.getBlockSolidity\n    var result = noa.pick(null, null, null, blockIdFn)\n    if (result) {\n        var dat = _targetedBlockDat\n        for (var i = 0; i < 3; i++) {\n            // position values are right on a border, so adjust them before flooring!\n            var n = result.normal[i] | 0\n            var p = Math.floor(result.position[i])\n            dat.position[i] = p\n            dat.normal[i] = n\n            dat.adjacent[i] = p + n\n            newhash += '|' + p + '|' + n\n        }\n        dat.blockID = noa.world.getBlockID(dat.position[0], dat.position[1], dat.position[2])\n        newhash += '|' + result.blockID\n        noa.targetedBlock = dat\n    } else {\n        noa.targetedBlock = null\n    }\n    if (newhash != _prevTargetHash) {\n        noa.emit('targetBlockChanged', noa.targetedBlock)\n        _prevTargetHash = newhash\n    }\n}\n\nvar _targetedBlockDat = {\n    blockID: 0,\n    position: [],\n    normal: [],\n    adjacent: [],\n}\n\nvar _prevTargetHash = ''\n\n\n\n\n\n\n\n\n\nvar profile_hook = function (s) {}\nvar profile_hook_render = function (s) {}\nif (PROFILE)(function () {\n    var timer = new(__webpack_require__(/*! ./lib/util */ \"./node_modules/noa-engine/src/lib/util.js\").Timer)(200, 'tick   ')\n    profile_hook = function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\nif (PROFILE_RENDER)(function () {\n    var timer = new(__webpack_require__(/*! ./lib/util */ \"./node_modules/noa-engine/src/lib/util.js\").Timer)(200, 'render ')\n    profile_hook_render = function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/index.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/camera.js":
/*!***************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/camera.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (noa, opts) {\n    return new CameraController(noa, opts)\n}\n\n\n\n/*\n *    Controller for the camera\n *\n */\n\n\nvar defaults = {\n    rotationScaleX: 0.0025,\n    rotationScaleY: 0.0025,\n    inverseY: false,\n}\n\n\nfunction CameraController(noa, opts) {\n    this.noa = noa\n\n    // options\n    opts = Object.assign({}, defaults, opts)\n    this.rotationScaleX = opts.rotationScaleX\n    this.rotationScaleY = opts.rotationScaleY\n    this.inverseY = opts.inverseY\n}\n\n\n\n\n\n/**\n * On render, move/rotate the camera based on target and mouse inputs\n */\n\nCameraController.prototype.updateForRender = function () {\n    // input state\n    var state = this.noa.inputs.state\n\n    // TODO: REMOVE EVENTUALLY\n    bugFix(state)\n\n    // Rotation: translate dx/dy inputs into y/x axis camera angle changes\n    var dx = this.rotationScaleY * state.dy * ((this.inverseY) ? -1 : 1)\n    var dy = this.rotationScaleX * state.dx\n\n    // normalize/clamp/update\n    var camrot = this.noa.rendering.getCameraRotation() // [x,y]\n    var rotX = clamp(camrot[0] + dx, rotXcutoff)\n    var rotY = (camrot[1] + dy) % (Math.PI * 2)\n    this.noa.rendering.setCameraRotation(rotX, rotY)\n\n}\n\nvar rotXcutoff = (Math.PI / 2) - .0001 // engines can be weird when xRot == pi/2\n\nfunction clamp(value, to) {\n    return isFinite(to) ? Math.max(Math.min(value, to), -to) : value\n}\n\n\n\n// workaround for this Chrome 63 + Win10 bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=781182\nfunction bugFix(state) {\n    var dx = state.dx\n    var dy = state.dy\n    var wval = document.body.clientWidth / 6\n    var hval = document.body.clientHeight / 6\n    var badx = (Math.abs(dx) > wval && (dx / lastx) < -1)\n    var bady = (Math.abs(dy) > hval && (dy / lasty) < -1)\n    if (badx || bady) {\n        state.dx = lastx\n        state.dy = lasty\n        lastx = (dx > 0) ? 1 : -1\n        lasty = (dy > 0) ? 1 : -1\n    } else {\n        if (dx) lastx = dx\n        if (dy) lasty = dy\n    }\n}\n\nvar lastx = 0\nvar lasty = 0\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/camera.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/chunk.js":
/*!**************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/chunk.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = __webpack_require__(/*! ./constants */ \"./node_modules/noa-engine/src/lib/constants.js\")\nvar ndarray = __webpack_require__(/*! ndarray */ \"./node_modules/noa-engine/node_modules/ndarray/ndarray.js\")\n\n\n\nmodule.exports = Chunk\n\n\n// shared references to terrain/object meshers\nvar terrainMesher = __webpack_require__(/*! ./terrainMesher */ \"./node_modules/noa-engine/src/lib/terrainMesher.js\")\nvar objectMesher = __webpack_require__(/*! ./objectMesher */ \"./node_modules/noa-engine/src/lib/objectMesher.js\")\n\n\n\n\n/* \n * \n *   Chunk\n * \n *  Stores and manages voxel ids and flags for each voxel within chunk\n *  See constants.js for internal data representation\n * \n */\n\n\n\n// data representation\nvar ID_MASK = constants.ID_MASK\n// var VAR_MASK = constants.VAR_MASK // NYI\nvar SOLID_BIT = constants.SOLID_BIT\nvar OPAQUE_BIT = constants.OPAQUE_BIT\nvar OBJECT_BIT = constants.OBJECT_BIT\n\n\n\n\n/*\n *\n *    Chunk constructor\n *\n */\n\nfunction Chunk(noa, id, i, j, k, size) {\n    this.id = id\n\n    this.noa = noa\n    this.isDisposed = false\n    this.isGenerated = false\n    this.inInvalid = false\n    this.octreeBlock = null\n    this._terrainMesh = null\n\n    this.isEmpty = false\n    this.isFull = false\n\n    // packed data storage\n    var s = size + 2 // 1 block of padding on each side\n    var arr = new Uint16Array(s * s * s)\n    this.array = new ndarray(arr, [s, s, s])\n    this.i = i\n    this.j = j\n    this.k = k\n    this.size = size\n    this.x = i * size\n    this.y = j * size\n    this.z = k * size\n\n    // flags to track if things need re-meshing\n    this._terrainDirty = false\n    this._objectsDirty = false\n\n    // init references shared among all chunks\n    setBlockLookups(noa)\n\n    // build unpadded and transposed array views for internal use\n    rebuildArrayViews(this)\n\n    // adds some properties to the chunk for handling object meshes\n    objectMesher.initChunk(this)\n\n}\n\n\n\n// Registry lookup references shared by all chunks\nvar solidLookup\nvar opaqueLookup\nvar objectMeshLookup\nvar blockHandlerLookup\n\nfunction setBlockLookups(noa) {\n    solidLookup = noa.registry._solidityLookup\n    opaqueLookup = noa.registry._opacityLookup\n    objectMeshLookup = noa.registry._blockMeshLookup\n    blockHandlerLookup = noa.registry._blockHandlerLookup\n}\n\n\n\n\n/*\n *\n *    Chunk API\n *\n */\n\n// get/set deal with block IDs, so that this class acts like an ndarray\n\nChunk.prototype.get = function (x, y, z) {\n    return ID_MASK & this._unpaddedView.get(x, y, z)\n}\n\nChunk.prototype.getSolidityAt = function (x, y, z) {\n    return (SOLID_BIT & this._unpaddedView.get(x, y, z)) ? true : false\n}\n\nChunk.prototype.set = function (x, y, z, id) {\n    var oldID = this._unpaddedView.get(x, y, z)\n    var oldIDnum = oldID & ID_MASK\n    if (id === oldIDnum) return\n\n    // manage data\n    var newID = packID(id)\n    this._unpaddedView.set(x, y, z, newID)\n\n    // handle object meshes\n    if (oldID & OBJECT_BIT) removeObjectBlock(this, x, y, z)\n    if (newID & OBJECT_BIT) addObjectBlock(this, id, x, y, z)\n\n    // track full/emptyness\n    if (newID !== 0) this.isEmpty = false\n    if (!(newID & OPAQUE_BIT)) this.isFull = false\n\n    // call block handlers\n    callBlockHandler(this, oldIDnum, 'onUnset', x, y, z)\n    callBlockHandler(this, id, 'onSet', x, y, z)\n\n    // mark terrain dirty unless neither block was terrain\n    if (isTerrain(oldID) || isTerrain(newID)) this._terrainDirty = true\n}\n\n\n\n\n\n\n// helper to call handler of a given type at a particular xyz\n\nfunction callBlockHandler(chunk, blockID, type, x, y, z) {\n    var hobj = blockHandlerLookup[blockID]\n    if (!hobj) return\n    var handler = hobj[type]\n    if (!handler) return\n    // ignore all handlers if block is in chunk's edge padding blocks\n    var s = chunk.size\n    if (x < 0 || y < 0 || z < 0 || x >= s || y >= s || z >= s) return\n    handler(chunk.x + x, chunk.y + y, chunk.z + z)\n}\n\n\n\n// Convert chunk's voxel terrain into a babylon.js mesh\n// Used internally, but needs to be public so mesh-building hacks can call it\nChunk.prototype.mesh = function (matGetter, colGetter, useAO, aoVals, revAoVal) {\n    return terrainMesher.meshChunk(this, matGetter, colGetter, useAO, aoVals, revAoVal)\n}\n\n\n\n\n\n// gets called by World when this chunk has been queued for remeshing\nChunk.prototype.updateMeshes = function () {\n    if (this._terrainDirty) {\n        this.noa.rendering.removeTerrainMesh(this)\n        var mesh = this.mesh()\n        if (mesh) this.noa.rendering.addTerrainMesh(this, mesh)\n        this._terrainDirty = false\n    }\n    if (this._objectsDirty) {\n        objectMesher.buildObjectMesh(this)\n        this._objectsDirty = false\n    }\n}\n\n\n\n\n\n\n\n// helper to determine if a block counts as \"terrain\" (non-air, non-object)\nfunction isTerrain(id) {\n    if (id === 0) return false\n    // treat object blocks as terrain if solid (they affect AO)\n    if (id & OBJECT_BIT) return !!(id & SOLID_BIT)\n    return true\n}\n\n// helper to pack a block ID into the internally stored form, given lookup tables\nfunction packID(id) {\n    var newID = id\n    if (solidLookup[id]) newID |= SOLID_BIT\n    if (opaqueLookup[id]) newID |= OPAQUE_BIT\n    if (objectMeshLookup[id]) newID |= OBJECT_BIT\n    return newID\n}\n\n\n\n\n\n\n\n\n/*\n * \n *      Init\n * \n *  Gets called right after client filled the voxel ID data array\n */\n\n\n\nChunk.prototype.initData = function () {\n    // remake other views, assuming that data has changed\n    rebuildArrayViews(this)\n    // flags for tracking if chunk is entirely opaque or transparent\n    var fullyOpaque = OPAQUE_BIT\n    var fullyAir = true\n\n    // init everything in one big scan\n    var arr = this.array\n    var data = arr.data\n    var len = arr.shape[0]\n    var kstride = arr.stride[2]\n    for (var i = 0; i < len; ++i) {\n        var edge1 = (i === 0 || i === len - 1)\n        for (var j = 0; j < len; ++j) {\n            var d0 = arr.index(i, j, 0)\n            var edge2 = edge1 || (j === 0 || j === len - 1)\n            for (var k = 0; k < len; ++k, d0 += kstride) {\n                // pull raw ID - could in principle be packed, so mask it\n                var id = data[d0] & ID_MASK\n                // skip air blocks\n                if (id === 0) {\n                    fullyOpaque = 0\n                    continue\n                }\n                // store ID as packed internal representation\n                var packed = packID(id) | 0\n                data[d0] = packed\n                // track whether chunk is entirely full or empty\n                fullyOpaque &= packed\n                fullyAir = false\n                // within unpadded view, handle object blocks and handlers\n                var atEdge = edge2 || (k === 0 || k === len - 1)\n                if (!atEdge) {\n                    if (OBJECT_BIT & packed) {\n                        addObjectBlock(this, id, i - 1, j - 1, k - 1)\n                    }\n                    callBlockHandler(this, id, 'onLoad', i - 1, j - 1, k - 1)\n                }\n            }\n        }\n    }\n\n    this.isFull = !!(fullyOpaque & OPAQUE_BIT)\n    this.isEmpty = !!(fullyAir)\n    this._terrainDirty = !(this.isFull || this.isEmpty)\n\n    this.isGenerated = true\n}\n\n\n// helper to rebuild several transformed views on the data array\n\nfunction rebuildArrayViews(chunk) {\n    var arr = chunk.array\n    var size = chunk.size\n    chunk._unpaddedView = arr.lo(1, 1, 1).hi(size, size, size)\n}\n\n\n\n// accessors related to meshing\n\nfunction addObjectBlock(chunk, id, x, y, z) {\n    objectMesher.addObjectBlock(chunk, id, x, y, z)\n    chunk._objectsDirty = true\n}\n\nfunction removeObjectBlock(chunk, x, y, z) {\n    objectMesher.removeObjectBlock(chunk, x, y, z)\n    chunk._objectsDirty = true\n}\n\n\n\n\n\n// dispose function - just clears properties and references\n\nChunk.prototype.dispose = function () {\n    // look through the data for onUnload handlers\n    callAllBlockHandlers(this, 'onUnload')\n\n    // let meshers dispose their stuff\n    objectMesher.disposeChunk(this)\n\n    // apparently there's no way to dispose typed arrays, so just null everything\n    this.array.data = null\n    this.array = null\n    this._unpaddedView = null\n\n    this.isGenerated = false\n    this.isDisposed = true\n}\n\n\n// helper to call a given handler for all blocks in the chunk\n\nfunction callAllBlockHandlers(chunk, type) {\n    var view = chunk._unpaddedView\n    var data = view.data\n    var si = view.stride[0]\n    var sj = view.stride[1]\n    var sk = view.stride[2]\n    var size = view.shape[0]\n    var d0 = view.offset\n    for (var i = 0; i < size; ++i) {\n        for (var j = 0; j < size; ++j) {\n            for (var k = 0; k < size; ++k) {\n                var id = ID_MASK & data[d0]\n                callBlockHandler(chunk, id, type, i, j, k)\n                d0 += sk\n            }\n            d0 -= sk * size\n            d0 += sj\n        }\n        d0 -= sj * size\n        d0 += si\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/chunk.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/constants.js":
/*!******************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/constants.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar constants = {}\nmodule.exports = constants\n\n\n/* \n *  Internal voxel data representation\n *\n *  Each voxel is stored as a Uint16.\n *  Voxel id is stored in lowest bits, and flags stored in upper bits for fast retrieval\n *  \n *  Stores, from right to left:\n *     9 bits of voxel ID\n *     4 bits of variation (e.g. orientation)  --- Not yet being used!\n *     1 bit solidity (i.e. physics-wise)\n *     1 bit opacity (whether voxel obscures neighboring faces)\n *     1 bit object marker (marks non-terrain blocks with custom meshes)\n */\n\n\nvar ID_BITS = 9\nvar ID_MASK = (1 << ID_BITS) - 1\n\nvar VAR_BITS = 4\nvar VAR_OFFSET = ID_BITS\nvar VAR_MASK = ((1 << VAR_BITS) - 1) << VAR_OFFSET\n\nvar n = ID_BITS + VAR_BITS\nvar SOLID_BIT = 1 << n++\nvar OPAQUE_BIT = 1 << n++\nvar OBJECT_BIT = 1 << n++\n\n// exports\n\nconstants.ID_MASK = ID_MASK\nconstants.VAR_MASK = VAR_MASK\nconstants.SOLID_BIT = SOLID_BIT\nconstants.OPAQUE_BIT = OPAQUE_BIT\nconstants.OBJECT_BIT = OBJECT_BIT\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/constants.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/container.js":
/*!******************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/container.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createGameShell = __webpack_require__(/*! game-shell */ \"./node_modules/game-shell/shell.js\")\n// var createGameShell = require('../../../../npm-modules/game-shell')\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter\n\n\nmodule.exports = function (noa, opts) {\n    return new Container(noa, opts)\n}\n\n/*\n *  Container module\n *    Wraps game-shell module and manages HTML container, canvas, etc.\n *    Emits: DOMready\n */\n\nfunction Container(noa, opts) {\n    opts = opts || {}\n    this._noa = noa\n    this.element = opts.domElement || createContainerDiv()\n    this.canvas = getOrCreateCanvas(this.element)\n    this._shell = createShell(this.canvas, opts)\n\n    // mouse state/feature detection\n    this.hasPointerLock = false\n    this.supportsPointerLock = false\n    this.pointerInGame = false\n    this.isFocused = document.hasFocus()\n\n    // basic listeners\n    var self = this\n    var lockChange = function (ev) { onLockChange(self, ev) }\n    document.addEventListener(\"pointerlockchange\", lockChange, false)\n    document.addEventListener(\"mozpointerlockchange\", lockChange, false)\n    document.addEventListener(\"webkitpointerlockchange\", lockChange, false)\n    detectPointerLock(self)\n\n    self.element.addEventListener('mouseenter', function () { self.pointerInGame = true })\n    self.element.addEventListener('mouseleave', function () { self.pointerInGame = false })\n\n    window.addEventListener('focus', function () { self.isFocused = true })\n    window.addEventListener('blur', function () { self.isFocused = false })\n\n    // get shell events after it's initialized\n    this._shell.on('init', onShellInit.bind(null, this))\n}\n\nContainer.prototype = Object.create(EventEmitter.prototype)\n\n\n\n/*\n *   SHELL EVENTS\n */\n\nfunction onShellInit(self) {\n    // create shell listeners that drive engine functions\n    var noa = self._noa\n    var shell = self._shell\n    shell.on('tick', function onTick(n) { noa.tick(n) })\n    shell.on('render', function onRender(n) { noa.render(n) })\n    shell.on('resize', noa.rendering.resize.bind(noa.rendering))\n\n    // let other components know DOM is ready\n    self.emit('DOMready')\n}\n\n\n\n/*\n *   PUBLIC API \n */\n\nContainer.prototype.appendTo = function (htmlElement) {\n    this.element.appendChild(htmlElement)\n}\n\n\n\nContainer.prototype.setPointerLock = function (lock) {\n    // not sure if this will work robustly\n    this._shell.pointerLock = !!lock\n}\n\n\n\n\n\n/*\n *   INTERNALS\n */\n\n\n\nfunction createContainerDiv() {\n    // based on github.com/mikolalysenko/game-shell - makeDefaultContainer()\n    var container = document.createElement(\"div\")\n    container.tabindex = 1\n    container.style.position = \"absolute\"\n    container.style.left = \"0px\"\n    container.style.right = \"0px\"\n    container.style.top = \"0px\"\n    container.style.bottom = \"0px\"\n    container.style.height = \"100%\"\n    container.style.overflow = \"hidden\"\n    document.body.appendChild(container)\n    document.body.style.overflow = \"hidden\" //Prevent bounce\n    document.body.style.height = \"100%\"\n    container.id = 'noa-container'\n    return container\n}\n\n\nfunction createShell(canvas, opts) {\n    var shellDefaults = {\n        pointerLock: true,\n        preventDefaults: false\n    }\n    opts = Object.assign(shellDefaults, opts)\n    opts.element = canvas\n    var shell = createGameShell(opts)\n    shell.preventDefaults = opts.preventDefaults\n    return shell\n}\n\nfunction getOrCreateCanvas(el) {\n    // based on github.com/stackgl/gl-now - default canvas\n    var canvas = el.querySelector('canvas')\n    if (!canvas) {\n        canvas = document.createElement('canvas')\n        canvas.style.position = \"absolute\"\n        canvas.style.left = \"0px\"\n        canvas.style.top = \"0px\"\n        canvas.style.height = \"100%\"\n        canvas.style.width = \"100%\"\n        canvas.id = 'noa-canvas'\n        el.insertBefore(canvas, el.firstChild)\n    }\n    return canvas\n}\n\n\n// track changes in Pointer Lock state\nfunction onLockChange(self, ev) {\n    var el = document.pointerLockElement ||\n        document.mozPointerLockElement ||\n        document.webkitPointerLockElement\n    if (el) {\n        self.hasPointerLock = true\n        self.emit('gainedPointerLock')\n    } else {\n        self.hasPointerLock = false\n        self.emit('lostPointerLock')\n    }\n    // this works around a Firefox bug where no mouse-in event \n    // gets issued after starting pointerlock\n    if (el) {\n        // act as if pointer is in game window while pointerLock is true\n        self.pointerInGame = true\n    }\n}\n\n\n// set up stuff to detect pointer lock support.\n// Needlessly complex because Chrome/Android claims to support but doesn't.\n// For now, just feature detect, but assume no support if a touch event occurs\n// TODO: see if this makes sense on hybrid touch/mouse devices\nfunction detectPointerLock(self) {\n    var lockElementExists =\n        ('pointerLockElement' in document) ||\n        ('mozPointerLockElement' in document) ||\n        ('webkitPointerLockElement' in document)\n    if (lockElementExists) {\n        self.supportsPointerLock = true\n        var listener = function (e) {\n            self.supportsPointerLock = false\n            document.removeEventListener(e.type, listener)\n        }\n        document.addEventListener('touchmove', listener)\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/container.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/entities.js":
/*!*****************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/entities.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"./node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\nvar EntComp = __webpack_require__(/*! ent-comp */ \"./node_modules/ent-comp/src/ECS.js\")\n// var EntComp = require('../../../../npm-modules/ent-comp')\n\nmodule.exports = function (noa, opts) {\n    return new Entities(noa, opts)\n}\n\nvar defaults = {\n    shadowDistance: 10,\n}\n\n\n\n/**\n * Wrangles entities. \n * This class is an instance of [ECS](https://github.com/andyhall/ent-comp), \n * and as such implements the usual ECS methods.\n * It's also decorated with helpers and accessor functions for getting component existence/state.\n * \n * Expects entity definitions in a specific format - see source `components` folder for examples.\n * \n * @class noa.entities\n */\n\nfunction Entities(noa, opts) {\n    // inherit from the ECS library\n    EntComp.call(this)\n\n    this.noa = noa\n    opts = Object.assign({}, defaults, opts)\n\n    // properties\n    /**\n     * Hash containing the component names of built-in components.\n     * @name names\n     */\n    this.names = {}\n\n    // options\n    var shadowDist = opts.shadowDistance\n\n    // register components with the ECS\n    this.names.position = this.createComponent(__webpack_require__(/*! ../components/position */ \"./node_modules/noa-engine/src/components/position.js\")(noa))\n    this.names.physics = this.createComponent(__webpack_require__(/*! ../components/physics */ \"./node_modules/noa-engine/src/components/physics.js\")(noa))\n    this.names.followsEntity = this.createComponent(__webpack_require__(/*! ../components/followsEntity */ \"./node_modules/noa-engine/src/components/followsEntity.js\")(noa))\n    this.names.mesh = this.createComponent(__webpack_require__(/*! ../components/mesh */ \"./node_modules/noa-engine/src/components/mesh.js\")(noa))\n    this.names.shadow = this.createComponent(__webpack_require__(/*! ../components/shadow */ \"./node_modules/noa-engine/src/components/shadow.js\")(noa, shadowDist))\n    this.names.collideTerrain = this.createComponent(__webpack_require__(/*! ../components/collideTerrain */ \"./node_modules/noa-engine/src/components/collideTerrain.js\")(noa))\n    this.names.collideEntities = this.createComponent(__webpack_require__(/*! ../components/collideEntities */ \"./node_modules/noa-engine/src/components/collideEntities.js\")(noa))\n    this.names.smoothCamera = this.createComponent(__webpack_require__(/*! ../components/smoothCamera */ \"./node_modules/noa-engine/src/components/smoothCamera.js\")(noa))\n    this.names.movement = this.createComponent(__webpack_require__(/*! ../components/movement */ \"./node_modules/noa-engine/src/components/movement.js\")(noa))\n    this.names.receivesInputs = this.createComponent(__webpack_require__(/*! ../components/receivesInputs */ \"./node_modules/noa-engine/src/components/receivesInputs.js\")(noa))\n    this.names.fadeOnZoom = this.createComponent(__webpack_require__(/*! ../components/fadeOnZoom */ \"./node_modules/noa-engine/src/components/fadeOnZoom.js\")(noa))\n\n    // decorate the entities object with accessor functions\n    this.isPlayer = function (id) { return id === noa.playerEntity }\n    this.hasPhysics = this.getComponentAccessor(this.names.physics)\n    this.cameraSmoothed = this.getComponentAccessor(this.names.smoothCamera)\n    this.hasMesh = this.getComponentAccessor(this.names.mesh)\n\n    // position functions\n    this.hasPosition = this.getComponentAccessor(this.names.position)\n    var getPos = this.getStateAccessor(this.names.position)\n    this.getPositionData = getPos\n    this.getPosition = function (id) { return getPos(id).position }\n    this.setPosition = function (id, x, y, z) {\n        var pdat = this.getPositionData(id)\n        vec3.set(pdat.position, x, y, z)\n        vec3.set(pdat.renderPosition, x, y, z)\n        pdat._extentsChanged = true\n        if (this.hasPhysics(id)) {\n            setAABBFromPosition(this.getPhysicsBody(id).aabb, pdat)\n        }\n    }\n\n    // physics\n    var getPhys = this.getStateAccessor(this.names.physics)\n    this.getPhysicsBody = function (id) { return getPhys(id).body }\n\n    // misc\n    this.getMeshData = this.getStateAccessor(this.names.mesh)\n    this.getMovement = this.getStateAccessor(this.names.movement)\n    this.getCollideTerrain = this.getStateAccessor(this.names.collideTerrain)\n    this.getCollideEntities = this.getStateAccessor(this.names.collideEntities)\n\n    // pairwise collideEntities event - this is for client to override\n    this.onPairwiseEntityCollision = function (id1, id2) {}\n\n    // events\n    var self = this\n    noa.on('tick', function (dt) { self.tick(dt) })\n    noa.on('beforeRender', function (dt) { self.render(dt) })\n\n}\n\n// inherit from EntComp\nEntities.prototype = Object.create(EntComp.prototype)\nEntities.prototype.constructor = Entities\n\n\n\n\n/*\n *\n *    ENTITY MANAGER API\n *\n */\n\n\n/** @param id,name,state */\nEntities.prototype.addComponentAgain = function (id, name, state) {\n    // removes component first if necessary\n    if (this.hasComponent(id, name)) this.removeComponent(id, name, true)\n    this.addComponent(id, name, state)\n}\n\n\n/** @param x,y,z */\nEntities.prototype.isTerrainBlocked = function (x, y, z) {\n    // checks if terrain location is blocked by entities\n    var box = _blockAABB\n    var eps = 0.001\n    box.setPosition([x + eps, y + eps, z + eps])\n    var hits = this.getEntitiesInAABB(box, this.names.collideTerrain)\n    return (hits.length > 0)\n}\nvar _blockAABB = new aabb([0, 0, 0], [0.998, 0.998, 0.998])\n\n\n/** @param x,y,z */\nEntities.prototype.setEntitySize = function (id, xs, ys, zs) {\n    // adding this so client doesn't need to understand the internals\n    if (!this.hasPosition(id)) throw 'Set size of entity without a position component'\n    var pdat = this.getPositionData(id)\n    pdat.width = (xs + zs) / 2\n    pdat.height = ys\n    pdat._extentsChanged = true\n    if (this.hasPhysics(id)) {\n        var box = this.getPhysicsBody(id).aabb\n        setAABBFromPosition(box, pdat)\n    }\n}\n\n\nfunction setAABBFromPosition(box, posData) {\n    var w = posData.width\n    var pos = posData.position\n    var hw = w / 2\n    vec3.set(box.base, pos[0] - hw, pos[1], pos[2] - hw)\n    vec3.set(box.vec, w, posData.height, w)\n    vec3.add(box.max, box.base, box.vec)\n}\n\n\n/** @param box */\nEntities.prototype.getEntitiesInAABB = function (box, withComponent) {\n    // TODO - use bipartite box-intersect?\n    var hits = []\n    var self = this\n    var posArr = (withComponent) ?\n        self.getStatesList(withComponent).map(function (state) {\n            return self.getPositionData(state.__id)\n        }) :\n        posArr = self.getStatesList(this.names.position)\n    var tmpBox = _searchBox\n    for (var i = 0; i < posArr.length; i++) {\n        setAABBFromPosition(tmpBox, posArr[i])\n        if (box.intersects(tmpBox)) hits.push(posArr[i].__id)\n    }\n    return hits\n}\nvar _searchBox = new aabb([], [])\n\n\n\n/** \n * Helper to set up a general entity, and populate with some common components depending on arguments.\n * \n * Parameters: position, width, height [, mesh, meshOffset, doPhysics, shadow]\n * \n * @param position\n * @param width\n * @param height..\n */\nEntities.prototype.add = function (position, width, height, // required\n    mesh, meshOffset, doPhysics, shadow) {\n\n    var self = this\n\n    // new entity\n    var eid = this.createEntity()\n\n    // position component - force position vector to be a vec3\n    var pos = vec3.create()\n    vec3.copy(pos, position)\n    this.addComponent(eid, this.names.position, {\n        position: pos,\n        width: width,\n        height: height\n    })\n\n    // rigid body in physics simulator\n    if (doPhysics) {\n        // body = this.noa.physics.addBody(box)\n        this.addComponent(eid, this.names.physics)\n        var body = this.getPhysicsBody(eid)\n\n        // handler for physics engine to call on auto-step\n        var smoothName = this.names.smoothCamera\n        body.onStep = function () {\n            self.addComponentAgain(eid, smoothName)\n        }\n    }\n\n    // mesh for the entity\n    if (mesh) {\n        if (!meshOffset) meshOffset = vec3.create()\n        this.addComponent(eid, this.names.mesh, {\n            mesh: mesh,\n            offset: meshOffset\n        })\n    }\n\n    // add shadow-drawing component\n    if (shadow) {\n        this.addComponent(eid, this.names.shadow, { size: width })\n    }\n\n    return eid\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/entities.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/inputs.js":
/*!***************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/inputs.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createInputs = __webpack_require__(/*! game-inputs */ \"./node_modules/game-inputs/inputs.js\")\n// var createInputs = require('../../../../npm-modules/game-inputs')\n\n\nmodule.exports = function (noa, opts, element) {\n    return makeInputs(noa, opts, element)\n}\n\n\nvar defaultBindings = {\n    bindings: {\n        \"forward\": [\"W\", \"<up>\"],\n        \"left\": [\"A\", \"<left>\"],\n        \"backward\": [\"S\", \"<down>\"],\n        \"right\": [\"D\", \"<right>\"],\n        \"fire\": \"<mouse 1>\",\n        \"mid-fire\": [\"<mouse 2>\", \"Q\"],\n        \"alt-fire\": [\"<mouse 3>\", \"E\"],\n        \"jump\": \"<space>\",\n        \"sprint\": \"<shift>\",\n        \"crouch\": \"<control>\"\n    }\n}\n\n\nfunction makeInputs(noa, opts, element) {\n    opts = Object.assign({}, defaultBindings, opts)\n    var inputs = createInputs(element, opts)\n    var b = opts.bindings\n    for (var name in b) {\n        var arr = (Array.isArray(b[name])) ? b[name] : [b[name]]\n        arr.unshift(name)\n        inputs.bind.apply(inputs, arr)\n    }\n    return inputs\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/inputs.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/objectMesher.js":
/*!*********************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/objectMesher.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nvar removeUnorderedListItem = __webpack_require__(/*! ./util */ \"./node_modules/noa-engine/src/lib/util.js\").removeUnorderedListItem\n\n\nmodule.exports = new ObjectMesher()\n\n\n// enable for profiling..\nvar PROFILE = 0\n\n\n\n\n// helper class to hold data about a single object mesh\nfunction ObjMeshDat(id, x, y, z) {\n    this.id = id | 0\n    this.x = x | 0\n    this.y = y | 0\n    this.z = z | 0\n}\n\n\n\n\n\n\n\n/*\n * \n * \n *          Object meshing\n *  Per-chunk handling of the creation/disposal of voxels with static meshes\n * \n * \n */\n\n\nfunction ObjectMesher() {\n\n\n    // adds properties to the new chunk that will be used when processing\n    this.initChunk = function (chunk) {\n        chunk._objectBlocks = {}\n        chunk._mergedObjectSystems = []\n    }\n\n    this.disposeChunk = function (chunk) {\n        removeCurrentSystems(chunk)\n        chunk._objectBlocks = null\n    }\n\n    function removeCurrentSystems(chunk) {\n        var systems = chunk._mergedObjectSystems\n        while (systems.length) {\n            var sps = systems.pop()\n            if (sps.mesh && chunk.octreeBlock && chunk.octreeBlock.entries) {\n                removeUnorderedListItem(chunk.octreeBlock.entries, sps.mesh)\n            }\n            if (sps.mesh) sps.mesh.dispose()\n            sps.dispose()\n        }\n    }\n\n\n\n    // accessors for the chunk to regester as object voxels are set/unset\n    this.addObjectBlock = function (chunk, id, x, y, z) {\n        var key = x + '|' + y + '|' + z\n        chunk._objectBlocks[key] = new ObjMeshDat(id, x, y, z, null)\n    }\n\n    this.removeObjectBlock = function (chunk, x, y, z) {\n        var key = x + '|' + y + '|' + z\n        if (chunk._objectBlocks[key]) delete chunk._objectBlocks[key]\n    }\n\n\n\n\n    /*\n     * \n     *    main implementation - re-creates all needed object mesh instances\n     * \n     */\n\n    this.buildObjectMesh = function (chunk) {\n        profile_hook('start')\n        // remove the current (if any) sps/mesh\n        removeCurrentSystems(chunk)\n\n        var scene = chunk.noa.rendering.getScene()\n        var objectMeshLookup = chunk.noa.registry._blockMeshLookup\n\n        // preprocess everything to build lists of object block keys\n        // hashed by material ID and then by block ID\n        var matIndexes = {}\n        for (var key in chunk._objectBlocks) {\n            var blockDat = chunk._objectBlocks[key]\n            var blockID = blockDat.id\n            var mat = objectMeshLookup[blockID].material\n            var matIndex = (mat) ? scene.materials.indexOf(mat) : -1\n            if (!matIndexes[matIndex]) matIndexes[matIndex] = {}\n            if (!matIndexes[matIndex][blockID]) matIndexes[matIndex][blockID] = []\n            matIndexes[matIndex][blockID].push(key)\n        }\n        profile_hook('preprocess')\n\n        // data structure now looks like:\n        // matIndexes = {\n        //      2: {                    // i.e. 2nd material in scene\n        //          14: {               // i.e. voxel ID 14 from registry\n        //              [ '2|3|4' ]     // key of block's local coords\n        //          }\n        //      }\n        // }\n\n        var x0 = chunk.i * chunk.size\n        var y0 = chunk.j * chunk.size\n        var z0 = chunk.k * chunk.size\n\n        // build one SPS for each material\n        for (var ix in matIndexes) {\n\n            var meshHash = matIndexes[ix]\n            var sps = buildSPSforMaterialIndex(chunk, scene, meshHash, x0, y0, z0)\n            profile_hook('made SPS')\n\n            // build SPS into the scene\n            var merged = sps.buildMesh()\n            profile_hook('built mesh')\n\n            // finish up\n            merged.material = (ix > -1) ? scene.materials[ix] : null\n            merged.position.x = x0\n            merged.position.y = y0\n            merged.position.z = z0\n            merged.freezeWorldMatrix()\n            merged.freezeNormals()\n\n            chunk.octreeBlock.entries.push(merged)\n            chunk._mergedObjectSystems.push(sps)\n        }\n\n        profile_hook('end')\n    }\n\n\n\n\n    function buildSPSforMaterialIndex(chunk, scene, meshHash, x0, y0, z0) {\n        var blockHash = chunk._objectBlocks\n        // base sps\n        var sps = new BABYLON.SolidParticleSystem('object_sps_' + chunk.id, scene, {\n            updatable: false,\n        })\n\n        var blockHandlerLookup = chunk.noa.registry._blockHandlerLookup\n        var objectMeshLookup = chunk.noa.registry._blockMeshLookup\n\n        // run through mesh hash adding shapes and position functions\n        for (var blockID in meshHash) {\n            var mesh = objectMeshLookup[blockID]\n            var blockArr = meshHash[blockID]\n            var count = blockArr.length\n\n            var handlerFn\n            var handlers = blockHandlerLookup[blockID]\n            if (handlers) handlerFn = handlers.onCustomMeshCreate\n            // jshint -W083\n            var setShape = function (particle, partIndex, shapeIndex) {\n                var key = blockArr[shapeIndex]\n                var dat = blockHash[key]\n                // set global positions for the custom handler, if any\n                particle.position.set(x0 + dat.x + 0.5, y0 + dat.y, z0 + dat.z + 0.5)\n                if (handlerFn) handlerFn(particle, x0 + dat.x, y0 + dat.y, z0 + dat.z)\n                // revert to local positions\n                particle.position.x -= x0\n                particle.position.y -= y0\n                particle.position.z -= z0\n            }\n            sps.addShape(mesh, count, { positionFunction: setShape })\n            blockArr.length = 0\n        }\n\n        return sps\n    }\n\n\n\n\n}\n\n\n\n\n\n\n\n\n\nvar profile_hook = (function () {\n    if (!PROFILE) return function () {}\n    var every = 50\n    var timer = new(__webpack_require__(/*! ./util */ \"./node_modules/noa-engine/src/lib/util.js\").Timer)(every, 'Object meshing')\n    return function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/objectMesher.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/physics.js":
/*!****************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/physics.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar createPhysics = __webpack_require__(/*! voxel-physics-engine */ \"./node_modules/voxel-physics-engine/src/index.js\")\n// var createPhysics = require('../../../../npm-modules/voxel-physics-engine')\n\n\nmodule.exports = function (noa, opts) {\n    return makePhysics(noa, opts)\n}\n\n\n/*\n *\n *    Simple wrapper module for the physics library\n *\n */\n\n\nvar defaults = {\n    gravity: [0, -10, 0],\n    airDrag: 0.1,\n}\n\n\nfunction makePhysics(noa, opts) {\n    opts = Object.assign({}, defaults, opts)\n    var world = noa.world\n    var blockGetter = function (x, y, z) { return world.getBlockSolidity(x, y, z) }\n    var isFluidGetter = function (x, y, z) { return world.getBlockFluidity(x, y, z) }\n\n    var physics = createPhysics(opts, blockGetter, isFluidGetter)\n\n    return physics\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/physics.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/registry.js":
/*!*****************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/registry.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (noa, opts) {\n    return new Registry(noa, opts)\n}\n\n\n/**\n * This is where clients register block types and their materials & properties.\n * @class noa.registry\n */\n\n\n/*\n *  data structs in the registry:\n *  registry \n *      blockSolidity:     id -> boolean\n *      blockOpacity:      id -> boolean\n *      blockIsFluid:      id -> boolean\n *      blockMats:         id -> 6x matID  [-x, +x, -y, +y, -z, +z]\n *      blockProps         id -> obj of less-often accessed properties\n *      blockMeshes:       id -> obj/null (custom mesh to instantiate)\n *      blockHandlers      id -> instance of `BlockCallbackHolder` or null \n *      matIDs             matName -> matID (int)\n *      matData            matID -> { color, alpha, texture, textureAlpha }\n */\n\n\nvar defaults = {\n    texturePath: ''\n}\n\nvar blockDefaults = {\n    solid: true,\n    opaque: true,\n    fluidDensity: 1.0,\n    viscosity: 0.5,\n}\n\nvar MAX_BLOCK_IDS = 255 // currently stored in chunks as int8\n\n\nfunction Registry(noa, opts) {\n    this.noa = noa\n    opts = Object.assign({}, defaults, opts)\n\n\n    /* \n     * \n     *      data structures\n     * \n     */\n\n    // lookup arrays for block props and flags - all keyed by blockID\n    // fill in first value for id=0, empty space\n    var blockSolidity = [false]\n    var blockOpacity = [false]\n    var blockIsFluid = [false]\n    var blockMats = [0, 0, 0, 0, 0, 0]\n    var blockProps = [null]\n    var blockMeshes = [null]\n    var blockHandlers = [null]\n\n    // material data structs\n    var matIDs = {} // mat name -> id\n    var matData = [null] // mat id -> { color, alpha, texture, textureAlpha }\n\n    // option data to save\n    var texturePath = opts.texturePath\n\n\n\n    /* \n     * \n     *      Block registration methods\n     * \n     */\n\n\n\n    /**\n     * Register (by integer ID) a block type and its parameters.\n     * \n     *  @param id: integer, currently 1..255. This needs to be passed in by the \n     *    client because it goes into the chunk data, which someday will get serialized.\n     * \n     *  @param options: Recognized fields for the options object:\n     * \n     *  * material: can be:\n     *      * one (String) material name\n     *      * array of 2 names: [top/bottom, sides]\n     *      * array of 3 names: [top, bottom, sides]\n     *      * array of 6 names: [-x, +x, -y, +y, -z, +z]\n     *    If not specified, terrain won't be meshed for the block type\n     *  * solid: (true) solidity for physics purposes\n     *  * opaque: (true) fully obscures neighboring blocks\n     *  * fluid: (false) whether nonsolid block is a fluid (buoyant, viscous..)\n     *  * blockMeshes: (null) if specified, noa will create an instance of the mesh instead of rendering voxel terrain\n     *  * fluidDensity: (1.0) for fluid blocks\n     *  * viscosity: (0.5) for fluid blocks\n     *  * onLoad(): block event handler\n     *  * onUnload(): block event handler\n     *  * onSet(): block event handler\n     *  * onUnset(): block event handler\n     *  * onCustomMeshCreate(): block event handler\n     */\n\n\n    this.registerBlock = function (id, _options) {\n        _options = _options || {}\n        blockDefaults.solid = !_options.fluid\n        blockDefaults.opaque = !_options.fluid\n        var opts = Object.assign({}, blockDefaults, _options)\n\n        // console.log('register block: ', id, opts)\n        if (id < 1 || id > MAX_BLOCK_IDS) throw 'Block id exceeds max: ' + id\n\n        // if block ID is greater than current highest ID, \n        // register fake blocks to avoid holes in lookup arrays\n        while (id > blockSolidity.length) {\n            this.registerBlock(blockSolidity.length, {})\n        }\n\n        // flags default to solid, opaque, nonfluid\n        blockSolidity[id] = !!opts.solid\n        blockOpacity[id] = !!opts.opaque\n        blockIsFluid[id] = !!opts.fluid\n\n        // store any custom mesh, and if one is present assume no material\n        blockMeshes[id] = opts.blockMesh || null\n        if (blockMeshes[id]) opts.material = null\n\n        // parse out material parameter\n        // always store 6 material IDs per blockID, so material lookup is monomorphic\n        var mat = opts.material || null\n        var mats\n        if (!mat) {\n            mats = [null, null, null, null, null, null]\n        } else if (typeof mat == 'string') {\n            mats = [mat, mat, mat, mat, mat, mat]\n        } else if (mat.length && mat.length == 2) {\n            // interpret as [top/bottom, sides]\n            mats = [mat[1], mat[1], mat[0], mat[0], mat[1], mat[1]]\n        } else if (mat.length && mat.length == 3) {\n            // interpret as [top, bottom, sides]\n            mats = [mat[2], mat[2], mat[0], mat[1], mat[2], mat[2]]\n        } else if (mat.length && mat.length == 6) {\n            // interpret as [-x, +x, -y, +y, -z, +z]\n            mats = mat\n        } else throw 'Invalid material parameter: ' + mat\n\n        // argument is material name, but store as material id, allocating one if needed\n        for (var i = 0; i < 6; ++i) {\n            blockMats[id * 6 + i] = getMaterialId(this, matIDs, mats[i], true)\n        }\n\n        // props data object - currently only used for fluid properties\n        blockProps[id] = {}\n\n        // if block is fluid, initialize properties if needed\n        if (blockIsFluid[id]) {\n            blockProps[id].fluidDensity = opts.fluidDensity\n            blockProps[id].viscosity = opts.viscosity\n        }\n\n        // event callbacks\n        var hasHandler = opts.onLoad || opts.onUnload || opts.onSet || opts.onUnset || opts.onCustomMeshCreate\n        blockHandlers[id] = (hasHandler) ? new BlockCallbackHolder(opts) : null\n\n        return id\n    }\n\n\n\n\n    /*\n     * Register (by name) a material and its parameters.\n     * \n     * @param name,color,textureURL,texHasAlpha\n     * @param renderMaterial an optional BABYLON material to be used for block faces with this block material\n     */\n\n    this.registerMaterial = function (name, color, textureURL, texHasAlpha, renderMaterial) {\n        // console.log('register mat: ', name, color, textureURL)\n        var id = matIDs[name] || matData.length\n        matIDs[name] = id\n        var alpha = 1\n        if (color && color.length == 4) {\n            alpha = color.pop()\n        }\n        matData[id] = {\n            color: color || [1, 1, 1],\n            alpha: alpha,\n            texture: textureURL ? texturePath + textureURL : '',\n            textureAlpha: !!texHasAlpha,\n            renderMat: renderMaterial || null,\n        }\n        return id\n    }\n\n\n\n    /*\n     *      quick accessors for querying block ID stuff\n     */\n\n    // block solidity (as in physics)\n    this.getBlockSolidity = function (id) {\n        return blockSolidity[id]\n    }\n\n    // block opacity - whether it obscures the whole voxel (dirt) or \n    // can be partially seen through (like a fencepost, etc)\n    this.getBlockOpacity = function (id) {\n        return blockOpacity[id]\n    }\n\n    // block is fluid or not\n    this.getBlockFluidity = function (id) {\n        return blockIsFluid[id]\n    }\n\n    // Get block property object passed in at registration\n    this.getBlockProps = function (id) {\n        return blockProps[id]\n    }\n\n    // look up a block ID's face material\n    // dir is a value 0..5: [ +x, -x, +y, -y, +z, -z ]\n    this.getBlockFaceMaterial = function (blockId, dir) {\n        return blockMats[blockId * 6 + dir]\n    }\n\n\n\n\n\n    // look up material color given ID\n    this.getMaterialColor = function (matID) {\n        return matData[matID].color\n    }\n\n    // look up material texture given ID\n    this.getMaterialTexture = function (matID) {\n        return matData[matID].texture\n    }\n\n    // look up material's properties: color, alpha, texture, textureAlpha\n    this.getMaterialData = function (matID) {\n        return matData[matID]\n    }\n\n\n\n\n\n    /*\n     * \n     *   Meant for internal use within the engine\n     * \n     */\n\n\n    // internal access to lookup arrays\n    this._solidityLookup = blockSolidity\n    this._opacityLookup = blockOpacity\n    this._blockMeshLookup = blockMeshes\n    this._blockHandlerLookup = blockHandlers\n\n\n\n\n\n\n    // look up color used for vertices of blocks of given material\n    // - i.e. white if it has a texture, color otherwise\n    this._getMaterialVertexColor = function (matID) {\n        if (matData[matID].texture) return white\n        return matData[matID].color\n    }\n    var white = [1, 1, 1]\n\n\n\n\n\n    /*\n     * \n     *      default initialization\n     * \n     */\n\n    // add a default material and set ID=1 to it\n    // note that registering new block data overwrites the old\n    this.registerMaterial('dirt', [0.4, 0.3, 0], null)\n    this.registerBlock(1, { material: 'dirt' })\n\n\n\n}\n\n\n\n/*\n * \n *          helpers\n * \n */\n\n\n\n// look up material ID given its name\n// if lazy is set, pre-register the name and return an ID\nfunction getMaterialId(reg, matIDs, name, lazyInit) {\n    if (!name) return 0\n    var id = matIDs[name]\n    if (id === undefined && lazyInit) id = reg.registerMaterial(name)\n    return id\n}\n\n\n\n// data class for holding block callback references\nfunction BlockCallbackHolder(opts) {\n    this.onLoad = opts.onLoad || null\n    this.onUnload = opts.onUnload || null\n    this.onSet = opts.onSet || null\n    this.onUnset = opts.onUnset || null\n    this.onCustomMeshCreate = opts.onCustomMeshCreate || null\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/registry.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/rendering.js":
/*!******************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/rendering.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar glvec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/noa-engine/node_modules/gl-vec3/index.js\")\nvar aabb = __webpack_require__(/*! aabb-3d */ \"./node_modules/aabb-3d/index.js\")\nvar sweep = __webpack_require__(/*! voxel-aabb-sweep */ \"./node_modules/voxel-aabb-sweep/index.js\")\nvar removeUnorderedListItem = __webpack_require__(/*! ./util */ \"./node_modules/noa-engine/src/lib/util.js\").removeUnorderedListItem\n\n\n// For now, assume Babylon.js has been imported into the global space already\nif (!BABYLON) {\n    throw new Error('Babylon.js reference not found! Abort! Abort!')\n}\n\nmodule.exports = function (noa, opts, canvas) {\n    return new Rendering(noa, opts, canvas)\n}\n\nvar vec3 = BABYLON.Vector3 // not a gl-vec3, in this module only!!\nvar col3 = BABYLON.Color3\n\n\n\n// profiling flags\nvar PROFILE = 0\n\n\n\nvar defaults = {\n    showFPS: false,\n    antiAlias: true,\n    clearColor: [0.8, 0.9, 1],\n    ambientColor: [1, 1, 1],\n    lightDiffuse: [1, 1, 1],\n    lightSpecular: [1, 1, 1],\n    groundLightColor: [0.5, 0.5, 0.5],\n    initialCameraZoom: 0,\n    cameraZoomSpeed: .2,\n    cameraMaxAngle: (Math.PI / 2) - 0.01,\n    useAO: true,\n    AOmultipliers: [0.93, 0.8, 0.5],\n    reverseAOmultiplier: 1.0,\n    useOctreesForDynamicMeshes: true,\n    preserveDrawingBuffer: true,\n}\n\n\n\n\n\nfunction Rendering(noa, opts, canvas) {\n    this.noa = noa\n    opts = Object.assign({}, defaults, opts)\n    this.zoomDistance = opts.initialCameraZoom // zoom setting\n    this._currentZoom = this.zoomDistance // current actual zoom level\n    this._cameraZoomSpeed = opts.cameraZoomSpeed\n    this._maxCamAngle = opts.cameraMaxAngle\n\n    // internals\n    this._dynamicMeshes = []\n    this.useAO = !!opts.useAO\n    this.aoVals = opts.AOmultipliers\n    this.revAoVal = opts.reverseAOmultiplier\n    this.meshingCutoffTime = 6 // ms\n    this._dynamicMeshOctrees = opts.useOctreesForDynamicMeshes\n    this._resizeDebounce = 250 // ms\n\n    // set up babylon scene\n    initScene(this, canvas, opts)\n\n    // for debugging\n    if (opts.showFPS) setUpFPS()\n}\n\n\n// Constructor helper - set up the Babylon.js scene and basic components\nfunction initScene(self, canvas, opts) {\n    if (!BABYLON) throw new Error('BABYLON.js engine not found!')\n\n    // init internal properties\n    self._engine = new BABYLON.Engine(canvas, opts.antiAlias, {\n        preserveDrawingBuffer: opts.preserveDrawingBuffer,\n    })\n    self._scene = new BABYLON.Scene(self._engine)\n    var scene = self._scene\n    // remove built-in listeners\n    scene.detachControl()\n\n    // octree setup\n    self._octree = new BABYLON.Octree($ => {})\n    self._octree.blocks = []\n    scene._selectionOctree = self._octree\n\n    // camera, and empty mesh to hold it, and one to accumulate rotations\n    self._rotationHolder = new BABYLON.Mesh('rotHolder', scene)\n    self._cameraHolder = new BABYLON.Mesh('camHolder', scene)\n    self._camera = new BABYLON.FreeCamera('camera', new vec3(0, 0, 0), scene)\n    self._camera.parent = self._cameraHolder\n    self._camera.minZ = .01\n    self._cameraHolder.visibility = false\n    self._rotationHolder.visibility = false\n\n    // plane obscuring the camera - for overlaying an effect on the whole view\n    self._camScreen = BABYLON.Mesh.CreatePlane('camScreen', 10, scene)\n    self.addMeshToScene(self._camScreen)\n    self._camScreen.position.z = .1\n    self._camScreen.parent = self._camera\n    self._camScreenMat = self.makeStandardMaterial('camscreenmat')\n    self._camScreen.material = self._camScreenMat\n    self._camScreen.setEnabled(false)\n    self._camLocBlock = 0\n\n    // apply some defaults\n    self._light = new BABYLON.HemisphericLight('light', new vec3(0.1, 1, 0.3), scene)\n\n    function arrToColor(a) { return new col3(a[0], a[1], a[2]) }\n    scene.clearColor = arrToColor(opts.clearColor)\n    scene.ambientColor = arrToColor(opts.ambientColor)\n    self._light.diffuse = arrToColor(opts.lightDiffuse)\n    self._light.specular = arrToColor(opts.lightSpecular)\n    self._light.groundColor = arrToColor(opts.groundLightColor)\n\n    // make a default flat material (used or clone by terrain, etc)\n    self.flatMaterial = self.makeStandardMaterial('flatmat')\n\n}\n\n\n\n/*\n *   PUBLIC API \n */\n\n// Init anything about scene that needs to wait for engine internals\nRendering.prototype.initScene = function () {\n    // engine entity to follow the player and act as camera target\n    this.cameraTarget = this.noa.ents.createEntity(['position'])\n    this.noa.ents.addComponent(this.cameraTarget, 'followsEntity', {\n        entity: this.noa.playerEntity,\n        offset: [0, this.noa.playerEyeOffset, 0],\n    })\n}\n\n// accessor for client app to build meshes and register materials\nRendering.prototype.getScene = function () {\n    return this._scene\n}\n\n// per-tick listener for rendering-related stuff\nRendering.prototype.tick = function (dt) {\n    if (this._dynamicMeshOctrees) updateDynamicMeshOctrees(this)\n}\n\n\n\n\n\nRendering.prototype.render = function (dt) {\n    profile_hook('start')\n    updateCamera(this)\n    profile_hook('updateCamera')\n    this._engine.beginFrame()\n    profile_hook('beginFrame')\n    this._scene.render()\n    profile_hook('render')\n    fps_hook()\n    this._engine.endFrame()\n    profile_hook('endFrame')\n    profile_hook('end')\n}\n\n\n\nRendering.prototype.resize = function (e) {\n    if (!pendingResize) {\n        pendingResize = true\n        setTimeout(() => {\n            this._engine.resize()\n            pendingResize = false\n        }, this._resizeDebounce)\n    }\n}\nvar pendingResize = false\n\n\n\nRendering.prototype.highlightBlockFace = function (show, posArr, normArr) {\n    var m = getHighlightMesh(this)\n    if (show) {\n        // bigger slop when zoomed out\n        var dist = this._currentZoom + glvec3.distance(this.noa.getPlayerEyePosition(), posArr)\n        var slop = 0.001 + 0.001 * dist\n        var pos = _highlightPos\n        for (var i = 0; i < 3; ++i) {\n            pos[i] = Math.floor(posArr[i]) + .5 + ((0.5 + slop) * normArr[i])\n        }\n        m.position.copyFromFloats(pos[0], pos[1], pos[2])\n        m.rotation.x = (normArr[1]) ? Math.PI / 2 : 0\n        m.rotation.y = (normArr[0]) ? Math.PI / 2 : 0\n    }\n    m.setEnabled(show)\n}\nvar _highlightPos = glvec3.create()\n\n\nRendering.prototype.getCameraVector = function () {\n    return vec3.TransformCoordinates(BABYLON.Axis.Z, this._rotationHolder.getWorldMatrix())\n}\nvar zero = vec3.Zero()\nRendering.prototype.getCameraPosition = function () {\n    return vec3.TransformCoordinates(zero, this._camera.getWorldMatrix())\n}\nRendering.prototype.getCameraRotation = function () {\n    var rot = this._rotationHolder.rotation\n    return [rot.x, rot.y]\n}\nRendering.prototype.setCameraRotation = function (x, y) {\n    var rot = this._rotationHolder.rotation\n    rot.x = Math.max(-this._maxCamAngle, Math.min(this._maxCamAngle, x))\n    rot.y = y\n}\n\n\n\n\n// add a mesh to the scene's octree setup so that it renders\n// pass in isStatic=true if the mesh won't move (i.e. change octree blocks)\nRendering.prototype.addMeshToScene = function (mesh, isStatic) {\n    // exit silently if mesh has already been added and not removed\n    if (mesh._currentNoaChunk || this._octree.dynamicContent.includes(mesh)) {\n        return\n    }\n    var pos = mesh.position\n    var chunk = this.noa.world._getChunkByCoords(pos.x, pos.y, pos.z)\n    if (this._dynamicMeshOctrees && chunk && chunk.octreeBlock) {\n        // add to an octree\n        chunk.octreeBlock.entries.push(mesh)\n        mesh._currentNoaChunk = chunk\n    } else {\n        // mesh added outside an active chunk - so treat as scene-dynamic\n        this._octree.dynamicContent.push(mesh)\n    }\n    // remember for updates if it's not static\n    if (!isStatic) this._dynamicMeshes.push(mesh)\n    // handle remover when mesh gets disposed\n    var remover = this.removeMeshFromScene.bind(this, mesh)\n    mesh.onDisposeObservable.add(remover)\n}\n\n// undo the above\nRendering.prototype.removeMeshFromScene = function (mesh) {\n    if (mesh._currentNoaChunk && mesh._currentNoaChunk.octreeBlock) {\n        removeUnorderedListItem(mesh._currentNoaChunk.octreeBlock.entries, mesh)\n    }\n    mesh._currentNoaChunk = null\n    removeUnorderedListItem(this._octree.dynamicContent, mesh)\n    removeUnorderedListItem(this._dynamicMeshes, mesh)\n}\n\n\n\n\n// runs once per tick - move any dynamic meshes to correct chunk octree\nfunction updateDynamicMeshOctrees(self) {\n    for (var i = 0; i < self._dynamicMeshes.length; i++) {\n        var mesh = self._dynamicMeshes[i]\n        if (mesh._isDisposed) continue // shouldn't be possible\n        var pos = mesh.position\n        var prev = mesh._currentNoaChunk || null\n        var next = self.noa.world._getChunkByCoords(pos.x, pos.y, pos.z) || null\n        if (prev === next) continue\n        // mesh has moved chunks since last update\n        // remove from previous location...\n        if (prev && prev.octreeBlock) {\n            removeUnorderedListItem(prev.octreeBlock.entries, mesh)\n        } else {\n            removeUnorderedListItem(self._octree.dynamicContent, mesh)\n        }\n        // ... and add to new location\n        if (next && next.octreeBlock) {\n            next.octreeBlock.entries.push(mesh)\n        } else {\n            self._octree.dynamicContent.push(mesh)\n        }\n        mesh._currentNoaChunk = next\n    }\n}\n\n\n\nRendering.prototype.makeMeshInstance = function (mesh, isStatic) {\n    var m = mesh.createInstance(mesh.name + ' instance' || false)\n    if (mesh.billboardMode) m.billboardMode = mesh.billboardMode\n    // add to scene so as to render\n    this.addMeshToScene(m, isStatic)\n\n    // testing performance tweaks\n\n    // make instance meshes skip over getLOD checks, since there may be lots of them\n    // mesh.getLOD = m.getLOD = function () { return mesh }\n    m._currentLOD = mesh\n\n    // make terrain instance meshes skip frustum checks \n    // (they'll still get culled by octree checks)\n    // if (isStatic) m.isInFrustum = function () { return true }\n\n    return m\n}\n\n\n\n// Create a default standardMaterial:\n//      flat, nonspecular, fully reflects diffuse and ambient light\nRendering.prototype.makeStandardMaterial = function (name) {\n    var mat = new BABYLON.StandardMaterial(name, this._scene)\n    mat.specularColor.copyFromFloats(0, 0, 0)\n    mat.ambientColor.copyFromFloats(1, 1, 1)\n    mat.diffuseColor.copyFromFloats(1, 1, 1)\n    return mat\n}\n\n\n\n\n\n\n\n/*\n *\n * \n *   ACCESSORS FOR CHUNK ADD/REMOVAL/MESHING\n *\n * \n */\n\nRendering.prototype.prepareChunkForRendering = function (chunk) {\n    var cs = chunk.size\n    var min = new vec3(chunk.x, chunk.y, chunk.z)\n    var max = new vec3(chunk.x + cs, chunk.y + cs, chunk.z + cs)\n    chunk.octreeBlock = new BABYLON.OctreeBlock(min, max, undefined, undefined, undefined, $ => {})\n    this._octree.blocks.push(chunk.octreeBlock)\n}\n\nRendering.prototype.disposeChunkForRendering = function (chunk) {\n    this.removeTerrainMesh(chunk)\n    removeUnorderedListItem(this._octree.blocks, chunk.octreeBlock)\n    chunk.octreeBlock.entries.length = 0\n    chunk.octreeBlock = null\n}\n\nRendering.prototype.addTerrainMesh = function (chunk, mesh) {\n    this.removeTerrainMesh(chunk)\n    if (mesh.getIndices().length) this.addMeshToScene(mesh, true)\n    chunk._terrainMesh = mesh\n}\n\nRendering.prototype.removeTerrainMesh = function (chunk) {\n    if (!chunk._terrainMesh) return\n    chunk._terrainMesh.dispose()\n    chunk._terrainMesh = null\n}\n\n\n\n\n\n\n\n\n\n/*\n *\n *   INTERNALS\n *\n */\n\n\n\n\n/*\n *\n *  zoom/camera related internals\n *\n */\n\n\n// check if obstructions are behind camera by sweeping back an AABB\n// along the negative camera vector\n\nfunction cameraObstructionDistance(self) {\n    var size = 0.2\n    if (!_camBox) {\n        _camBox = new aabb([0, 0, 0], [size * 2, size * 2, size * 2])\n        _getVoxel = function (x, y, z) {\n            return self.noa.world.getBlockSolidity(x, y, z)\n        }\n    }\n\n    var pos = self._cameraHolder.position\n    glvec3.set(_posVec, pos.x - size, pos.y - size, pos.z - size)\n    _camBox.setPosition(_posVec)\n\n    var dist = -self.zoomDistance\n    var cam = self.getCameraVector()\n    glvec3.set(_camVec, dist * cam.x, dist * cam.y, dist * cam.z)\n\n    return sweep(_getVoxel, _camBox, _camVec, function (dist, axis, dir, vec) {\n        return true\n    }, true)\n}\n\nvar _posVec = glvec3.create()\nvar _camVec = glvec3.create()\nvar _camBox\nvar _getVoxel\n\n\n\n\n// Various updates to camera position/zoom, called every render\n\nfunction updateCamera(self) {\n    // update cameraHolder pos/rot from rotation holder and target entity\n    self._cameraHolder.rotation.copyFrom(self._rotationHolder.rotation)\n    var cpos = self.noa.ents.getPositionData(self.cameraTarget).renderPosition\n    self._cameraHolder.position.copyFromFloats(cpos[0], cpos[1], cpos[2])\n\n    // check obstructions and tween camera towards clipped position\n    var dist = self.zoomDistance\n    var speed = self._cameraZoomSpeed\n    if (dist > 0) {\n        dist = cameraObstructionDistance(self)\n        if (dist < self._currentZoom) self._currentZoom = dist\n    }\n    self._currentZoom += speed * (dist - self._currentZoom)\n    self._camera.position.z = -self._currentZoom\n\n    // check id of block camera is in for overlay effects (e.g. being in water) \n    var cam = self.getCameraPosition()\n    var id = self.noa.world.getBlockID(Math.floor(cam.x), Math.floor(cam.y), Math.floor(cam.z))\n    checkCameraEffect(self, id)\n}\n\n\n\n//  If camera's current location block id has alpha color (e.g. water), apply/remove an effect\n\nfunction checkCameraEffect(self, id) {\n    if (id === self._camLocBlock) return\n    if (id === 0) {\n        self._camScreen.setEnabled(false)\n    } else {\n        var matId = self.noa.registry.getBlockFaceMaterial(id, 0)\n        if (matId) {\n            var matData = self.noa.registry.getMaterialData(matId)\n            var col = matData.color\n            var alpha = matData.alpha\n            if (col && alpha && alpha < 1) {\n                self._camScreenMat.diffuseColor = new col3(col[0], col[1], col[2])\n                self._camScreenMat.alpha = alpha\n                self._camScreen.setEnabled(true)\n            }\n        }\n    }\n    self._camLocBlock = id\n}\n\n\n\n\n\n\n// make or get a mesh for highlighting active voxel\nfunction getHighlightMesh(rendering) {\n    var m = rendering._highlightMesh\n    if (!m) {\n        var mesh = BABYLON.Mesh.CreatePlane(\"highlight\", 1.0, rendering._scene)\n        var hlm = rendering.makeStandardMaterial('highlightMat')\n        hlm.backFaceCulling = false\n        hlm.emissiveColor = new col3(1, 1, 1)\n        hlm.alpha = 0.2\n        mesh.material = hlm\n        m = rendering._highlightMesh = mesh\n        // outline\n        var s = 0.5\n        var lines = BABYLON.Mesh.CreateLines(\"hightlightLines\", [\n            new vec3(s, s, 0),\n            new vec3(s, -s, 0),\n            new vec3(-s, -s, 0),\n            new vec3(-s, s, 0),\n            new vec3(s, s, 0)\n        ], rendering._scene)\n        lines.color = new col3(1, 1, 1)\n        lines.parent = mesh\n\n        rendering.addMeshToScene(m)\n        rendering.addMeshToScene(lines)\n    }\n    return m\n}\n\n\n\n\n\n\n\n\n\n/*\n * \n *      sanity checks:\n * \n */\n\nRendering.prototype.debug_SceneCheck = function () {\n    var meshes = this._scene.meshes\n    var dyns = this._octree.dynamicContent\n    var octs = []\n    var numOcts = 0\n    var mats = this._scene.materials\n    var allmats = []\n    mats.forEach(mat => {\n        if (mat.subMaterials) mat.subMaterials.forEach(mat => allmats.push(mat))\n        else allmats.push(mat)\n    })\n    this._octree.blocks.forEach(function (block) {\n        numOcts++\n        block.entries.forEach(m => octs.push(m))\n    })\n    meshes.forEach(function (m) {\n        if (m._isDisposed) warn(m, 'disposed mesh in scene')\n        if (empty(m)) return\n        if (missing(m, dyns, octs)) warn(m, 'non-empty mesh missing from octree')\n        if (!m.material) { warn(m, 'non-empty scene mesh with no material'); return }\n        (m.material.subMaterials || [m.material]).forEach(function (mat) {\n            if (missing(mat, mats)) warn(mat, 'mesh material not in scene')\n        })\n    })\n    var unusedMats = []\n    allmats.forEach(mat => {\n        var used = false\n        meshes.forEach(mesh => {\n            if (mesh.material === mat) used = true\n            if (!mesh.material || !mesh.material.subMaterials) return\n            if (mesh.material.subMaterials.includes(mat)) used = true\n        })\n        if (!used) unusedMats.push(mat.name)\n    })\n    if (unusedMats.length) {\n        console.warn('Materials unused by any mesh: ', unusedMats.join(', '))\n    }\n    dyns.forEach(function (m) {\n        if (missing(m, meshes)) warn(m, 'octree/dynamic mesh not in scene')\n    })\n    octs.forEach(function (m) {\n        if (missing(m, meshes)) warn(m, 'octree block mesh not in scene')\n    })\n    var avgPerOct = Math.round(10 * octs.length / numOcts) / 10\n    console.log('meshes - octree:', octs.length, '  dynamic:', dyns.length,\n        '   avg meshes/octreeBlock:', avgPerOct)\n\n    function warn(obj, msg) { console.warn(obj.name + ' --- ' + msg) }\n\n    function empty(mesh) { return (mesh.getIndices().length === 0) }\n\n    function missing(obj, list1, list2) {\n        if (!obj) return false\n        if (list1.includes(obj)) return false\n        if (list2 && list2.includes(obj)) return false\n        return true\n    }\n    return 'done.'\n}\n\nRendering.prototype.debug_MeshCount = function () {\n    var ct = {}\n    this._scene.meshes.forEach(m => {\n        var n = m.name || ''\n        n = n.replace(/-\\d+.*/, '#')\n        n = n.replace(/\\d+.*/, '#')\n        n = n.replace(/(rotHolder|camHolder|camScreen)/, 'rendering use')\n        n = n.replace(/atlas sprite .*/, 'atlas sprites')\n        ct[n] = ct[n] || 0\n        ct[n]++\n    })\n    for (var s in ct) console.log('   ' + (ct[s] + '       ').substr(0, 7) + s)\n}\n\n\n\n\n\n\n\nvar profile_hook = (function () {\n    if (!PROFILE) return function () {}\n    var every = 200\n    var timer = new(__webpack_require__(/*! ./util */ \"./node_modules/noa-engine/src/lib/util.js\").Timer)(every, 'render internals')\n    return function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n\nvar fps_hook = function () {}\n\nfunction setUpFPS() {\n    var div = document.createElement('div')\n    div.id = 'noa_fps'\n    var style = 'position:absolute; top:0; right:0; z-index:0;'\n    style += 'color:white; background-color:rgba(0,0,0,0.5);'\n    style += 'font:14px monospace; text-align:center;'\n    style += 'min-width:2em; margin:4px;'\n    div.style = style\n    document.body.appendChild(div)\n    var every = 1000\n    var ct = 0\n    var longest = 0\n    var start = performance.now()\n    var last = start\n    fps_hook = function () {\n        ct++\n        var nt = performance.now()\n        if (nt - last > longest) longest = nt - last\n        last = nt\n        if (nt - start < every) return\n        var fps = Math.round(ct / (nt - start) * 1000)\n        var min = Math.round(1 / longest * 1000)\n        div.innerHTML = fps + '<br>' + min\n        ct = 0\n        longest = 0\n        start = nt\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/rendering.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/terrainMesher.js":
/*!**********************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/terrainMesher.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n\n\nmodule.exports = new TerrainMesher()\n\n\n\n\n// enable for profiling..\nvar PROFILE = 0\n\n\n\n\n/*\n * \n *          TERRAIN MESHER!!\n * \n */\n\n\nfunction TerrainMesher() {\n\n    var greedyMesher = new GreedyMesher()\n    var meshBuilder = new MeshBuilder()\n\n\n    /*\n     * \n     * Entry point and high-level flow\n     * \n     */\n\n    this.meshChunk = function (chunk, matGetter, colGetter, ignoreMaterials, useAO, aoVals, revAoVal) {\n        profile_hook('start')\n        var noa = chunk.noa\n\n        // args\n        var array = chunk.array\n        var mats = matGetter || noa.registry.getBlockFaceMaterial\n        var cols = colGetter || noa.registry._getMaterialVertexColor\n        var ao = (useAO === undefined) ? noa.rendering.useAO : useAO\n        var vals = aoVals || noa.rendering.aoVals\n        var rev = isNaN(revAoVal) ? noa.rendering.revAoVal : revAoVal\n\n        // greedy mesher creates an array of Submesh structs\n        var subMeshes = greedyMesher.mesh(array, mats, cols, ao, vals, rev)\n\n        // builds the babylon mesh that will be added to the scene\n        var mesh\n        if (Object.keys(subMeshes).length) {\n            mesh = meshBuilder.build(chunk, subMeshes, ignoreMaterials)\n            profile_hook('built terrain')\n        }\n\n        profile_hook('end')\n        return mesh || null\n    }\n\n}\n\n\n\n\n/*\n * \n *  Submesh - holds one submesh worth of greedy-meshed data\n * \n *  Basically, the greedy mesher builds these and the mesh builder consumes them\n * \n */\n\nfunction Submesh(id) {\n    this.id = id | 0\n    this.positions = []\n    this.indices = []\n    this.normals = []\n    this.colors = []\n    this.uvs = []\n}\n\nSubmesh.prototype.dispose = function () {\n    this.positions = null\n    this.indices = null\n    this.normals = null\n    this.colors = null\n    this.uvs = null\n}\n\n\n\n\n\n\n\n\n/*\n * \n *  Mesh Builder - turns an array of Submesh data into a \n *  Babylon.js mesh/submeshes, ready to be added to the scene\n * \n */\n\nfunction MeshBuilder() {\n\n    var noa\n\n\n    // core\n    this.build = function (chunk, meshdata, ignoreMaterials) {\n        noa = chunk.noa\n\n        // preprocess meshdata entries to merge those that will use default terrain material\n        var mergeCriteria = function (mdat) {\n            if (ignoreMaterials) return true\n            if (mdat.renderMat) return false\n            var url = noa.registry.getMaterialTexture(mdat.id)\n            var alpha = noa.registry.getMaterialData(mdat.id).alpha\n            if (url || alpha < 1) return false\n        }\n        mergeSubmeshes(meshdata, mergeCriteria)\n\n        // now merge everything, keeping track of vertices/indices/materials\n        var results = mergeSubmeshes(meshdata, () => true)\n\n        // merge sole remaining submesh instance into a babylon mesh\n        var mdat = meshdata[results.mergedID]\n        var name = 'chunk_' + chunk.id\n        var mats = results.matIDs.map(id => getTerrainMaterial(id, ignoreMaterials))\n        var mesh = buildMeshFromSubmesh(mdat, name, mats, results.vertices, results.indices)\n\n        // position, freeze and exit\n        var x = chunk.i * chunk.size\n        var y = chunk.j * chunk.size\n        var z = chunk.k * chunk.size\n        mesh.position.x = x\n        mesh.position.y = y\n        mesh.position.z = z\n\n        mesh.freezeWorldMatrix()\n        mesh.freezeNormals()\n        return mesh\n    }\n\n\n\n    // this version builds a parent mesh + child meshes, rather than\n    // one big mesh with submeshes and a multimaterial.\n    // This should be obsolete, unless the first one has problems..\n    this.buildWithoutMultimats = function (chunk, meshdata, ignoreMaterials) {\n        noa = chunk.noa\n\n        // preprocess meshdata entries to merge those that use default terrain material\n        var mergeCriteria = function (mdat) {\n            if (ignoreMaterials) return true\n            if (mdat.renderMat) return false\n            var url = noa.registry.getMaterialTexture(mdat.id)\n            var alpha = noa.registry.getMaterialData(mdat.id).alpha\n            if (url || alpha < 1) return false\n        }\n        mergeSubmeshes(meshdata, mergeCriteria)\n\n        // go through (remaining) meshdata entries and create a mesh for each\n        // call the first one the parent, and attach others to it\n        var parent = null\n        var keylist = Object.keys(meshdata)\n        for (var i = 0; i < keylist.length; ++i) {\n            var mdat = meshdata[keylist[i]]\n            var matID = mdat.id\n            var mat = getTerrainMaterial(matID, ignoreMaterials)\n            var name = 'chunk_inner_' + chunk.id + ' ' + matID\n            var mesh = buildMeshFromSubmesh(mdat, name, [mat])\n\n            if (!parent) {\n                parent = mesh\n                // position the parent globally\n                var x = chunk.i * chunk.size\n                var y = chunk.j * chunk.size\n                var z = chunk.k * chunk.size\n                parent.position.x = x\n                parent.position.y = y\n                parent.position.z = z\n            } else {\n                mesh.parent = parent\n            }\n\n            mesh.freezeWorldMatrix()\n            mesh.freezeNormals()\n        }\n\n        return parent\n    }\n\n\n\n    // given a set of submesh objects, merge all those that \n    // meet some criteria into the first such submesh\n    //      modifies meshDataList in place!\n    function mergeSubmeshes(meshDataList, criteria) {\n        var vertices = []\n        var indices = []\n        var matIDs = []\n\n        var keylist = Object.keys(meshDataList)\n        var target = null\n        var targetID\n        for (var i = 0; i < keylist.length; ++i) {\n            var mdat = meshDataList[keylist[i]]\n            if (!criteria(mdat)) continue\n\n            vertices.push(mdat.positions.length)\n            indices.push(mdat.indices.length)\n            matIDs.push(mdat.id)\n\n            if (!target) {\n                target = mdat\n                targetID = keylist[i]\n\n            } else {\n                var indexOffset = target.positions.length / 3\n                // merge data in \"mdat\" onto \"target\"\n                target.positions = target.positions.concat(mdat.positions)\n                target.normals = target.normals.concat(mdat.normals)\n                target.colors = target.colors.concat(mdat.colors)\n                target.uvs = target.uvs.concat(mdat.uvs)\n                // indices must be offset relative to data being merged onto\n                for (var j = 0, len = mdat.indices.length; j < len; ++j) {\n                    target.indices.push(mdat.indices[j] + indexOffset)\n                }\n                // get rid of entry that's been merged\n                mdat.dispose()\n                delete meshDataList[keylist[i]]\n            }\n        }\n\n        return {\n            mergedID: targetID,\n            vertices: vertices,\n            indices: indices,\n            matIDs: matIDs,\n        }\n    }\n\n\n\n    function buildMeshFromSubmesh(submesh, name, mats, verts, inds) {\n\n        // base mesh and vertexData object\n        var scene = noa.rendering.getScene()\n        var mesh = new BABYLON.Mesh(name, scene)\n        var vdat = new BABYLON.VertexData()\n        vdat.positions = submesh.positions\n        vdat.indices = submesh.indices\n        vdat.normals = submesh.normals\n        vdat.colors = submesh.colors\n        vdat.uvs = submesh.uvs\n        vdat.applyToMesh(mesh)\n        submesh.dispose()\n\n        if (mats.length === 1) {\n            // if only one material ID, assign as a regular mesh and return\n            mesh.material = mats[0]\n\n        } else {\n            // else we need to make a multimaterial and define (babylon) submeshes\n            var multiMat = new BABYLON.MultiMaterial('multimat ' + name, scene)\n            mesh.subMeshes = []\n            // var totalVerts = vdat.positions.length\n            // var totalInds = vdat.indices.length\n            var vertStart = 0\n            var indStart = 0\n            for (var i = 0; i < mats.length; i++) {\n                multiMat.subMaterials[i] = mats[i]\n                var sub = new BABYLON.SubMesh(i, vertStart, verts[i], indStart, inds[i], mesh)\n                mesh.subMeshes[i] = sub\n                vertStart += verts[i]\n                indStart += inds[i]\n            }\n            mesh.material = multiMat\n        }\n\n        return mesh\n    }\n\n\n\n\n    //                         Material wrangling\n\n\n    var materialCache = {}\n\n    // manage materials/textures to avoid duplicating them\n    function getTerrainMaterial(matID, ignore) {\n        if (ignore) return noa.rendering.flatMaterial\n        var name = 'terrain mat ' + matID\n        if (!materialCache[name]) materialCache[name] = makeTerrainMaterial(matID)\n        return materialCache[name]\n    }\n\n\n    // canonical function to make a terrain material\n    function makeTerrainMaterial(id) {\n        // if user-specified render material is defined, use it\n        var matData = noa.registry.getMaterialData(id)\n        if (matData.renderMat) return matData.renderMat\n        // otherwise determine which built-in material to use\n        var url = noa.registry.getMaterialTexture(id)\n        var alpha = matData.alpha\n        if (!url && alpha == 1) {\n            // base material is fine for non-textured case, if no alpha\n            return noa.rendering.flatMaterial\n        }\n        var mat = noa.rendering.flatMaterial.clone('terrain' + id)\n        if (url) {\n            var scene = noa.rendering.getScene()\n            var tex = new BABYLON.Texture(url, scene, true, false, BABYLON.Texture.NEAREST_SAMPLINGMODE)\n            if (matData.textureAlpha) tex.hasAlpha = true\n            mat.diffuseTexture = tex\n        }\n        if (matData.alpha < 1) {\n            mat.alpha = matData.alpha\n        }\n        return mat\n    }\n}\n\n\n\n\n\n\n\n\n/*\n *    Greedy voxel meshing algorithm\n *        based initially on algo by Mikola Lysenko:\n *          http://0fps.net/2012/07/07/meshing-minecraft-part-2/\n *          but evolved quite a bit since then\n *        AO handling by me, stitched together out of cobwebs and dreams\n *    \n *    Arguments:\n *        arr: 3D ndarray of dimensions X,Y,Z\n *             packed with solidity/opacity booleans in higher bits\n *        getMaterial: function( blockID, dir )\n *             returns a material ID based on block id and which cube face it is\n *             (assume for now that each mat ID should get its own mesh)\n *        getColor: function( materialID )\n *             looks up a color (3-array) by material ID\n *             TODO: replace this with a lookup array?\n *        doAO: whether or not to bake ambient occlusion into vertex colors\n *        aoValues: array[3] of color multipliers for AO (least to most occluded)\n *        revAoVal: \"reverse ao\" - color multiplier for unoccluded exposed edges\n *\n *    Return object: array of mesh objects keyed by material ID\n *        arr[id] = {\n *          id:       material id for mesh\n *          vertices: ints, range 0 .. X/Y/Z\n *          indices:  ints\n *          normals:  ints,   -1 .. 1\n *          colors:   floats,  0 .. 1\n *          uvs:      floats,  0 .. X/Y/Z\n *        }\n */\n\nfunction GreedyMesher() {\n\n    // data representation constants\n    var constants = __webpack_require__(/*! ./constants */ \"./node_modules/noa-engine/src/lib/constants.js\")\n\n    var ID_MASK = constants.ID_MASK\n    // var VAR_MASK = constants.VAR_MASK // NYI\n    var SOLID_BIT = constants.SOLID_BIT\n    var OPAQUE_BIT = constants.OPAQUE_BIT\n    var OBJECT_BIT = constants.OBJECT_BIT\n\n\n    var maskCache = new Int16Array(16)\n    var aomaskCache = new Uint16Array(16)\n\n\n\n\n    this.mesh = function (arr, getMaterial, getColor, doAO, aoValues, revAoVal) {\n\n        // return object, holder for Submeshes\n        var subMeshes = {}\n\n        // precalc how to apply AO packing in first masking function\n        var skipReverseAO = (doAO && (revAoVal === aoValues[0]))\n        var aoPackFcn\n        if (doAO) aoPackFcn = (skipReverseAO) ? packAOMaskNoReverse : packAOMask\n\n\n        //Sweep over each axis, mapping axes to [d,u,v]\n        for (var d = 0; d < 3; ++d) {\n            var u = (d + 1) % 3\n            var v = (d + 2) % 3\n\n            // make transposed ndarray so index i is the axis we're sweeping\n            var arrT = arr.transpose(d, u, v).lo(1, 1, 1).hi(arr.shape[d] - 2, arr.shape[u] - 2, arr.shape[v] - 2)\n\n            // shorten len0 by 1 so faces at edges don't get drawn in both chunks\n            var len0 = arrT.shape[0] - 1\n            var len1 = arrT.shape[1]\n            var len2 = arrT.shape[2]\n\n            // create bigger mask arrays as needed\n            if (maskCache.length < len1 * len2) {\n                maskCache = new Int16Array(len1 * len2)\n                aomaskCache = new Uint16Array(len1 * len2)\n            }\n\n            // iterate along current major axis..\n            for (var i = 0; i <= len0; ++i) {\n\n                // fills mask and aomask arrays with values\n                constructMeshMasks(i, d, arrT, getMaterial, aoPackFcn)\n                profile_hook('built masks')\n\n                // parses the masks to do greedy meshing\n                constructMeshDataFromMasks(i, d, u, v, len1, len2,\n                    doAO, subMeshes, getColor, aoValues, revAoVal)\n\n                profile_hook('build submeshes')\n            }\n        }\n\n        // done, return array of submeshes\n        return subMeshes\n    }\n\n\n\n\n\n\n\n    //      Greedy meshing inner loop one\n    //\n    // iterating across ith 2d plane, with n being index into masks\n\n    function constructMeshMasks(i, d, arrT, getMaterial, aoPackFcn) {\n        var len = arrT.shape[1]\n        var mask = maskCache\n        var aomask = aomaskCache\n        // set up for quick array traversals\n        var n = 0\n        var data = arrT.data\n        var dbase = arrT.index(i - 1, 0, 0)\n        var istride = arrT.stride[0]\n        var jstride = arrT.stride[1]\n        var kstride = arrT.stride[2]\n\n        for (var k = 0; k < len; ++k) {\n            var d0 = dbase\n            dbase += kstride\n            for (var j = 0; j < len; j++, n++, d0 += jstride) {\n\n                // mask[n] will represent the face needed between i-1,j,k and i,j,k\n                // for now, assume we never have two faces in both directions\n\n                // IDs at i-1,j,k  and  i,j,k\n                var id0 = data[d0]\n                var id1 = data[d0 + istride]\n\n                var faceDir = getFaceDir(id0, id1)\n                if (faceDir) {\n                    // set regular mask value to material ID, sign indicating direction\n                    mask[n] = (faceDir > 0) ?\n                        getMaterial(id0 & ID_MASK, d * 2) :\n                        -getMaterial(id1 & ID_MASK, d * 2 + 1)\n\n                    // if doing AO, precalculate AO level for each face into second mask\n                    if (aoPackFcn) {\n                        // i values in direction face is/isn't pointing\n                        var ipos = (faceDir > 0) ? i : i - 1\n                        var ineg = (faceDir > 0) ? i - 1 : i\n\n                        // this got so big I rolled it into a function\n                        aomask[n] = aoPackFcn(arrT, ipos, ineg, j, k)\n                    }\n                } else {\n                    // unneeded, mesher zeroes out mask as it goes\n                    // mask[n] = 0\n                }\n\n            }\n        }\n    }\n\n\n\n    function getFaceDir(id0, id1) {\n        // no face if both blocks are opaque, or if ids match\n        if (id0 === id1) return 0\n        var op0 = id0 & OPAQUE_BIT\n        var op1 = id1 & OPAQUE_BIT\n        if (op0 && op1) return 0\n        // if either block is opaque draw a face for it\n        if (op0) return 1\n        if (op1) return -1\n        // if one block is air or an object block draw face for the other\n        if (id1 === 0 || (id1 & OBJECT_BIT)) return 1\n        if (id0 === 0 || (id0 & OBJECT_BIT)) return -1\n        // only remaining case is two different non-opaque non-air blocks that are adjacent\n        // really we should draw both faces here; draw neither for now\n        return 0\n    }\n\n\n\n\n\n\n\n    //      Greedy meshing inner loop two\n    //\n    // construct data for mesh using the masks\n\n    function constructMeshDataFromMasks(i, d, u, v, len1, len2,\n        doAO, submeshes, getColor, aoValues, revAoVal) {\n        var n = 0\n        var mask = maskCache\n        var aomask = aomaskCache\n\n        // some logic is broken into helper functions for AO and non-AO\n        // this fixes deopts in Chrome (for reasons unknown)\n        var maskCompareFcn = (doAO) ? maskCompare : maskCompare_noAO\n        var meshColorFcn = (doAO) ? pushMeshColors : pushMeshColors_noAO\n\n        for (var k = 0; k < len2; ++k) {\n            var w = 1\n            var h = 1\n            for (var j = 0; j < len1; j += w, n += w) {\n\n                var maskVal = mask[n] | 0\n                if (!maskVal) {\n                    w = 1\n                    continue\n                }\n                var ao = aomask[n] | 0\n\n                // Compute width and height of area with same mask/aomask values\n                for (w = 1; w < len1 - j; ++w) {\n                    if (!maskCompareFcn(n + w, mask, maskVal, aomask, ao)) break\n                }\n\n                OUTER:\n                    for (h = 1; h < len2 - k; ++h) {\n                        for (var m = 0; m < w; ++m) {\n                            var ix = n + m + h * len1\n                            if (!maskCompareFcn(ix, mask, maskVal, aomask, ao)) break OUTER\n                        }\n                    }\n\n                // for testing: doing the following will disable greediness\n                //w=h=1\n\n                // material and mesh for this face\n                var matID = Math.abs(maskVal)\n                if (!submeshes[matID]) submeshes[matID] = new Submesh(matID)\n                var mesh = submeshes[matID]\n                var colors = mesh.colors\n                var c = getColor(matID)\n\n                // colors are pushed in helper function - avoids deopts\n                // tridir is boolean for which way to split the quad into triangles\n\n                var triDir = meshColorFcn(colors, c, ao, aoValues, revAoVal)\n\n\n                //Add quad, vertices = x -> x+du -> x+du+dv -> x+dv\n                var x = [0, 0, 0]\n                x[d] = i\n                x[u] = j\n                x[v] = k\n                var du = [0, 0, 0]\n                var dv = [0, 0, 0]\n                du[u] = w\n                dv[v] = h\n\n                var pos = mesh.positions\n                pos.push(\n                    x[0], x[1], x[2],\n                    x[0] + du[0], x[1] + du[1], x[2] + du[2],\n                    x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2],\n                    x[0] + dv[0], x[1] + dv[1], x[2] + dv[2])\n\n\n                // add uv values, with the order and sign depending on \n                // axis and direction so as to avoid mirror-image textures\n                var dir = (maskVal > 0) ? 1 : -1\n\n                if (d === 2) {\n                    mesh.uvs.push(\n                        0, h,\n                        -dir * w, h,\n                        -dir * w, 0,\n                        0, 0)\n                } else {\n                    mesh.uvs.push(\n                        0, w,\n                        0, 0,\n                        dir * h, 0,\n                        dir * h, w)\n                }\n\n\n                // Add indexes, ordered clockwise for the facing direction;\n\n                var vs = pos.length / 3 - 4\n\n                if (maskVal < 0) {\n                    if (triDir) {\n                        mesh.indices.push(vs, vs + 1, vs + 2, vs, vs + 2, vs + 3)\n                    } else {\n                        mesh.indices.push(vs + 1, vs + 2, vs + 3, vs, vs + 1, vs + 3)\n                    }\n                } else {\n                    if (triDir) {\n                        mesh.indices.push(vs, vs + 2, vs + 1, vs, vs + 3, vs + 2)\n                    } else {\n                        mesh.indices.push(vs + 3, vs + 1, vs, vs + 3, vs + 2, vs + 1)\n                    }\n                }\n\n\n                // norms depend on which direction the mask was solid in..\n                var norm0 = d === 0 ? dir : 0\n                var norm1 = d === 1 ? dir : 0\n                var norm2 = d === 2 ? dir : 0\n\n                // same norm for all vertices\n                mesh.normals.push(\n                    norm0, norm1, norm2,\n                    norm0, norm1, norm2,\n                    norm0, norm1, norm2,\n                    norm0, norm1, norm2)\n\n\n                //Zero-out mask\n                for (var hx = 0; hx < h; ++hx) {\n                    for (var wx = 0; wx < w; ++wx) {\n                        mask[n + wx + hx * len1] = 0\n                    }\n                }\n\n            }\n        }\n    }\n\n\n\n    // Two helper functions with AO and non-AO implementations:\n\n    function maskCompare(index, mask, maskVal, aomask, aoVal) {\n        if (maskVal !== mask[index]) return false\n        if (aoVal !== aomask[index]) return false\n        return true\n    }\n\n    function maskCompare_noAO(index, mask, maskVal, aomask, aoVal) {\n        if (maskVal !== mask[index]) return false\n        return true\n    }\n\n    function pushMeshColors_noAO(colors, c, ao, aoValues, revAoVal) {\n        colors.push(c[0], c[1], c[2], 1)\n        colors.push(c[0], c[1], c[2], 1)\n        colors.push(c[0], c[1], c[2], 1)\n        colors.push(c[0], c[1], c[2], 1)\n        return true // triangle direction doesn't matter for non-AO\n    }\n\n    function pushMeshColors(colors, c, ao, aoValues, revAoVal) {\n        var ao00 = unpackAOMask(ao, 0, 0)\n        var ao10 = unpackAOMask(ao, 1, 0)\n        var ao11 = unpackAOMask(ao, 1, 1)\n        var ao01 = unpackAOMask(ao, 0, 1)\n        pushAOColor(colors, c, ao00, aoValues, revAoVal)\n        pushAOColor(colors, c, ao10, aoValues, revAoVal)\n        pushAOColor(colors, c, ao11, aoValues, revAoVal)\n        pushAOColor(colors, c, ao01, aoValues, revAoVal)\n\n        // this bit is pretty magical..\n        var triDir = true\n        if (ao00 === ao11) {\n            triDir = (ao01 === ao10) ? (ao01 == 2) : true\n        } else {\n            triDir = (ao01 === ao10) ? false : (ao00 + ao11 > ao01 + ao10)\n        }\n        return triDir\n    }\n\n\n\n\n\n    /* \n     *  packAOMask:\n     *\n     *    For a given face, find occlusion levels for each vertex, then\n     *    pack 4 such (2-bit) values into one Uint8 value\n     * \n     *  Occlusion levels:\n     *    1 is flat ground, 2 is partial occlusion, 3 is max (corners)\n     *    0 is \"reverse occlusion\" - an unoccluded exposed edge \n     *  Packing order var(bit offset):\n     *      a01(2)  -   a11(6)   ^  K\n     *        -     -            +> J\n     *      a00(0)  -   a10(4)\n     */\n\n    // when skipping reverse AO, uses this simpler version of the function:\n\n    function packAOMaskNoReverse(data, ipos, ineg, j, k) {\n        var a00 = 1\n        var a01 = 1\n        var a10 = 1\n        var a11 = 1\n        var solidBit = SOLID_BIT\n\n        // facing into a solid (non-opaque) block?\n        var facingSolid = (solidBit & data.get(ipos, j, k))\n\n        // inc occlusion of vertex next to obstructed side\n        if (data.get(ipos, j + 1, k) & solidBit) {++a10;++a11 }\n        if (data.get(ipos, j - 1, k) & solidBit) {++a00;++a01 }\n        if (data.get(ipos, j, k + 1) & solidBit) {++a01;++a11 }\n        if (data.get(ipos, j, k - 1) & solidBit) {++a00;++a10 }\n\n        // treat corners differently based when facing a solid block\n        if (facingSolid) {\n            // always 2, or 3 in corners\n            a11 = (a11 == 3 || data.get(ipos, j + 1, k + 1) & solidBit) ? 3 : 2\n            a01 = (a01 == 3 || data.get(ipos, j - 1, k + 1) & solidBit) ? 3 : 2\n            a10 = (a10 == 3 || data.get(ipos, j + 1, k - 1) & solidBit) ? 3 : 2\n            a00 = (a00 == 3 || data.get(ipos, j - 1, k - 1) & solidBit) ? 3 : 2\n        } else {\n            // treat corner as occlusion 3 only if not occluded already\n            if (a11 === 1 && (data.get(ipos, j + 1, k + 1) & solidBit)) { a11 = 2 }\n            if (a01 === 1 && (data.get(ipos, j - 1, k + 1) & solidBit)) { a01 = 2 }\n            if (a10 === 1 && (data.get(ipos, j + 1, k - 1) & solidBit)) { a10 = 2 }\n            if (a00 === 1 && (data.get(ipos, j - 1, k - 1) & solidBit)) { a00 = 2 }\n        }\n\n        return a11 << 6 | a10 << 4 | a01 << 2 | a00\n    }\n\n    // more complicated AO packing when doing reverse AO on corners\n\n    function packAOMask(data, ipos, ineg, j, k) {\n        var a00 = 1\n        var a01 = 1\n        var a10 = 1\n        var a11 = 1\n        var solidBit = SOLID_BIT\n\n        // facing into a solid (non-opaque) block?\n        var facingSolid = (solidBit & data.get(ipos, j, k))\n\n        // inc occlusion of vertex next to obstructed side\n        if (data.get(ipos, j + 1, k) & solidBit) {++a10;++a11 }\n        if (data.get(ipos, j - 1, k) & solidBit) {++a00;++a01 }\n        if (data.get(ipos, j, k + 1) & solidBit) {++a01;++a11 }\n        if (data.get(ipos, j, k - 1) & solidBit) {++a00;++a10 }\n\n        if (facingSolid) {\n            // always 2, or 3 in corners\n            a11 = (a11 == 3 || data.get(ipos, j + 1, k + 1) & solidBit) ? 3 : 2\n            a01 = (a01 == 3 || data.get(ipos, j - 1, k + 1) & solidBit) ? 3 : 2\n            a10 = (a10 == 3 || data.get(ipos, j + 1, k - 1) & solidBit) ? 3 : 2\n            a00 = (a00 == 3 || data.get(ipos, j - 1, k - 1) & solidBit) ? 3 : 2\n        } else {\n\n            // check each corner, and if not present do reverse AO\n            if (a11 === 1) {\n                if (data.get(ipos, j + 1, k + 1) & solidBit) {\n                    a11 = 2\n                } else if (!(data.get(ineg, j, k + 1) & solidBit) ||\n                    !(data.get(ineg, j + 1, k) & solidBit) ||\n                    !(data.get(ineg, j + 1, k + 1) & solidBit)) {\n                    a11 = 0\n                }\n            }\n\n            if (a10 === 1) {\n                if (data.get(ipos, j + 1, k - 1) & solidBit) {\n                    a10 = 2\n                } else if (!(data.get(ineg, j, k - 1) & solidBit) ||\n                    !(data.get(ineg, j + 1, k) & solidBit) ||\n                    !(data.get(ineg, j + 1, k - 1) & solidBit)) {\n                    a10 = 0\n                }\n            }\n\n            if (a01 === 1) {\n                if (data.get(ipos, j - 1, k + 1) & solidBit) {\n                    a01 = 2\n                } else if (!(data.get(ineg, j, k + 1) & solidBit) ||\n                    !(data.get(ineg, j - 1, k) & solidBit) ||\n                    !(data.get(ineg, j - 1, k + 1) & solidBit)) {\n                    a01 = 0\n                }\n            }\n\n            if (a00 === 1) {\n                if (data.get(ipos, j - 1, k - 1) & solidBit) {\n                    a00 = 2\n                } else if (!(data.get(ineg, j, k - 1) & solidBit) ||\n                    !(data.get(ineg, j - 1, k) & solidBit) ||\n                    !(data.get(ineg, j - 1, k - 1) & solidBit)) {\n                    a00 = 0\n                }\n            }\n        }\n\n        return a11 << 6 | a10 << 4 | a01 << 2 | a00\n    }\n\n\n\n    // unpack (2 bit) ao value from ao mask\n    // see above for details\n    function unpackAOMask(aomask, jpos, kpos) {\n        var offset = jpos ? (kpos ? 6 : 4) : (kpos ? 2 : 0)\n        return aomask >> offset & 3\n    }\n\n\n    // premultiply vertex colors by value depending on AO level\n    // then push them into color array\n    function pushAOColor(colors, baseCol, ao, aoVals, revAoVal) {\n        var mult = (ao === 0) ? revAoVal : aoVals[ao - 1]\n        colors.push(baseCol[0] * mult, baseCol[1] * mult, baseCol[2] * mult, 1)\n    }\n\n}\n\n\n\n\n\n\n\n\n\nvar profile_hook = (function () {\n    if (!PROFILE) return function () {}\n    var every = 50\n    var timer = new(__webpack_require__(/*! ./util */ \"./node_modules/noa-engine/src/lib/util.js\").Timer)(every, 'Terrain meshing')\n    return function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/terrainMesher.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/util.js":
/*!*************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/util.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = {\n    Timer: Timer,\n    removeUnorderedListItem: removeUnorderedListItem,\n}\n\n\n\n\n// helper to swap item to end and pop(), instead of splice()ing\nfunction removeUnorderedListItem(list, item) {\n    var i = list.indexOf(item)\n    if (i < 0) { return }\n    if (i === list.length - 1) {\n        list.pop()\n    } else {\n        list[i] = list.pop()\n    }\n}\n\n\n\n\n// simple thing for reporting time split up between several activities\nfunction Timer(_every, _title) {\n    var title = _title || ''\n    var every = _every || 1\n    var times = []\n    var names = []\n    var started = 0\n    var last = 0\n    var iter = 0\n    var total = 0\n    var clearNext = true\n\n    this.start = function () {\n        if (clearNext) {\n            times.length = names.length = 0\n            clearNext = false\n        }\n        started = last = performance.now()\n        iter++\n    }\n    this.add = function (name) {\n        var t = performance.now()\n        if (names.indexOf(name) < 0) names.push(name)\n        var i = names.indexOf(name)\n        if (!times[i]) times[i] = 0\n        times[i] += t - last\n        last = t\n    }\n    this.report = function () {\n        total += performance.now() - started\n        if (iter === every) {\n            var head = title + ' total ' + (total / every).toFixed(2) + 'ms (avg, ' + every + ' runs)    '\n            console.log(head, names.map(function (name, i) {\n                return name + ': ' + (times[i] / every).toFixed(2) + 'ms    '\n            }).join(''))\n            clearNext = true\n            iter = 0\n            total = 0\n        }\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/util.js?");

/***/ }),

/***/ "./node_modules/noa-engine/src/lib/world.js":
/*!**************************************************!*\
  !*** ./node_modules/noa-engine/src/lib/world.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ndHash = __webpack_require__(/*! ndarray-hash */ \"./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js\")\nvar EventEmitter = __webpack_require__(/*! events */ \"./node_modules/events/events.js\").EventEmitter\nvar Chunk = __webpack_require__(/*! ./chunk */ \"./node_modules/noa-engine/src/lib/chunk.js\")\n\n\nmodule.exports = function (noa, opts) {\n    return new World(noa, opts)\n}\n\n\nvar PROFILE = 0\nvar PROFILE_QUEUES = 0\n\n\nvar defaultOptions = {\n    chunkSize: 24,\n    chunkAddDistance: 3,\n    chunkRemoveDistance: 4\n}\n\n/**\n * Module for managing the world, and its chunks\n * @class noa.world\n * \n * Emits:\n *  * worldDataNeeded  (id, ndarray, x, y, z)\n *  * chunkAdded (chunk)\n *  * chunkChanged (chunk)\n *  * chunkBeingRemoved (id, ndarray, userData)\n */\n\nfunction World(noa, opts) {\n    this.noa = noa\n    opts = Object.assign({}, defaultOptions, opts)\n\n    this.userData = null\n    this.playerChunkLoaded = false\n    this.Chunk = Chunk\n\n    this.chunkSize = opts.chunkSize\n    this.chunkAddDistance = opts.chunkAddDistance\n    this.chunkRemoveDistance = opts.chunkRemoveDistance\n    if (this.chunkRemoveDistance < this.chunkAddDistance) {\n        this.chunkRemoveDistance = this.chunkAddDistance\n    }\n\n    // internals\n    this._chunkIDsToAdd = []\n    this._chunkIDsToRemove = []\n    this._chunkIDsInMemory = []\n    this._chunkIDsToCreate = []\n    this._chunkIDsToMesh = []\n    this._chunkIDsToMeshFirst = []\n    this._maxChunksPendingCreation = 20\n    this._maxChunksPendingMeshing = 20\n    this._maxProcessingPerTick = 9 // ms\n    this._maxProcessingPerRender = 5 // ms\n\n    // triggers a short visit to the meshing queue before renders\n    var self = this\n    noa.on('beforeRender', function () { beforeRender(self) })\n\n    // actual chunk storage - hash size hard coded for now\n    this._chunkHash = ndHash([1024, 1024, 1024])\n\n    // instantiate coord conversion functions based on the chunk size\n    // use bit twiddling if chunk size is a power of 2\n    var cs = this.chunkSize\n    if (cs & cs - 1 === 0) {\n        var shift = Math.log2(cs) | 0\n        var mask = (cs - 1) | 0\n        worldCoordToChunkCoord = coord => (coord >> shift) | 0\n        worldCoordToChunkIndex = coord => (coord & mask) | 0\n    } else {\n        worldCoordToChunkCoord = coord => Math.floor(coord / cs) | 0\n        worldCoordToChunkIndex = coord => (((coord % cs) + cs) % cs) | 0\n    }\n\n}\nWorld.prototype = Object.create(EventEmitter.prototype)\n\nvar worldCoordToChunkCoord\nvar worldCoordToChunkIndex\n\n\n\n\n/*\n *   PUBLIC API \n */\n\n\n\n/** @param x,y,z */\nWorld.prototype.getBlockID = function (x, y, z) {\n    var chunk = this._getChunkByCoords(x, y, z)\n    if (!chunk) return 0\n\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n    return chunk.get(ix, iy, iz)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockSolidity = function (x, y, z) {\n    var chunk = this._getChunkByCoords(x, y, z)\n    if (!chunk) return 0\n\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n    return !!chunk.getSolidityAt(ix, iy, iz)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockOpacity = function (x, y, z) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockOpacity(id)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockFluidity = function (x, y, z) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockFluidity(id)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockProperties = function (x, y, z) {\n    var id = this.getBlockID(x, y, z)\n    return this.noa.registry.getBlockProps(id)\n}\n\n/** @param x,y,z */\nWorld.prototype.getBlockObjectMesh = function (x, y, z) {\n    var chunk = this._getChunkByCoords(x, y, z)\n    if (!chunk) return 0\n\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n    return chunk.getObjectMeshAt(ix, iy, iz)\n}\n\n\n/** @param x,y,z */\nWorld.prototype.setBlockID = function (val, x, y, z) {\n    var i = worldCoordToChunkCoord(x)\n    var j = worldCoordToChunkCoord(y)\n    var k = worldCoordToChunkCoord(z)\n    var ix = worldCoordToChunkIndex(x)\n    var iy = worldCoordToChunkIndex(y)\n    var iz = worldCoordToChunkIndex(z)\n\n    // if update is on chunk border, update neighbor's padding data too\n    _updateChunkAndBorders(this, i, j, k, this.chunkSize, ix, iy, iz, val)\n}\n\n\n/** @param x,y,z */\nWorld.prototype.isBoxUnobstructed = function (box) {\n    var base = box.base\n    var max = box.max\n    for (var i = Math.floor(base[0]); i < max[0] + 1; i++) {\n        for (var j = Math.floor(base[1]); j < max[1] + 1; j++) {\n            for (var k = Math.floor(base[2]); k < max[2] + 1; k++) {\n                if (this.getBlockSolidity(i, j, k)) return false\n            }\n        }\n    }\n    return true\n}\n\n\n\n\n\nWorld.prototype.tick = function () {\n    profile_hook('start')\n\n    // check player position and needed/unneeded chunks\n    var pos = getPlayerChunkCoords(this)\n    var chunkID = getChunkID(pos[0], pos[1], pos[2])\n    if (chunkID != this._lastPlayerChunkID) {\n        this.emit('playerEnteredChunk', pos[0], pos[1], pos[2])\n        buildChunkAddQueue(this, pos[0], pos[1], pos[2])\n        buildChunkRemoveQueue(this, pos[0], pos[1], pos[2])\n    }\n    this._lastPlayerChunkID = chunkID\n    profile_hook('build queues')\n\n    // process (create or mesh) some chunks. If fast enough, do several\n    profile_queues(this, 'start')\n    var cutoff = performance.now() + this._maxProcessingPerTick\n    var done = false\n    while (!done && (performance.now() < cutoff)) {\n        var d1 = processMeshingQueues(this, false)\n        var d2 = processChunkQueues(this)\n        if (!d2) d2 = processChunkQueues(this)\n        done = d1 && d2\n    }\n    profile_queues(this, 'end')\n\n\n    // track whether the player's local chunk is loaded and ready or not\n    var pChunk = getChunk(this, pos[0], pos[1], pos[2])\n    var okay = !!(pChunk && pChunk.isGenerated && !pChunk.isInvalid)\n    this.playerChunkLoaded = okay\n\n    profile_hook('end')\n}\n\n\n\nfunction beforeRender(self) {\n    // on render, quickly process the high-priority meshing queue\n    // to help avoid flashes of background while neighboring chunks update\n    var cutoff = performance.now() + self._maxProcessingPerRender\n    var done = false\n    while (!done && (performance.now() < cutoff)) {\n        done = processMeshingQueues(self, true)\n    }\n}\n\n\n\n\n/** client should call this after creating a chunk's worth of data (as an ndarray)  \n * If userData is passed in it will be attached to the chunk\n * @param id\n * @param array\n * @param userData\n */\nWorld.prototype.setChunkData = function (id, array, userData) {\n    profile_queues(this, 'received')\n    var arr = parseChunkID(id)\n    var chunk = getChunk(this, arr[0], arr[1], arr[2])\n    // ignore if chunk was invalidated while being prepared\n    if (!chunk || chunk.isInvalid) return\n    chunk.array = array\n    if (userData) chunk.userData = userData\n    chunk.initData()\n    enqueueID(id, this._chunkIDsInMemory)\n    unenqueueID(id, this._chunkIDsToCreate)\n\n    // chunk can now be meshed...\n    this.noa.rendering.prepareChunkForRendering(chunk)\n    enqueueID(id, this._chunkIDsToMesh)\n    this.emit('chunkAdded', chunk)\n}\n\n\n\n\n/*\n * Calling this causes all world chunks to get unloaded and recreated \n * (after receiving new world data from the client). This is useful when\n * you're teleporting the player to a new world, e.g.\n */\nWorld.prototype.invalidateAllChunks = function () {\n    var toInval = this._chunkIDsInMemory.concat(this._chunkIDsToCreate)\n    for (var id of toInval) {\n        var loc = parseChunkID(id)\n        var chunk = getChunk(this, loc[0], loc[1], loc[2])\n        chunk.isInvalid = true\n    }\n    // this causes chunk queues to get rebuilt next tick\n    this._lastPlayerChunkID = ''\n}\n\n\n\n// debugging\nWorld.prototype.report = function () {\n    console.log('World report - playerChunkLoaded: ', this.playerChunkLoaded)\n    _report(this, '  to add     ', this._chunkIDsToAdd)\n    _report(this, '  to remove: ', this._chunkIDsToRemove)\n    _report(this, '  in memory: ', this._chunkIDsInMemory, true)\n    _report(this, '  creating:  ', this._chunkIDsToCreate)\n    _report(this, '  meshing:   ', this._chunkIDsToMesh.concat(this._chunkIDsToMeshFirst))\n}\n\nfunction _report(world, name, arr, ext) {\n    var ct = 0,\n        full = 0,\n        empty = 0\n    for (var id of arr) {\n        if (id.size) {\n            if (id.isInvalid) ct++\n            continue\n        }\n        var loc = parseChunkID(id)\n        var chunk = getChunk(world, loc[0], loc[1], loc[2])\n        if (chunk.isInvalid) ct++\n        if (chunk.isFull) full++\n        if (chunk.isEmpty) empty++\n    }\n    var len = (arr.length + '        ').substr(0, 6)\n    var es = (ext) ? [', ', full, ' full, ', empty, ' empty'].join('') : ''\n    console.log(name, len, ct, 'invalid' + es)\n}\n\n\n\n\n/*\n *\n *\n *            INTERNALS\n *\n *\n */\n\n\n// canonical string ID handling for the i,j,k-th chunk\nfunction getChunkID(i, j, k) {\n    return i + '|' + j + '|' + k\n}\n\nfunction parseChunkID(id) {\n    var arr = id.split('|')\n    return [parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2])]\n}\n\n// canonical functions to store/retrieve a chunk held in memory\nfunction getChunk(world, i, j, k) {\n    var mi = (i | 0) & 1023\n    var mj = (j | 0) & 1023\n    var mk = (k | 0) & 1023\n    return world._chunkHash.get(mi, mj, mk)\n}\n\nfunction setChunk(world, i, j, k, value) {\n    var mi = (i | 0) & 1023\n    var mj = (j | 0) & 1023\n    var mk = (k | 0) & 1023\n    world._chunkHash.set(mi, mj, mk, value)\n}\n\n\n\nfunction getPlayerChunkCoords(world) {\n    var pos = world.noa.getPlayerPosition()\n    var i = worldCoordToChunkCoord(pos[0])\n    var j = worldCoordToChunkCoord(pos[1])\n    var k = worldCoordToChunkCoord(pos[2])\n    return [i, j, k]\n}\n\n\n// for internal use\nWorld.prototype._getChunkByCoords = function (x, y, z) {\n    var i = worldCoordToChunkCoord(x)\n    var j = worldCoordToChunkCoord(y)\n    var k = worldCoordToChunkCoord(z)\n    return getChunk(this, i, j, k)\n}\n\n\n\n\n// run through chunk tracking queues looking for work to do next\nfunction processChunkQueues(self) {\n    var done = true\n    // both queues are sorted by ascending distance\n    if (self._chunkIDsToRemove.length) {\n        var remove = parseChunkID(self._chunkIDsToRemove.pop())\n        removeChunk(self, remove[0], remove[1], remove[2])\n        profile_queues(self, 'removed')\n        profile_hook('removed')\n        done = false\n    }\n    if (self._chunkIDsToCreate.length >= self._maxChunksPendingCreation) return done\n    // if (self._chunkIDsToMesh.length >= self._maxChunksPendingMeshing) return done\n    if (self._chunkIDsToAdd.length) {\n        var id = self._chunkIDsToAdd.shift()\n        requestNewChunk(self, id)\n        profile_hook('requested')\n        profile_queues(self, 'requested')\n        done = false\n    }\n    return done\n}\n\n\n// similar to above but for chunks waiting to be meshed\nfunction processMeshingQueues(self, firstOnly) {\n    var id\n    if (self._chunkIDsToMeshFirst.length) {\n        id = self._chunkIDsToMeshFirst.pop()\n    } else if (firstOnly) {\n        return true\n    } else if (self._chunkIDsToMesh.length) {\n        id = self._chunkIDsToMesh.pop()\n    } else return true\n\n    var arr = parseChunkID(id)\n    var chunk = getChunk(self, arr[0], arr[1], arr[2])\n    if (chunk.isInvalid) return\n    if (!chunk.isGenerated) {\n        // client code triggered a remesh too early, requeue it\n        self._chunkIDsToMesh.unshift(id)\n        return\n    }\n    chunk.updateMeshes()\n\n    profile_queues(self, 'meshed')\n    profile_hook('meshed')\n    return false\n}\n\n\n\n\n\n\n\n\n\n// make a new chunk and emit an event for it to be populated with world data\nfunction requestNewChunk(world, id) {\n    var pos = parseChunkID(id)\n    var i = pos[0]\n    var j = pos[1]\n    var k = pos[2]\n    var size = world.chunkSize\n    var chunk = new Chunk(world.noa, id, i, j, k, size)\n    setChunk(world, i, j, k, chunk)\n    var x = i * size - 1\n    var y = j * size - 1\n    var z = k * size - 1\n    enqueueID(id, world._chunkIDsToCreate)\n    world.emit('worldDataNeeded', id, chunk.array, x, y, z)\n}\n\n\n\n\n// remove a chunk that wound up in the remove queue\nfunction removeChunk(world, i, j, k) {\n    var chunk = getChunk(world, i, j, k)\n    world.emit('chunkBeingRemoved', chunk.id, chunk.array, chunk.userData)\n    world.noa.rendering.disposeChunkForRendering(chunk)\n    chunk.dispose()\n    setChunk(world, i, j, k, 0)\n    unenqueueID(chunk.id, world._chunkIDsInMemory)\n    unenqueueID(chunk.id, world._chunkIDsToMesh)\n    unenqueueID(chunk.id, world._chunkIDsToMeshFirst)\n    // when removing a chunk because it was invalid, arrange for chunk queues to get rebuilt\n    if (chunk.isInvalid) world._lastPlayerChunkID = ''\n}\n\n\n\n\n\n// for a given chunk (i/j/k) and local location (x/y/z), \n// update all chunks that need it (including border chunks with the \n// changed block in their 1-block padding)\n\nfunction _updateChunkAndBorders(world, i, j, k, size, x, y, z, val) {\n    var ilocs = [0]\n    var jlocs = [0]\n    var klocs = [0]\n    if (x === 0) { ilocs.push(-1) } else if (x === size - 1) { ilocs.push(1) }\n    if (y === 0) { jlocs.push(-1) } else if (y === size - 1) { jlocs.push(1) }\n    if (z === 0) { klocs.push(-1) } else if (z === size - 1) { klocs.push(1) }\n\n    for (var di of ilocs) {\n        var lx = [size, x, -1][di + 1]\n        for (var dj of jlocs) {\n            var ly = [size, y, -1][dj + 1]\n            for (var dk of klocs) {\n                var lz = [size, z, -1][dk + 1]\n                _modifyBlockData(world,\n                    i + di, j + dj, k + dk,\n                    lx, ly, lz, val)\n            }\n        }\n    }\n}\n\n\n\n// internal function to modify a chunk's block\n\nfunction _modifyBlockData(world, i, j, k, x, y, z, val) {\n    var chunk = getChunk(world, i, j, k)\n    if (!chunk) return\n    chunk.set(x, y, z, val)\n    enqueueID(chunk.id, world._chunkIDsToMeshFirst)\n    world.emit('chunkChanged', chunk)\n}\n\n\n\n\n// rebuild queue of chunks to be added around (ci,cj,ck)\nfunction buildChunkAddQueue(world, ci, cj, ck) {\n    var add = Math.ceil(world.chunkAddDistance)\n    var pending = world._chunkIDsToCreate\n    var queue = []\n    var distArr = []\n\n    var addDistSq = world.chunkAddDistance * world.chunkAddDistance\n    for (var i = ci - add; i <= ci + add; ++i) {\n        for (var j = cj - add; j <= cj + add; ++j) {\n            for (var k = ck - add; k <= ck + add; ++k) {\n                var di = i - ci\n                var dj = j - cj\n                var dk = k - ck\n                var distSq = di * di + dj * dj + dk * dk\n                if (distSq > addDistSq) continue\n\n                if (getChunk(world, i, j, k)) continue\n                var id = getChunkID(i, j, k)\n                if (pending.indexOf(id) > -1) continue\n                queue.push(id)\n                distArr.push(distSq)\n            }\n        }\n    }\n    world._chunkIDsToAdd = sortByReferenceArray(queue, distArr)\n}\n\n\n// rebuild queue of chunks to be removed from around (ci,cj,ck)\nfunction buildChunkRemoveQueue(world, ci, cj, ck) {\n    var remDistSq = world.chunkRemoveDistance * world.chunkRemoveDistance\n    var list = world._chunkIDsInMemory\n    var queue = []\n    var distArr = []\n\n    for (var i = 0; i < list.length; i++) {\n        var id = list[i]\n        var loc = parseChunkID(id)\n        var di = loc[0] - ci\n        var dj = loc[1] - cj\n        var dk = loc[2] - ck\n        var distSq = di * di + dj * dj + dk * dk\n        if (distSq < remDistSq) {\n            var chunk = getChunk(world, loc[0], loc[1], loc[2])\n            if (!chunk.isInvalid) continue\n            distSq *= -1 // rig sort so that invalidated chunks get removed first\n        }\n        queue.push(id)\n        distArr.push(distSq)\n    }\n    world._chunkIDsToRemove = sortByReferenceArray(queue, distArr)\n}\n\n\n\n// sorts [A, B, C] and [3, 1, 2] into [B, C, A]\nfunction sortByReferenceArray(data, ref) {\n    var ind = Object.keys(ref)\n    ind.sort((i, j) => ref[i] - ref[j])\n    return ind.map(i => data[i])\n}\n\n\n\n\n\n// uniquely enqueue a string id into an array of them\nfunction enqueueID(id, queue) {\n    var i = queue.indexOf(id)\n    if (i >= 0) return\n    queue.push(id)\n}\n\n// remove string id from queue if it exists\nfunction unenqueueID(id, queue) {\n    var i = queue.indexOf(id)\n    if (i >= 0) queue.splice(i, 1)\n}\n\n\n\n\n\nvar profile_queues = function (w, s) {}\nif (PROFILE_QUEUES)(function () {\n    var every = 100\n    var iter = 0\n    var t, nrem, nreq, totalrec, nmesh\n    var reqcts, remcts, meshcts\n    var qadd, qrem, qmem, qgen, qmesh\n    profile_queues = function (world, state) {\n        if (state === 'start') {\n            if (iter === 0) {\n                t = performance.now()\n                qadd = qrem = qmem = qgen = qmesh = 0\n                totalrec = 0\n                remcts = []\n                reqcts = []\n                meshcts = []\n            }\n            iter++\n            nrem = nreq = nmesh = 0\n        } else if (state === 'removed') {\n            nrem++\n        } else if (state === 'received') {\n            totalrec++\n        } else if (state === 'requested') {\n            nreq++\n        } else if (state === 'meshed') {\n            nmesh++\n        } else if (state === 'end') {\n            // counts for frames that were fully worked\n            if (world._chunkIDsToAdd.length) reqcts.push(nreq)\n            if (world._chunkIDsToRemove.length) remcts.push(nrem)\n            if (world._chunkIDsToMesh.length + world._chunkIDsToMeshFirst.length) meshcts.push(nmesh)\n            // avg queue sizes\n            qadd += world._chunkIDsToAdd.length\n            qrem += world._chunkIDsToRemove.length\n            qmem += world._chunkIDsInMemory.length\n            qgen += world._chunkIDsToCreate.length\n            qmesh += world._chunkIDsToMesh.length + world._chunkIDsToMeshFirst.length\n            // on end\n            if (iter === every) {\n                var dt = (performance.now() - t) / 1000\n                console.log('world chunk queues:',\n                    'made', rnd(totalrec / dt), 'cps',\n                    '- avg queuelen: ',\n                    'add', qadd / every,\n                    'rem', qrem / every,\n                    'mem', qmem / every,\n                    'gen', qgen / every,\n                    'mesh', qmesh / every,\n                    '- work/frame: ',\n                    'req', rnd(reqcts.reduce(sum, 0) / reqcts.length),\n                    'rem', rnd(remcts.reduce(sum, 0) / remcts.length),\n                    'mesh', rnd(meshcts.reduce(sum, 0) / meshcts.length)\n                )\n                iter = 0\n            }\n        }\n    }\n    var sum = function (num, prev) { return num + prev }\n    var rnd = function (n) { return Math.round(n * 10) / 10 }\n})()\n\n\nvar profile_hook = function (s) {}\nif (PROFILE)(function () {\n    var every = 200\n    var timer = new(__webpack_require__(/*! ./util */ \"./node_modules/noa-engine/src/lib/util.js\").Timer)(every, 'world ticks')\n    profile_hook = function (state) {\n        if (state === 'start') timer.start()\n        else if (state === 'end') timer.report()\n        else timer.add(state)\n    }\n})()\n\n\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/world.js?");

/***/ }),

/***/ "./node_modules/object-keys/implementation.js":
/*!****************************************************!*\
  !*** ./node_modules/object-keys/implementation.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar keysShim;\nif (!Object.keys) {\n\t// modified from https://github.com/es-shims/es5-shim\n\tvar has = Object.prototype.hasOwnProperty;\n\tvar toStr = Object.prototype.toString;\n\tvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\"); // eslint-disable-line global-require\n\tvar isEnumerable = Object.prototype.propertyIsEnumerable;\n\tvar hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');\n\tvar hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');\n\tvar dontEnums = [\n\t\t'toString',\n\t\t'toLocaleString',\n\t\t'valueOf',\n\t\t'hasOwnProperty',\n\t\t'isPrototypeOf',\n\t\t'propertyIsEnumerable',\n\t\t'constructor'\n\t];\n\tvar equalsConstructorPrototype = function (o) {\n\t\tvar ctor = o.constructor;\n\t\treturn ctor && ctor.prototype === o;\n\t};\n\tvar excludedKeys = {\n\t\t$applicationCache: true,\n\t\t$console: true,\n\t\t$external: true,\n\t\t$frame: true,\n\t\t$frameElement: true,\n\t\t$frames: true,\n\t\t$innerHeight: true,\n\t\t$innerWidth: true,\n\t\t$onmozfullscreenchange: true,\n\t\t$onmozfullscreenerror: true,\n\t\t$outerHeight: true,\n\t\t$outerWidth: true,\n\t\t$pageXOffset: true,\n\t\t$pageYOffset: true,\n\t\t$parent: true,\n\t\t$scrollLeft: true,\n\t\t$scrollTop: true,\n\t\t$scrollX: true,\n\t\t$scrollY: true,\n\t\t$self: true,\n\t\t$webkitIndexedDB: true,\n\t\t$webkitStorageInfo: true,\n\t\t$window: true\n\t};\n\tvar hasAutomationEqualityBug = (function () {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined') { return false; }\n\t\tfor (var k in window) {\n\t\t\ttry {\n\t\t\t\tif (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tequalsConstructorPrototype(window[k]);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}());\n\tvar equalsConstructorPrototypeIfNotBuggy = function (o) {\n\t\t/* global window */\n\t\tif (typeof window === 'undefined' || !hasAutomationEqualityBug) {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t}\n\t\ttry {\n\t\t\treturn equalsConstructorPrototype(o);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t};\n\n\tkeysShim = function keys(object) {\n\t\tvar isObject = object !== null && typeof object === 'object';\n\t\tvar isFunction = toStr.call(object) === '[object Function]';\n\t\tvar isArguments = isArgs(object);\n\t\tvar isString = isObject && toStr.call(object) === '[object String]';\n\t\tvar theKeys = [];\n\n\t\tif (!isObject && !isFunction && !isArguments) {\n\t\t\tthrow new TypeError('Object.keys called on a non-object');\n\t\t}\n\n\t\tvar skipProto = hasProtoEnumBug && isFunction;\n\t\tif (isString && object.length > 0 && !has.call(object, 0)) {\n\t\t\tfor (var i = 0; i < object.length; ++i) {\n\t\t\t\ttheKeys.push(String(i));\n\t\t\t}\n\t\t}\n\n\t\tif (isArguments && object.length > 0) {\n\t\t\tfor (var j = 0; j < object.length; ++j) {\n\t\t\t\ttheKeys.push(String(j));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (var name in object) {\n\t\t\t\tif (!(skipProto && name === 'prototype') && has.call(object, name)) {\n\t\t\t\t\ttheKeys.push(String(name));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (hasDontEnumBug) {\n\t\t\tvar skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);\n\n\t\t\tfor (var k = 0; k < dontEnums.length; ++k) {\n\t\t\t\tif (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {\n\t\t\t\t\ttheKeys.push(dontEnums[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn theKeys;\n\t};\n}\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack:///./node_modules/object-keys/implementation.js?");

/***/ }),

/***/ "./node_modules/object-keys/index.js":
/*!*******************************************!*\
  !*** ./node_modules/object-keys/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar slice = Array.prototype.slice;\nvar isArgs = __webpack_require__(/*! ./isArguments */ \"./node_modules/object-keys/isArguments.js\");\n\nvar origKeys = Object.keys;\nvar keysShim = origKeys ? function keys(o) { return origKeys(o); } : __webpack_require__(/*! ./implementation */ \"./node_modules/object-keys/implementation.js\");\n\nvar originalKeys = Object.keys;\n\nkeysShim.shim = function shimObjectKeys() {\n\tif (Object.keys) {\n\t\tvar keysWorksWithArguments = (function () {\n\t\t\t// Safari 5.0 bug\n\t\t\tvar args = Object.keys(arguments);\n\t\t\treturn args && args.length === arguments.length;\n\t\t}(1, 2));\n\t\tif (!keysWorksWithArguments) {\n\t\t\tObject.keys = function keys(object) { // eslint-disable-line func-name-matching\n\t\t\t\tif (isArgs(object)) {\n\t\t\t\t\treturn originalKeys(slice.call(object));\n\t\t\t\t}\n\t\t\t\treturn originalKeys(object);\n\t\t\t};\n\t\t}\n\t} else {\n\t\tObject.keys = keysShim;\n\t}\n\treturn Object.keys || keysShim;\n};\n\nmodule.exports = keysShim;\n\n\n//# sourceURL=webpack:///./node_modules/object-keys/index.js?");

/***/ }),

/***/ "./node_modules/object-keys/isArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/object-keys/isArguments.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar toStr = Object.prototype.toString;\n\nmodule.exports = function isArguments(value) {\n\tvar str = toStr.call(value);\n\tvar isArgs = str === '[object Arguments]';\n\tif (!isArgs) {\n\t\tisArgs = str !== '[object Array]' &&\n\t\t\tvalue !== null &&\n\t\t\ttypeof value === 'object' &&\n\t\t\ttypeof value.length === 'number' &&\n\t\t\tvalue.length >= 0 &&\n\t\t\ttoStr.call(value.callee) === '[object Function]';\n\t}\n\treturn isArgs;\n};\n\n\n//# sourceURL=webpack:///./node_modules/object-keys/isArguments.js?");

/***/ }),

/***/ "./node_modules/parse-headers/parse-headers.js":
/*!*****************************************************!*\
  !*** ./node_modules/parse-headers/parse-headers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var trim = __webpack_require__(/*! string.prototype.trim */ \"./node_modules/string.prototype.trim/index.js\")\n  , forEach = __webpack_require__(/*! for-each */ \"./node_modules/for-each/index.js\")\n  , isArray = function(arg) {\n      return Object.prototype.toString.call(arg) === '[object Array]';\n    }\n\nmodule.exports = function (headers) {\n  if (!headers)\n    return {}\n\n  var result = {}\n\n  forEach(\n      trim(headers).split('\\n')\n    , function (row) {\n        var index = row.indexOf(':')\n          , key = trim(row.slice(0, index)).toLowerCase()\n          , value = trim(row.slice(index + 1))\n\n        if (typeof(result[key]) === 'undefined') {\n          result[key] = value\n        } else if (isArray(result[key])) {\n          result[key].push(value)\n        } else {\n          result[key] = [ result[key], value ]\n        }\n      }\n  )\n\n  return result\n}\n\n\n//# sourceURL=webpack:///./node_modules/parse-headers/parse-headers.js?");

/***/ }),

/***/ "./node_modules/pleasejs/dist/Please.js":
/*!**********************************************!*\
  !*** ./node_modules/pleasejs/dist/Please.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!Please JS v0.4.2, Jordan Checkman 2014, Checkman.io, MIT License, Have fun.*/\n!function(e,r,a){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (a),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):undefined}(\"Please\",this,function(){\"use strict\";function e(){function e(e,r,a){var o=Math.random;return a instanceof l&&(o=a.random),Math.floor(o()*(r-e+1))+e}function r(e,r,a){var o=Math.random;return a instanceof l&&(o=a.random),o()*(r-e)+e}function a(e,r,a){return Math.max(r,Math.min(e,a))}function o(e,r){var a;switch(e){case\"hex\":for(a=0;a<r.length;a++)r[a]=F.HSV_to_HEX(r[a]);break;case\"rgb\":for(a=0;a<r.length;a++)r[a]=F.HSV_to_RGB(r[a]);break;case\"rgb-string\":for(a=0;a<r.length;a++){var o=F.HSV_to_RGB(r[a]);r[a]=\"rgb(\"+o.r+\",\"+o.g+\",\"+o.b+\")\"}break;case\"hsv\":break;default:console.error(\"Format not recognized.\")}return r}function n(e){var r=F.HSV_to_RGB(e),a=(299*r.r+587*r.g+114*r.b)/1e3;return a>=128?\"dark\":\"light\"}function t(e){var r={};for(var a in e)e.hasOwnProperty(a)&&(r[a]=e[a]);return r}function l(e){function r(){o=(o+1)%256,n=(n+a[o])%256;var e=a[o];return a[o]=a[n],a[n]=e,a[(a[o]+a[n])%256]}for(var a=[],o=0,n=0,t=0;256>t;t++)a[t]=t;for(var l=0,F=0;256>l;l++){F=(F+a[l]+e.charCodeAt(l%e.length))%256;var s=a[l];a[l]=a[F],a[F]=s}this.random=function(){for(var e=0,a=0,o=1;8>e;e++)a+=r()*o,o*=256;return a/0x10000000000000000}}var F={},s={aliceblue:\"F0F8FF\",antiquewhite:\"FAEBD7\",aqua:\"00FFFF\",aquamarine:\"7FFFD4\",azure:\"F0FFFF\",beige:\"F5F5DC\",bisque:\"FFE4C4\",black:\"000000\",blanchedalmond:\"FFEBCD\",blue:\"0000FF\",blueviolet:\"8A2BE2\",brown:\"A52A2A\",burlywood:\"DEB887\",cadetblue:\"5F9EA0\",chartreuse:\"7FFF00\",chocolate:\"D2691E\",coral:\"FF7F50\",cornflowerblue:\"6495ED\",cornsilk:\"FFF8DC\",crimson:\"DC143C\",cyan:\"00FFFF\",darkblue:\"00008B\",darkcyan:\"008B8B\",darkgoldenrod:\"B8860B\",darkgray:\"A9A9A9\",darkgrey:\"A9A9A9\",darkgreen:\"006400\",darkkhaki:\"BDB76B\",darkmagenta:\"8B008B\",darkolivegreen:\"556B2F\",darkorange:\"FF8C00\",darkorchid:\"9932CC\",darkred:\"8B0000\",darksalmon:\"E9967A\",darkseagreen:\"8FBC8F\",darkslateblue:\"483D8B\",darkslategray:\"2F4F4F\",darkslategrey:\"2F4F4F\",darkturquoise:\"00CED1\",darkviolet:\"9400D3\",deeppink:\"FF1493\",deepskyblue:\"00BFFF\",dimgray:\"696969\",dimgrey:\"696969\",dodgerblue:\"1E90FF\",firebrick:\"B22222\",floralwhite:\"FFFAF0\",forestgreen:\"228B22\",fuchsia:\"FF00FF\",gainsboro:\"DCDCDC\",ghostwhite:\"F8F8FF\",gold:\"FFD700\",goldenrod:\"DAA520\",gray:\"808080\",grey:\"808080\",green:\"008000\",greenyellow:\"ADFF2F\",honeydew:\"F0FFF0\",hotpink:\"FF69B4\",indianred:\"CD5C5C\",indigo:\"4B0082\",ivory:\"FFFFF0\",khaki:\"F0E68C\",lavender:\"E6E6FA\",lavenderblush:\"FFF0F5\",lawngreen:\"7CFC00\",lemonchiffon:\"FFFACD\",lightblue:\"ADD8E6\",lightcoral:\"F08080\",lightcyan:\"E0FFFF\",lightgoldenrodyellow:\"FAFAD2\",lightgray:\"D3D3D3\",lightgrey:\"D3D3D3\",lightgreen:\"90EE90\",lightpink:\"FFB6C1\",lightsalmon:\"FFA07A\",lightseagreen:\"20B2AA\",lightskyblue:\"87CEFA\",lightslategray:\"778899\",lightslategrey:\"778899\",lightsteelblue:\"B0C4DE\",lightyellow:\"FFFFE0\",lime:\"00FF00\",limegreen:\"32CD32\",linen:\"FAF0E6\",magenta:\"FF00FF\",maroon:\"800000\",mediumaquamarine:\"66CDAA\",mediumblue:\"0000CD\",mediumorchid:\"BA55D3\",mediumpurple:\"9370D8\",mediumseagreen:\"3CB371\",mediumslateblue:\"7B68EE\",mediumspringgreen:\"00FA9A\",mediumturquoise:\"48D1CC\",mediumvioletred:\"C71585\",midnightblue:\"191970\",mintcream:\"F5FFFA\",mistyrose:\"FFE4E1\",moccasin:\"FFE4B5\",navajowhite:\"FFDEAD\",navy:\"000080\",oldlace:\"FDF5E6\",olive:\"808000\",olivedrab:\"6B8E23\",orange:\"FFA500\",orangered:\"FF4500\",orchid:\"DA70D6\",palegoldenrod:\"EEE8AA\",palegreen:\"98FB98\",paleturquoise:\"AFEEEE\",palevioletred:\"D87093\",papayawhip:\"FFEFD5\",peachpuff:\"FFDAB9\",peru:\"CD853F\",pink:\"FFC0CB\",plum:\"DDA0DD\",powderblue:\"B0E0E6\",purple:\"800080\",rebeccapurple:\"663399\",red:\"FF0000\",rosybrown:\"BC8F8F\",royalblue:\"4169E1\",saddlebrown:\"8B4513\",salmon:\"FA8072\",sandybrown:\"F4A460\",seagreen:\"2E8B57\",seashell:\"FFF5EE\",sienna:\"A0522D\",silver:\"C0C0C0\",skyblue:\"87CEEB\",slateblue:\"6A5ACD\",slategray:\"708090\",slategrey:\"708090\",snow:\"FFFAFA\",springgreen:\"00FF7F\",steelblue:\"4682B4\",tan:\"D2B48C\",teal:\"008080\",thistle:\"D8BFD8\",tomato:\"FF6347\",turquoise:\"40E0D0\",violet:\"EE82EE\",wheat:\"F5DEB3\",white:\"FFFFFF\",whitesmoke:\"F5F5F5\",yellow:\"FFFF00\",yellowgreen:\"9ACD32\"},i=.618033988749895,u={hue:null,saturation:null,value:null,base_color:\"\",greyscale:!1,grayscale:!1,golden:!0,full_random:!1,colors_returned:1,format:\"hex\",seed:null},c={scheme_type:\"analogous\",format:\"hex\"},h={golden:!1,format:\"hex\"};return F.NAME_to_HEX=function(e){return e=e.toLowerCase(),e in s?s[e]:(console.error(\"Color name not recognized.\"),void 0)},F.NAME_to_RGB=function(e){return F.HEX_to_RGB(F.NAME_to_HEX(e))},F.NAME_to_HSV=function(e){return F.HEX_to_HSV(F.NAME_to_HEX(e))},F.HEX_to_RGB=function(e){var r=/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;e=e.replace(r,function(e,r,a,o){return r+r+a+a+o+o});var a=/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(e);return a?{r:parseInt(a[1],16),g:parseInt(a[2],16),b:parseInt(a[3],16)}:null},F.RGB_to_HEX=function(e){return\"#\"+((1<<24)+(e.r<<16)+(e.g<<8)+e.b).toString(16).slice(1)},F.HSV_to_RGB=function(e){var r,a,o,n,t,l,F,s,i=e.h,u=e.s,c=e.v;if(0===u)return{r:c,g:c,b:c};switch(i/=60,n=Math.floor(i),t=i-n,l=c*(1-u),F=c*(1-u*t),s=c*(1-u*(1-t)),n){case 0:r=c,a=s,o=l;break;case 1:r=F,a=c,o=l;break;case 2:r=l,a=c,o=s;break;case 3:r=l,a=F,o=c;break;case 4:r=s,a=l,o=c;break;case 5:r=c,a=l,o=F}return{r:Math.floor(255*r),g:Math.floor(255*a),b:Math.floor(255*o)}},F.RGB_to_HSV=function(e){var r=e.r/255,a=e.g/255,o=e.b/255,n=0,t=0,l=0,F=Math.min(r,Math.min(a,o)),s=Math.max(r,Math.max(a,o));if(F===s)return l=F,{h:0,s:0,v:l};var i=r===F?a-o:o===F?r-a:o-r,u=r===F?3:o===F?1:5;return n=60*(u-i/(s-F)),t=(s-F)/s,l=s,{h:n,s:t,v:l}},F.HSV_to_HEX=function(e){return F.RGB_to_HEX(F.HSV_to_RGB(e))},F.HEX_to_HSV=function(e){return F.RGB_to_HSV(F.HEX_to_RGB(e))},F.make_scheme=function(e,r){function n(e){return{h:e.h,s:e.s,v:e.v}}var l,F,s,i,u,h=t(c);if(null!==r)for(var d in r)r.hasOwnProperty(d)&&(h[d]=r[d]);var g=[e];switch(h.scheme_type.toLowerCase()){case\"monochromatic\":case\"mono\":for(u=1;2>=u;u++)l=n(e),s=l.s+.1*u,s=a(s,0,1),i=l.v+.1*u,i=a(i,0,1),l.s=s,l.v=i,g.push(l);for(u=1;2>=u;u++)l=n(e),s=l.s-.1*u,s=a(s,0,1),i=l.v-.1*u,i=a(i,0,1),l.s=s,l.v=i,g.push(l);break;case\"complementary\":case\"complement\":case\"comp\":l=n(e),l.h=(l.h+180)%360,g.push(l);break;case\"split-complementary\":case\"split-complement\":case\"split\":l=n(e),l.h=(l.h+165)%360,g.push(l),l=n(e),l.h=Math.abs((l.h-165)%360),g.push(l);break;case\"double-complementary\":case\"double-complement\":case\"double\":l=n(e),l.h=(l.h+180)%360,g.push(l),l.h=(l.h+30)%360,F=n(l),g.push(l),l.h=(l.h+180)%360,g.push(F);break;case\"analogous\":case\"ana\":for(u=1;5>=u;u++)l=n(e),l.h=(l.h+20*u)%360,g.push(l);break;case\"triadic\":case\"triad\":case\"tri\":for(u=1;3>u;u++)l=n(e),l.h=(l.h+120*u)%360,g.push(l);break;default:console.error(\"Color scheme not recognized.\")}return o(h.format.toLowerCase(),g),g},F.make_color=function(n){var s=[],c=t(u),h=null;if(null!==n)for(var d in n)n.hasOwnProperty(d)&&(c[d]=n[d]);var g=null;\"string\"==typeof c.seed&&(g=new l(c.seed)),c.base_color.length>0&&(h=c.base_color.match(/^#?([0-9a-f]{3})([0-9a-f]{3})?$/i)?F.HEX_to_HSV(c.base_color):F.NAME_to_HSV(c.base_color));for(var m=0;m<c.colors_returned;m++){var f,E,b,p=e(0,360,g);null!==h?(f=a(e(h.h-5,h.h+5,g),0,360),E=0===h.s?0:r(.4,.85,g),b=r(.4,.85,g),s.push({h:f,s:E,v:b})):(f=c.greyscale===!0||c.grayscale===!0?0:c.golden===!0?(p+p/i)%360:null===c.hue||c.full_random===!0?p:a(c.hue,0,360),E=c.greyscale===!0||c.grayscale===!0?0:c.full_random===!0?r(0,1,g):null===c.saturation?.4:a(c.saturation,0,1),b=c.full_random===!0?r(0,1,g):c.greyscale===!0||c.grayscale===!0?r(.15,.75,g):null===c.value?.75:a(c.value,0,1),s.push({h:f,s:E,v:b}))}return o(c.format.toLowerCase(),s),s},F.make_contrast=function(e,r){var l=t(h);if(null!==r)for(var s in r)r.hasOwnProperty(s)&&(l[s]=r[s]);var u,c,d=n(e);if(l.golden===!0)c=e.h*(1+i)%360;else{var g=F.make_scheme(e,{scheme_type:\"complementary\",format:\"hsv\"})[1];c=a(g.h-30,0,360)}var m;return\"dark\"===d?m=a(e.v-.25,0,1):\"light\"===d&&(m=a(e.v+.25,0,1)),u=[{h:c,s:e.s,v:m}],o(l.format.toLowerCase(),u),u[0]},F}return e()});\n\n//# sourceURL=webpack:///./node_modules/pleasejs/dist/Please.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/string.prototype.trim/implementation.js":
/*!**************************************************************!*\
  !*** ./node_modules/string.prototype.trim/implementation.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar ES = __webpack_require__(/*! es-abstract/es5 */ \"./node_modules/es-abstract/es5.js\");\nvar replace = bind.call(Function.call, String.prototype.replace);\n\nvar leftWhitespace = /^[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+/;\nvar rightWhitespace = /[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]+$/;\n\nmodule.exports = function trim() {\n\tvar S = ES.ToString(ES.CheckObjectCoercible(this));\n\treturn replace(replace(S, leftWhitespace, ''), rightWhitespace, '');\n};\n\n\n//# sourceURL=webpack:///./node_modules/string.prototype.trim/implementation.js?");

/***/ }),

/***/ "./node_modules/string.prototype.trim/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/string.prototype.trim/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar bind = __webpack_require__(/*! function-bind */ \"./node_modules/function-bind/index.js\");\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/string.prototype.trim/implementation.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/string.prototype.trim/polyfill.js\");\nvar shim = __webpack_require__(/*! ./shim */ \"./node_modules/string.prototype.trim/shim.js\");\n\nvar boundTrim = bind.call(Function.call, getPolyfill());\n\ndefine(boundTrim, {\n\tgetPolyfill: getPolyfill,\n\timplementation: implementation,\n\tshim: shim\n});\n\nmodule.exports = boundTrim;\n\n\n//# sourceURL=webpack:///./node_modules/string.prototype.trim/index.js?");

/***/ }),

/***/ "./node_modules/string.prototype.trim/polyfill.js":
/*!********************************************************!*\
  !*** ./node_modules/string.prototype.trim/polyfill.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar implementation = __webpack_require__(/*! ./implementation */ \"./node_modules/string.prototype.trim/implementation.js\");\n\nvar zeroWidthSpace = '\\u200b';\n\nmodule.exports = function getPolyfill() {\n\tif (String.prototype.trim && zeroWidthSpace.trim() === zeroWidthSpace) {\n\t\treturn String.prototype.trim;\n\t}\n\treturn implementation;\n};\n\n\n//# sourceURL=webpack:///./node_modules/string.prototype.trim/polyfill.js?");

/***/ }),

/***/ "./node_modules/string.prototype.trim/shim.js":
/*!****************************************************!*\
  !*** ./node_modules/string.prototype.trim/shim.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar define = __webpack_require__(/*! define-properties */ \"./node_modules/define-properties/index.js\");\nvar getPolyfill = __webpack_require__(/*! ./polyfill */ \"./node_modules/string.prototype.trim/polyfill.js\");\n\nmodule.exports = function shimStringTrim() {\n\tvar polyfill = getPolyfill();\n\tdefine(String.prototype, { trim: polyfill }, { trim: function () { return String.prototype.trim !== polyfill; } });\n\treturn polyfill;\n};\n\n\n//# sourceURL=webpack:///./node_modules/string.prototype.trim/shim.js?");

/***/ }),

/***/ "./node_modules/typedarray-pool/pool.js":
/*!**********************************************!*\
  !*** ./node_modules/typedarray-pool/pool.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global, Buffer) {\n\nvar bits = __webpack_require__(/*! bit-twiddle */ \"./node_modules/bit-twiddle/twiddle.js\")\nvar dup = __webpack_require__(/*! dup */ \"./node_modules/dup/dup.js\")\n\n//Legacy pool support\nif(!global.__TYPEDARRAY_POOL) {\n  global.__TYPEDARRAY_POOL = {\n      UINT8   : dup([32, 0])\n    , UINT16  : dup([32, 0])\n    , UINT32  : dup([32, 0])\n    , INT8    : dup([32, 0])\n    , INT16   : dup([32, 0])\n    , INT32   : dup([32, 0])\n    , FLOAT   : dup([32, 0])\n    , DOUBLE  : dup([32, 0])\n    , DATA    : dup([32, 0])\n    , UINT8C  : dup([32, 0])\n    , BUFFER  : dup([32, 0])\n  }\n}\n\nvar hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'\nvar POOL = global.__TYPEDARRAY_POOL\n\n//Upgrade pool\nif(!POOL.UINT8C) {\n  POOL.UINT8C = dup([32, 0])\n}\nif(!POOL.BUFFER) {\n  POOL.BUFFER = dup([32, 0])\n}\n\n//New technique: Only allocate from ArrayBufferView and Buffer\nvar DATA    = POOL.DATA\n  , BUFFER  = POOL.BUFFER\n\nexports.free = function free(array) {\n  if(Buffer.isBuffer(array)) {\n    BUFFER[bits.log2(array.length)].push(array)\n  } else {\n    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {\n      array = array.buffer\n    }\n    if(!array) {\n      return\n    }\n    var n = array.length || array.byteLength\n    var log_n = bits.log2(n)|0\n    DATA[log_n].push(array)\n  }\n}\n\nfunction freeArrayBuffer(buffer) {\n  if(!buffer) {\n    return\n  }\n  var n = buffer.length || buffer.byteLength\n  var log_n = bits.log2(n)\n  DATA[log_n].push(buffer)\n}\n\nfunction freeTypedArray(array) {\n  freeArrayBuffer(array.buffer)\n}\n\nexports.freeUint8 =\nexports.freeUint16 =\nexports.freeUint32 =\nexports.freeInt8 =\nexports.freeInt16 =\nexports.freeInt32 =\nexports.freeFloat32 = \nexports.freeFloat =\nexports.freeFloat64 = \nexports.freeDouble = \nexports.freeUint8Clamped = \nexports.freeDataView = freeTypedArray\n\nexports.freeArrayBuffer = freeArrayBuffer\n\nexports.freeBuffer = function freeBuffer(array) {\n  BUFFER[bits.log2(array.length)].push(array)\n}\n\nexports.malloc = function malloc(n, dtype) {\n  if(dtype === undefined || dtype === 'arraybuffer') {\n    return mallocArrayBuffer(n)\n  } else {\n    switch(dtype) {\n      case 'uint8':\n        return mallocUint8(n)\n      case 'uint16':\n        return mallocUint16(n)\n      case 'uint32':\n        return mallocUint32(n)\n      case 'int8':\n        return mallocInt8(n)\n      case 'int16':\n        return mallocInt16(n)\n      case 'int32':\n        return mallocInt32(n)\n      case 'float':\n      case 'float32':\n        return mallocFloat(n)\n      case 'double':\n      case 'float64':\n        return mallocDouble(n)\n      case 'uint8_clamped':\n        return mallocUint8Clamped(n)\n      case 'buffer':\n        return mallocBuffer(n)\n      case 'data':\n      case 'dataview':\n        return mallocDataView(n)\n\n      default:\n        return null\n    }\n  }\n  return null\n}\n\nfunction mallocArrayBuffer(n) {\n  var n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var d = DATA[log_n]\n  if(d.length > 0) {\n    return d.pop()\n  }\n  return new ArrayBuffer(n)\n}\nexports.mallocArrayBuffer = mallocArrayBuffer\n\nfunction mallocUint8(n) {\n  return new Uint8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocUint8 = mallocUint8\n\nfunction mallocUint16(n) {\n  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocUint16 = mallocUint16\n\nfunction mallocUint32(n) {\n  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocUint32 = mallocUint32\n\nfunction mallocInt8(n) {\n  return new Int8Array(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocInt8 = mallocInt8\n\nfunction mallocInt16(n) {\n  return new Int16Array(mallocArrayBuffer(2*n), 0, n)\n}\nexports.mallocInt16 = mallocInt16\n\nfunction mallocInt32(n) {\n  return new Int32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocInt32 = mallocInt32\n\nfunction mallocFloat(n) {\n  return new Float32Array(mallocArrayBuffer(4*n), 0, n)\n}\nexports.mallocFloat32 = exports.mallocFloat = mallocFloat\n\nfunction mallocDouble(n) {\n  return new Float64Array(mallocArrayBuffer(8*n), 0, n)\n}\nexports.mallocFloat64 = exports.mallocDouble = mallocDouble\n\nfunction mallocUint8Clamped(n) {\n  if(hasUint8C) {\n    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)\n  } else {\n    return mallocUint8(n)\n  }\n}\nexports.mallocUint8Clamped = mallocUint8Clamped\n\nfunction mallocDataView(n) {\n  return new DataView(mallocArrayBuffer(n), 0, n)\n}\nexports.mallocDataView = mallocDataView\n\nfunction mallocBuffer(n) {\n  n = bits.nextPow2(n)\n  var log_n = bits.log2(n)\n  var cache = BUFFER[log_n]\n  if(cache.length > 0) {\n    return cache.pop()\n  }\n  return new Buffer(n)\n}\nexports.mallocBuffer = mallocBuffer\n\nexports.clearCache = function clearCache() {\n  for(var i=0; i<32; ++i) {\n    POOL.UINT8[i].length = 0\n    POOL.UINT16[i].length = 0\n    POOL.UINT32[i].length = 0\n    POOL.INT8[i].length = 0\n    POOL.INT16[i].length = 0\n    POOL.INT32[i].length = 0\n    POOL.FLOAT[i].length = 0\n    POOL.DOUBLE[i].length = 0\n    POOL.UINT8C[i].length = 0\n    DATA[i].length = 0\n    BUFFER[i].length = 0\n  }\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack:///./node_modules/typedarray-pool/pool.js?");

/***/ }),

/***/ "./node_modules/uniq/uniq.js":
/*!***********************************!*\
  !*** ./node_modules/uniq/uniq.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction unique_pred(list, compare) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b=list[0]\n  for(var i=1; i<len; ++i) {\n    b = a\n    a = list[i]\n    if(compare(a, b)) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique_eq(list) {\n  var ptr = 1\n    , len = list.length\n    , a=list[0], b = list[0]\n  for(var i=1; i<len; ++i, b=a) {\n    b = a\n    a = list[i]\n    if(a !== b) {\n      if(i === ptr) {\n        ptr++\n        continue\n      }\n      list[ptr++] = a\n    }\n  }\n  list.length = ptr\n  return list\n}\n\nfunction unique(list, compare, sorted) {\n  if(list.length === 0) {\n    return list\n  }\n  if(compare) {\n    if(!sorted) {\n      list.sort(compare)\n    }\n    return unique_pred(list, compare)\n  }\n  if(!sorted) {\n    list.sort()\n  }\n  return unique_eq(list)\n}\n\nmodule.exports = unique\n\n\n//# sourceURL=webpack:///./node_modules/uniq/uniq.js?");

/***/ }),

/***/ "./node_modules/util/node_modules/inherits/inherits_browser.js":
/*!*********************************************************************!*\
  !*** ./node_modules/util/node_modules/inherits/inherits_browser.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n//# sourceURL=webpack:///./node_modules/util/node_modules/inherits/inherits_browser.js?");

/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n//# sourceURL=webpack:///./node_modules/util/support/isBufferBrowser.js?");

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ \"./node_modules/util/support/isBufferBrowser.js\");\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(/*! inherits */ \"./node_modules/util/node_modules/inherits/inherits_browser.js\");\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/util/util.js?");

/***/ }),

/***/ "./node_modules/vkey/index.js":
/*!************************************!*\
  !*** ./node_modules/vkey/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar ua = typeof window !== 'undefined' ? window.navigator.userAgent : ''\n  , isOSX = /OS X/.test(ua)\n  , isOpera = /Opera/.test(ua)\n  , maybeFirefox = !/like Gecko/.test(ua) && !isOpera\n\nvar i, output = module.exports = {\n  0:  isOSX ? '<menu>' : '<UNK>'\n, 1:  '<mouse 1>'\n, 2:  '<mouse 2>'\n, 3:  '<break>'\n, 4:  '<mouse 3>'\n, 5:  '<mouse 4>'\n, 6:  '<mouse 5>'\n, 8:  '<backspace>'\n, 9:  '<tab>'\n, 12: '<clear>'\n, 13: '<enter>'\n, 16: '<shift>'\n, 17: '<control>'\n, 18: '<alt>'\n, 19: '<pause>'\n, 20: '<caps-lock>'\n, 21: '<ime-hangul>'\n, 23: '<ime-junja>'\n, 24: '<ime-final>'\n, 25: '<ime-kanji>'\n, 27: '<escape>'\n, 28: '<ime-convert>'\n, 29: '<ime-nonconvert>'\n, 30: '<ime-accept>'\n, 31: '<ime-mode-change>'\n, 32: '<space>'\n, 33: '<page-up>'\n, 34: '<page-down>'\n, 35: '<end>'\n, 36: '<home>'\n, 37: '<left>'\n, 38: '<up>'\n, 39: '<right>'\n, 40: '<down>'\n, 41: '<select>'\n, 42: '<print>'\n, 43: '<execute>'\n, 44: '<snapshot>'\n, 45: '<insert>'\n, 46: '<delete>'\n, 47: '<help>'\n, 91: '<meta>'  // meta-left -- no one handles left and right properly, so we coerce into one.\n, 92: '<meta>'  // meta-right\n, 93: isOSX ? '<meta>' : '<menu>'      // chrome,opera,safari all report this for meta-right (osx mbp).\n, 95: '<sleep>'\n, 106: '<num-*>'\n, 107: '<num-+>'\n, 108: '<num-enter>'\n, 109: '<num-->'\n, 110: '<num-.>'\n, 111: '<num-/>'\n, 144: '<num-lock>'\n, 145: '<scroll-lock>'\n, 160: '<shift-left>'\n, 161: '<shift-right>'\n, 162: '<control-left>'\n, 163: '<control-right>'\n, 164: '<alt-left>'\n, 165: '<alt-right>'\n, 166: '<browser-back>'\n, 167: '<browser-forward>'\n, 168: '<browser-refresh>'\n, 169: '<browser-stop>'\n, 170: '<browser-search>'\n, 171: '<browser-favorites>'\n, 172: '<browser-home>'\n\n  // ff/osx reports '<volume-mute>' for '-'\n, 173: isOSX && maybeFirefox ? '-' : '<volume-mute>'\n, 174: '<volume-down>'\n, 175: '<volume-up>'\n, 176: '<next-track>'\n, 177: '<prev-track>'\n, 178: '<stop>'\n, 179: '<play-pause>'\n, 180: '<launch-mail>'\n, 181: '<launch-media-select>'\n, 182: '<launch-app 1>'\n, 183: '<launch-app 2>'\n, 186: ';'\n, 187: '='\n, 188: ','\n, 189: '-'\n, 190: '.'\n, 191: '/'\n, 192: '`'\n, 219: '['\n, 220: '\\\\'\n, 221: ']'\n, 222: \"'\"\n, 223: '<meta>'\n, 224: '<meta>'       // firefox reports meta here.\n, 226: '<alt-gr>'\n, 229: '<ime-process>'\n, 231: isOpera ? '`' : '<unicode>'\n, 246: '<attention>'\n, 247: '<crsel>'\n, 248: '<exsel>'\n, 249: '<erase-eof>'\n, 250: '<play>'\n, 251: '<zoom>'\n, 252: '<no-name>'\n, 253: '<pa-1>'\n, 254: '<clear>'\n}\n\nfor(i = 58; i < 65; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// 0-9\nfor(i = 48; i < 58; ++i) {\n  output[i] = (i - 48)+''\n}\n\n// A-Z\nfor(i = 65; i < 91; ++i) {\n  output[i] = String.fromCharCode(i)\n}\n\n// num0-9\nfor(i = 96; i < 106; ++i) {\n  output[i] = '<num-'+(i - 96)+'>'\n}\n\n// F1-F24\nfor(i = 112; i < 136; ++i) {\n  output[i] = 'F'+(i-111)\n}\n\n\n//# sourceURL=webpack:///./node_modules/vkey/index.js?");

/***/ }),

/***/ "./node_modules/voxel-aabb-sweep/index.js":
/*!************************************************!*\
  !*** ./node_modules/voxel-aabb-sweep/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\n// reused array instances\n\nvar tr_arr = []\nvar ldi_arr = []\nvar tri_arr = []\nvar step_arr = []\nvar tDelta_arr = []\nvar tNext_arr = []\nvar vec_arr = []\nvar normed_arr = []\nvar base_arr = []\nvar max_arr = []\nvar left_arr = []\nvar result_arr = []\n\n\n\n// core implementation:\n\nfunction sweep_impl(getVoxel, callback, vec, base, max, epsilon) {\n\n    // consider algo as a raycast along the AABB's leading corner\n    // as raycast enters each new voxel, iterate in 2D over the AABB's \n    // leading face in that axis looking for collisions\n    // \n    // original raycast implementation: https://github.com/andyhall/fast-voxel-raycast\n    // original raycast paper: http://www.cse.chalmers.se/edu/year/2010/course/TDA361/grid.pdf\n\n    var tr = tr_arr\n    var ldi = ldi_arr\n    var tri = tri_arr\n    var step = step_arr\n    var tDelta = tDelta_arr\n    var tNext = tNext_arr\n    var normed = normed_arr\n\n    var floor = Math.floor\n    var cumulative_t = 0.0\n    var t = 0.0\n    var max_t = 0.0\n    var axis = 0\n    var i = 0\n\n\n    // init for the current sweep vector and take first step\n    initSweep()\n    if (max_t === 0) return 0\n\n    axis = stepForward()\n\n    // loop along raycast vector\n    while (t <= max_t) {\n\n        // sweeps over leading face of AABB\n        if (checkCollision(axis)) {\n            // calls the callback and decides whether to continue\n            var done = handleCollision()\n            if (done) return cumulative_t\n        }\n\n        axis = stepForward()\n    }\n\n    // reached the end of the vector unobstructed, finish and exit\n    cumulative_t += max_t\n    for (i = 0; i < 3; i++) {\n        base[i] += vec[i]\n        max[i] += vec[i]\n    }\n    return cumulative_t\n\n\n\n\n\n    // low-level implementations of each step:\n    function initSweep() {\n\n        // parametrization t along raycast\n        t = 0.0\n        max_t = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2])\n        if (max_t === 0) return\n        for (var i = 0; i < 3; i++) {\n            var dir = (vec[i] >= 0)\n            step[i] = dir ? 1 : -1\n            // trailing / trailing edge coords\n            var lead = dir ? max[i] : base[i]\n            tr[i] = dir ? base[i] : max[i]\n            // int values of lead/trail edges\n            ldi[i] = leadEdgeToInt(lead, step[i])\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n            // normed vector\n            normed[i] = vec[i] / max_t\n            // distance along t required to move one voxel in each axis\n            tDelta[i] = Math.abs(1 / normed[i])\n            // location of nearest voxel boundary, in units of t \n            var dist = dir ? (ldi[i] + 1 - lead) : (lead - ldi[i])\n            tNext[i] = (tDelta[i] < Infinity) ? tDelta[i] * dist : Infinity\n        }\n\n    }\n\n\n    // check for collisions - iterate over the leading face on the advancing axis\n\n    function checkCollision(i_axis) {\n        var stepx = step[0]\n        var x0 = (i_axis === 0) ? ldi[0] : tri[0]\n        var x1 = ldi[0] + stepx\n\n        var stepy = step[1]\n        var y0 = (i_axis === 1) ? ldi[1] : tri[1]\n        var y1 = ldi[1] + stepy\n\n        var stepz = step[2]\n        var z0 = (i_axis === 2) ? ldi[2] : tri[2]\n        var z1 = ldi[2] + stepz\n\n        // var j_axis = (i_axis + 1) % 3\n        // var k_axis = (i_axis + 2) % 3\n        // var s = ['x', 'y', 'z'][i_axis]\n        // var js = ['x', 'y', 'z'][j_axis]\n        // var ks = ['x', 'y', 'z'][k_axis]\n        // var i0 = [x0, y0, z0][i_axis]\n        // var j0 = [x0, y0, z0][j_axis]\n        // var k0 = [x0, y0, z0][k_axis]\n        // var i1 = [x1 - stepx, y1 - stepy, z1 - stepz][i_axis]\n        // var j1 = [x1 - stepx, y1 - stepy, z1 - stepz][j_axis]\n        // var k1 = [x1 - stepx, y1 - stepy, z1 - stepz][k_axis]\n        // console.log('=== step', s, 'to', i0, '   sweep', js, j0 + ',' + j1, '   ', ks, k0 + ',' + k1)\n\n        for (var x = x0; x != x1; x += stepx) {\n            for (var y = y0; y != y1; y += stepy) {\n                for (var z = z0; z != z1; z += stepz) {\n                    if (getVoxel(x, y, z)) return true\n                }\n            }\n        }\n        return false\n    }\n\n\n    // on collision - call the callback and return or set up for the next sweep\n\n    function handleCollision() {\n\n        // set up for callback\n        cumulative_t += t\n        var dir = step[axis]\n\n        // vector moved so far, and left to move\n        var done = t / max_t\n        var left = left_arr\n        for (i = 0; i < 3; i++) {\n            var dv = vec[i] * done\n            base[i] += dv\n            max[i] += dv\n            left[i] = vec[i] - dv\n        }\n\n        // set leading edge of stepped axis exactly to voxel boundary\n        // else we'll sometimes rounding error beyond it\n        if (dir > 0) {\n            max[axis] = Math.round(max[axis])\n        } else {\n            base[axis] = Math.round(base[axis])\n        }\n        \n        // call back to let client update the \"left to go\" vector\n        var res = callback(cumulative_t, axis, dir, left)\n\n        // bail out out on truthy response\n        if (res) return true\n\n        // init for new sweep along vec\n        for (i = 0; i < 3; i++) vec[i] = left[i]\n        initSweep()\n        if (max_t === 0) return true // no vector left\n\n        return false\n    }\n\n\n    // advance to next voxel boundary, and return which axis was stepped\n\n    function stepForward() {\n        var axis = (tNext[0] < tNext[1]) ?\n            ((tNext[0] < tNext[2]) ? 0 : 2) :\n            ((tNext[1] < tNext[2]) ? 1 : 2)\n        var dt = tNext[axis] - t\n        t = tNext[axis]\n        ldi[axis] += step[axis]\n        tNext[axis] += tDelta[axis]\n        for (i = 0; i < 3; i++) {\n            tr[i] += dt * normed[i]\n            tri[i] = trailEdgeToInt(tr[i], step[i])\n        }\n\n        return axis\n    }\n\n\n\n    function leadEdgeToInt(coord, step) {\n        return floor(coord - step * epsilon)\n    }\n    function trailEdgeToInt(coord, step) {\n        return floor(coord + step * epsilon)\n    }\n\n}\n\n\n\n\n\n// conform inputs\n\nfunction sweep(getVoxel, box, dir, callback, noTranslate, epsilon) {\n\n    var vec = vec_arr\n    var base = base_arr\n    var max = max_arr\n    var result = result_arr\n\n    // init parameter float arrays\n    for (var i = 0; i < 3; i++) {\n        vec[i] = +dir[i]\n        max[i] = +box.max[i]\n        base[i] = +box.base[i]\n    }\n\n    if (!epsilon) epsilon = 1e-10\n\n    // run sweep implementation\n    var dist = sweep_impl(getVoxel, callback, vec, base, max, epsilon)\n\n    // translate box by distance needed to updated base value\n    if (!noTranslate) {\n        for (i = 0; i < 3; i++) {\n            result[i] = (dir[i] > 0) ? max[i] - box.max[i] : base[i] - box.base[i]\n        }\n        box.translate(result)\n    }\n\n    // return value is total distance moved (not necessarily magnitude of [end]-[start])\n    return dist\n}\n\nmodule.exports = sweep\n\n\n\n//# sourceURL=webpack:///./node_modules/voxel-aabb-sweep/index.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/add.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/add.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = add;\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction add(out, a, b) {\n    out[0] = a[0] + b[0]\n    out[1] = a[1] + b[1]\n    out[2] = a[2] + b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/add.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/angle.js":
/*!*************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/angle.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = angle\n\nvar fromValues = __webpack_require__(/*! ./fromValues */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/fromValues.js\")\nvar normalize = __webpack_require__(/*! ./normalize */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/normalize.js\")\nvar dot = __webpack_require__(/*! ./dot */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/dot.js\")\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nfunction angle(a, b) {\n    var tempA = fromValues(a[0], a[1], a[2])\n    var tempB = fromValues(b[0], b[1], b[2])\n \n    normalize(tempA, tempA)\n    normalize(tempB, tempB)\n \n    var cosine = dot(tempA, tempB)\n\n    if(cosine > 1.0){\n        return 0\n    } else {\n        return Math.acos(cosine)\n    }     \n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/angle.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/ceil.js":
/*!************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/ceil.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = ceil\n\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to ceil\n * @returns {vec3} out\n */\nfunction ceil(out, a) {\n  out[0] = Math.ceil(a[0])\n  out[1] = Math.ceil(a[1])\n  out[2] = Math.ceil(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/ceil.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/clone.js":
/*!*************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/clone.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = clone;\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nfunction clone(a) {\n    var out = new Float32Array(3)\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/clone.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/copy.js":
/*!************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/copy.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = copy;\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nfunction copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    out[2] = a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/copy.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/create.js":
/*!**************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/create.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = create;\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nfunction create() {\n    var out = new Float32Array(3)\n    out[0] = 0\n    out[1] = 0\n    out[2] = 0\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/create.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/cross.js":
/*!*************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/cross.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = cross;\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction cross(out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2]\n\n    out[0] = ay * bz - az * by\n    out[1] = az * bx - ax * bz\n    out[2] = ax * by - ay * bx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/cross.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/dist.js":
/*!************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/dist.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./distance */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/distance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/dist.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/distance.js":
/*!****************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/distance.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = distance;\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nfunction distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/distance.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/div.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/div.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./divide */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/divide.js\")\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/div.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/divide.js":
/*!**************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/divide.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = divide;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction divide(out, a, b) {\n    out[0] = a[0] / b[0]\n    out[1] = a[1] / b[1]\n    out[2] = a[2] / b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/divide.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/dot.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/dot.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = dot;\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nfunction dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/dot.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/epsilon.js":
/*!***************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/epsilon.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = 0.000001\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/epsilon.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/equals.js":
/*!**************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/equals.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = equals\n\nvar EPSILON = __webpack_require__(/*! ./epsilon */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/epsilon.js\")\n\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction equals(a, b) {\n  var a0 = a[0]\n  var a1 = a[1]\n  var a2 = a[2]\n  var b0 = b[0]\n  var b1 = b[1]\n  var b2 = b[2]\n  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&\n          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&\n          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/equals.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/exactEquals.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/exactEquals.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = exactEquals\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nfunction exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/exactEquals.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/floor.js":
/*!*************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/floor.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = floor\n\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to floor\n * @returns {vec3} out\n */\nfunction floor(out, a) {\n  out[0] = Math.floor(a[0])\n  out[1] = Math.floor(a[1])\n  out[2] = Math.floor(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/floor.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/forEach.js":
/*!***************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/forEach.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = forEach;\n\nvar vec = __webpack_require__(/*! ./create */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/create.js\")()\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nfunction forEach(a, stride, offset, count, fn, arg) {\n        var i, l\n        if(!stride) {\n            stride = 3\n        }\n\n        if(!offset) {\n            offset = 0\n        }\n        \n        if(count) {\n            l = Math.min((count * stride) + offset, a.length)\n        } else {\n            l = a.length\n        }\n\n        for(i = offset; i < l; i += stride) {\n            vec[0] = a[i] \n            vec[1] = a[i+1] \n            vec[2] = a[i+2]\n            fn(vec, vec, arg)\n            a[i] = vec[0] \n            a[i+1] = vec[1] \n            a[i+2] = vec[2]\n        }\n        \n        return a\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/forEach.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/fromValues.js":
/*!******************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/fromValues.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = fromValues;\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nfunction fromValues(x, y, z) {\n    var out = new Float32Array(3)\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/fromValues.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/index.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n  EPSILON: __webpack_require__(/*! ./epsilon */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/epsilon.js\")\n  , create: __webpack_require__(/*! ./create */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/create.js\")\n  , clone: __webpack_require__(/*! ./clone */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/clone.js\")\n  , angle: __webpack_require__(/*! ./angle */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/angle.js\")\n  , fromValues: __webpack_require__(/*! ./fromValues */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/fromValues.js\")\n  , copy: __webpack_require__(/*! ./copy */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/copy.js\")\n  , set: __webpack_require__(/*! ./set */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/set.js\")\n  , equals: __webpack_require__(/*! ./equals */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/equals.js\")\n  , exactEquals: __webpack_require__(/*! ./exactEquals */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/exactEquals.js\")\n  , add: __webpack_require__(/*! ./add */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/add.js\")\n  , subtract: __webpack_require__(/*! ./subtract */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/subtract.js\")\n  , sub: __webpack_require__(/*! ./sub */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/sub.js\")\n  , multiply: __webpack_require__(/*! ./multiply */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/multiply.js\")\n  , mul: __webpack_require__(/*! ./mul */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/mul.js\")\n  , divide: __webpack_require__(/*! ./divide */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/divide.js\")\n  , div: __webpack_require__(/*! ./div */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/div.js\")\n  , min: __webpack_require__(/*! ./min */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/min.js\")\n  , max: __webpack_require__(/*! ./max */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/max.js\")\n  , floor: __webpack_require__(/*! ./floor */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/floor.js\")\n  , ceil: __webpack_require__(/*! ./ceil */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/ceil.js\")\n  , round: __webpack_require__(/*! ./round */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/round.js\")\n  , scale: __webpack_require__(/*! ./scale */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/scale.js\")\n  , scaleAndAdd: __webpack_require__(/*! ./scaleAndAdd */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/scaleAndAdd.js\")\n  , distance: __webpack_require__(/*! ./distance */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/distance.js\")\n  , dist: __webpack_require__(/*! ./dist */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/dist.js\")\n  , squaredDistance: __webpack_require__(/*! ./squaredDistance */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredDistance.js\")\n  , sqrDist: __webpack_require__(/*! ./sqrDist */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrDist.js\")\n  , length: __webpack_require__(/*! ./length */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/length.js\")\n  , len: __webpack_require__(/*! ./len */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/len.js\")\n  , squaredLength: __webpack_require__(/*! ./squaredLength */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredLength.js\")\n  , sqrLen: __webpack_require__(/*! ./sqrLen */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrLen.js\")\n  , negate: __webpack_require__(/*! ./negate */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/negate.js\")\n  , inverse: __webpack_require__(/*! ./inverse */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/inverse.js\")\n  , normalize: __webpack_require__(/*! ./normalize */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/normalize.js\")\n  , dot: __webpack_require__(/*! ./dot */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/dot.js\")\n  , cross: __webpack_require__(/*! ./cross */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/cross.js\")\n  , lerp: __webpack_require__(/*! ./lerp */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/lerp.js\")\n  , random: __webpack_require__(/*! ./random */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/random.js\")\n  , transformMat4: __webpack_require__(/*! ./transformMat4 */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat4.js\")\n  , transformMat3: __webpack_require__(/*! ./transformMat3 */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat3.js\")\n  , transformQuat: __webpack_require__(/*! ./transformQuat */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformQuat.js\")\n  , rotateX: __webpack_require__(/*! ./rotateX */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateX.js\")\n  , rotateY: __webpack_require__(/*! ./rotateY */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateY.js\")\n  , rotateZ: __webpack_require__(/*! ./rotateZ */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateZ.js\")\n  , forEach: __webpack_require__(/*! ./forEach */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/forEach.js\")\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/index.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/inverse.js":
/*!***************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/inverse.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = inverse;\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nfunction inverse(out, a) {\n  out[0] = 1.0 / a[0]\n  out[1] = 1.0 / a[1]\n  out[2] = 1.0 / a[2]\n  return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/inverse.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/len.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/len.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./length */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/length.js\")\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/len.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/length.js":
/*!**************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/length.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = length;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nfunction length(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return Math.sqrt(x*x + y*y + z*z)\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/length.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/lerp.js":
/*!************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/lerp.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = lerp;\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nfunction lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2]\n    out[0] = ax + t * (b[0] - ax)\n    out[1] = ay + t * (b[1] - ay)\n    out[2] = az + t * (b[2] - az)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/lerp.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/max.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/max.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = max;\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction max(out, a, b) {\n    out[0] = Math.max(a[0], b[0])\n    out[1] = Math.max(a[1], b[1])\n    out[2] = Math.max(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/max.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/min.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/min.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = min;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction min(out, a, b) {\n    out[0] = Math.min(a[0], b[0])\n    out[1] = Math.min(a[1], b[1])\n    out[2] = Math.min(a[2], b[2])\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/min.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/mul.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/mul.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./multiply */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/multiply.js\")\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/mul.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/multiply.js":
/*!****************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/multiply.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = multiply;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction multiply(out, a, b) {\n    out[0] = a[0] * b[0]\n    out[1] = a[1] * b[1]\n    out[2] = a[2] * b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/multiply.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/negate.js":
/*!**************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/negate.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = negate;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nfunction negate(out, a) {\n    out[0] = -a[0]\n    out[1] = -a[1]\n    out[2] = -a[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/negate.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/normalize.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/normalize.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = normalize;\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nfunction normalize(out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    var len = x*x + y*y + z*z\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len)\n        out[0] = a[0] * len\n        out[1] = a[1] * len\n        out[2] = a[2] * len\n    }\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/normalize.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/random.js":
/*!**************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/random.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = random;\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nfunction random(out, scale) {\n    scale = scale || 1.0\n\n    var r = Math.random() * 2.0 * Math.PI\n    var z = (Math.random() * 2.0) - 1.0\n    var zScale = Math.sqrt(1.0-z*z) * scale\n\n    out[0] = Math.cos(r) * zScale\n    out[1] = Math.sin(r) * zScale\n    out[2] = z * scale\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/random.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateX.js":
/*!***************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateX.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateX;\n\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateX(out, a, b, c){\n    var by = b[1]\n    var bz = b[2]\n\n    // Translate point to the origin\n    var py = a[1] - by\n    var pz = a[2] - bz\n\n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = a[0]\n    out[1] = by + py * cc - pz * sc\n    out[2] = bz + py * sc + pz * cc\n\n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateX.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateY.js":
/*!***************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateY.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateY;\n\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateY(out, a, b, c){\n    var bx = b[0]\n    var bz = b[2]\n\n    // translate point to the origin\n    var px = a[0] - bx\n    var pz = a[2] - bz\n    \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n  \n    // perform rotation and translate to correct position\n    out[0] = bx + pz * sc + px * cc\n    out[1] = a[1]\n    out[2] = bz + pz * cc - px * sc\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateY.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateZ.js":
/*!***************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateZ.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = rotateZ;\n\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {vec3} a The vec3 point to rotate\n * @param {vec3} b The origin of the rotation\n * @param {Number} c The angle of rotation\n * @returns {vec3} out\n */\nfunction rotateZ(out, a, b, c){\n    var bx = b[0]\n    var by = b[1]\n\n    //Translate point to the origin\n    var px = a[0] - bx\n    var py = a[1] - by\n  \n    var sc = Math.sin(c)\n    var cc = Math.cos(c)\n\n    // perform rotation and translate to correct position\n    out[0] = bx + px * cc - py * sc\n    out[1] = by + px * sc + py * cc\n    out[2] = a[2]\n  \n    return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/rotateZ.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/round.js":
/*!*************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/round.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = round\n\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to round\n * @returns {vec3} out\n */\nfunction round(out, a) {\n  out[0] = Math.round(a[0])\n  out[1] = Math.round(a[1])\n  out[2] = Math.round(a[2])\n  return out\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/round.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/scale.js":
/*!*************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/scale.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scale;\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nfunction scale(out, a, b) {\n    out[0] = a[0] * b\n    out[1] = a[1] * b\n    out[2] = a[2] * b\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/scale.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/scaleAndAdd.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/scaleAndAdd.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = scaleAndAdd;\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nfunction scaleAndAdd(out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale)\n    out[1] = a[1] + (b[1] * scale)\n    out[2] = a[2] + (b[2] * scale)\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/scaleAndAdd.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/set.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/set.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = set;\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nfunction set(out, x, y, z) {\n    out[0] = x\n    out[1] = y\n    out[2] = z\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/set.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrDist.js":
/*!***************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrDist.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredDistance */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredDistance.js\")\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrDist.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrLen.js":
/*!**************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrLen.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./squaredLength */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredLength.js\")\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/sqrLen.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredDistance.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredDistance.js ***!
  \***********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredDistance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nfunction squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredDistance.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredLength.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredLength.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = squaredLength;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nfunction squaredLength(a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2]\n    return x*x + y*y + z*z\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/squaredLength.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/sub.js":
/*!***********************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/sub.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./subtract */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/subtract.js\")\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/sub.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/subtract.js":
/*!****************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/subtract.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = subtract;\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nfunction subtract(out, a, b) {\n    out[0] = a[0] - b[0]\n    out[1] = a[1] - b[1]\n    out[2] = a[2] - b[2]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/subtract.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat3.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat3.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat3;\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat3(out, a, m) {\n    var x = a[0], y = a[1], z = a[2]\n    out[0] = x * m[0] + y * m[3] + z * m[6]\n    out[1] = x * m[1] + y * m[4] + z * m[7]\n    out[2] = x * m[2] + y * m[5] + z * m[8]\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat3.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat4.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat4.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformMat4;\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nfunction transformMat4(out, a, m) {\n    var x = a[0], y = a[1], z = a[2],\n        w = m[3] * x + m[7] * y + m[11] * z + m[15]\n    w = w || 1.0\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformMat4.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformQuat.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformQuat.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = transformQuat;\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nfunction transformQuat(out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx\n    return out\n}\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/node_modules/gl-vec3/transformQuat.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/voxel-physics-engine/src/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"./node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/index.js\")\nvar sweep = __webpack_require__(/*! voxel-aabb-sweep */ \"./node_modules/voxel-aabb-sweep/index.js\")\nvar RigidBody = __webpack_require__(/*! ./rigidBody */ \"./node_modules/voxel-physics-engine/src/rigidBody.js\")\n\n\nvar DEBUG = 0\n\n\nmodule.exports = function (opts, testSolid, testFluid) {\n    return new Physics(opts, testSolid, testFluid)\n}\n\nvar defaults = {\n    gravity: [0, -10, 0],\n    minBounceImpulse: .5, // lowest collision impulse that bounces\n    airDrag: 0.1,\n    fluidDrag: 0.4,\n    fluidDensity: 2.0,\n}\n\n\n/* \n *    CONSTRUCTOR - represents a world of rigid bodies.\n * \n *  Takes testSolid(x,y,z) function to query block solidity\n *  Takes testFluid(x,y,z) function to query if a block is a fluid\n*/\nfunction Physics(opts, testSolid, testFluid) {\n    opts = Object.assign({}, defaults, opts)\n\n    this.gravity = opts.gravity\n    this.airDrag = opts.airDrag\n    this.fluidDensity = opts.fluidDensity\n    this.fluidDrag = opts.fluidDrag\n    this.minBounceImpulse = opts.minBounceImpulse\n    this.bodies = []\n\n    // collision function - TODO: abstract this into a setter?\n    this.testSolid = testSolid\n    this.testFluid = testFluid\n}\n\n\n/*\n *    ADDING AND REMOVING RIGID BODIES\n*/\n\nPhysics.prototype.addBody = function (_aabb, mass, friction,\n    restitution, gravMult, onCollide) {\n    _aabb = _aabb || new aabb([0, 0, 0], [1, 1, 1])\n    if (typeof mass == 'undefined') mass = 1\n    if (typeof friction == 'undefined') friction = 1\n    if (typeof restitution == 'undefined') restitution = 0\n    if (typeof gravMult == 'undefined') gravMult = 1\n    var b = new RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide)\n    this.bodies.push(b)\n    return b\n}\n\nPhysics.prototype.removeBody = function (b) {\n    var i = this.bodies.indexOf(b)\n    if (i < 0) return undefined\n    this.bodies.splice(i, 1)\n    b.aabb = b.onCollide = null\n}\n\n\n\n\n/*\n *    PHYSICS AND COLLISIONS\n*/\n\nvar a = vec3.create()\nvar dv = vec3.create()\nvar dx = vec3.create()\nvar impacts = vec3.create()\nvar oldResting = vec3.create()\n\n\n/*\n *    TICK HANDLER\n*/\nPhysics.prototype.tick = function (dt) {\n    // convert dt to seconds\n    dt = dt / 1000\n    var noGravity = equals(0, vec3.squaredLength(this.gravity))\n\n    this.bodies.forEach(b => iterateBody(this, b, dt, noGravity))\n}\n\n\n\n/*\n *    PER-BODY MAIN PHYSICS ROUTINE\n*/\n\nfunction iterateBody(self, b, dt, noGravity) {\n    vec3.copy(oldResting, b.resting)\n\n    // treat bodies with <= mass as static\n    if (b.mass <= 0) {\n        vec3.set(b.velocity, 0, 0, 0)\n        vec3.set(b._forces, 0, 0, 0)\n        vec3.set(b._impulses, 0, 0, 0)\n        return\n    }\n\n    // skip bodies if static or no velocity/forces/impulses\n    var localNoGrav = noGravity || (b.gravityMultiplier === 0)\n    if (bodyAsleep(self, b, dt, localNoGrav)) return\n    b._sleepFrameCount--\n\n    // check if under water, if so apply buoyancy and drag forces\n    applyFluidForces(self, b)\n\n    // debug hooks\n    sanityCheck(b._forces)\n    sanityCheck(b._impulses)\n    sanityCheck(b.velocity)\n    sanityCheck(b.resting)\n\n    // semi-implicit Euler integration\n\n    // a = f/m + gravity*gravityMultiplier\n    vec3.scale(a, b._forces, 1 / b.mass)\n    vec3.scaleAndAdd(a, a, self.gravity, b.gravityMultiplier)\n\n    // dv = i/m + a*dt\n    // v1 = v0 + dv\n    vec3.scale(dv, b._impulses, 1 / b.mass)\n    vec3.scaleAndAdd(dv, dv, a, dt)\n    vec3.add(b.velocity, b.velocity, dv)\n\n    // apply friction based on change in velocity this frame\n    if (b.friction) {\n        applyFrictionByAxis(0, b, dv)\n        applyFrictionByAxis(1, b, dv)\n        applyFrictionByAxis(2, b, dv)\n    }\n\n    // linear air or fluid friction - effectively v *= drag\n    // body settings override global settings\n    var drag = (b.airDrag >= 0) ? b.airDrag : self.airDrag\n    if (b.inFluid) {\n        drag = (b.fluidDrag >= 0) ? b.fluidDrag : self.fluidDrag\n        drag *= 1 - (1 - b.ratioInFluid) ** 2\n    }\n    var mult = Math.max(1 - drag * dt / b.mass, 0)\n    vec3.scale(b.velocity, b.velocity, mult)\n\n    // x1-x0 = v1*dt\n    vec3.scale(dx, b.velocity, dt)\n\n    // clear forces and impulses for next timestep\n    vec3.set(b._forces, 0, 0, 0)\n    vec3.set(b._impulses, 0, 0, 0)\n\n    // cache old position for use in autostepping\n    if (b.autoStep) {\n        cloneAABB(tmpBox, b.aabb)\n    }\n\n    // sweeps aabb along dx and accounts for collisions\n    processCollisions(self, b.aabb, dx, b.resting)\n\n    // if autostep, and on ground, run collisions again with stepped up aabb\n    if (b.autoStep) {\n        tryAutoStepping(self, b, tmpBox, dx)\n    }\n\n    // Collision impacts. b.resting shows which axes had collisions:\n    for (var i = 0; i < 3; ++i) {\n        impacts[i] = 0\n        if (b.resting[i]) {\n            // count impact only if wasn't collided last frame\n            if (!oldResting[i]) impacts[i] = -b.velocity[i]\n            b.velocity[i] = 0\n        }\n    }\n    var mag = vec3.length(impacts)\n    if (mag > .001) { // epsilon\n        // send collision event - allows client to optionally change\n        // body's restitution depending on what terrain it hit\n        // event argument is impulse J = m * dv\n        vec3.scale(impacts, impacts, b.mass)\n        if (b.onCollide) b.onCollide(impacts)\n\n        // bounce depending on restitution and minBounceImpulse\n        if (b.restitution > 0 && mag > self.minBounceImpulse) {\n            vec3.scale(impacts, impacts, b.restitution)\n            b.applyImpulse(impacts)\n        }\n    }\n\n\n    // sleep check\n    var vsq = vec3.squaredLength(b.velocity)\n    if (vsq > 1e-5) b._markActive()\n}\n\n\n\n\n\n\n\n\n/*\n *    FLUIDS\n*/\n\nfunction applyFluidForces(self, body) {\n    // First pass at handling fluids. Assumes fluids are settled\n    //   thus, only check at corner of body, and only from bottom up\n    var box = body.aabb\n    var cx = Math.floor(box.base[0])\n    var cz = Math.floor(box.base[2])\n    var y0 = Math.floor(box.base[1])\n    var y1 = Math.floor(box.max[1])\n\n    if (!self.testFluid(cx, y0, cz)) {\n        body.inFluid = false\n        body.ratioInFluid = 0\n        return\n    }\n\n    // body is in a fluid - find out how much of body is submerged\n    var submerged = 1\n    var cy = y0 + 1\n    while (cy <= y1 && self.testFluid(cx, cy, cz)) {\n        submerged++\n        cy++\n    }\n    var fluidLevel = y0 + submerged\n    var heightInFluid = fluidLevel - box.base[1]\n    var ratioInFluid = heightInFluid / box.vec[1]\n    if (ratioInFluid > 1) ratioInFluid = 1\n    var vol = box.vec[0] * box.vec[1] * box.vec[2]\n    var displaced = vol * ratioInFluid\n    // bouyant force = -gravity * fluidDensity * volumeDisplaced\n    var f = _fluidVec\n    vec3.scale(f, self.gravity, -self.fluidDensity * displaced)\n    body.applyForce(f)\n\n    body.inFluid = true\n    body.ratioInFluid = ratioInFluid\n}\n\nvar _fluidVec = vec3.create()\n\n\n\n\n\n/*\n *    FRICTION\n*/\n\n\nfunction applyFrictionByAxis(axis, body, dvel) {\n    // friction applies only if moving into a touched surface\n    var restDir = body.resting[axis]\n    var vNormal = dvel[axis]\n    if (restDir === 0) return\n    if (restDir * vNormal <= 0) return\n\n    // current vel lateral to friction axis\n    vec3.copy(lateralVel, body.velocity)\n    lateralVel[axis] = 0\n    var vCurr = vec3.length(lateralVel)\n    if (equals(vCurr, 0)) return\n\n    // treat current change in velocity as the result of a pseudoforce\n    //        Fpseudo = m*dv/dt\n    // Base friction force on normal component of the pseudoforce\n    //        Ff = u * Fnormal\n    //        Ff = u * m * dvnormal / dt\n    // change in velocity due to friction force\n    //        dvF = dt * Ff / m\n    //            = dt * (u * m * dvnormal / dt) / m\n    //            = u * dvnormal\n    var dvMax = Math.abs(body.friction * vNormal)\n\n    // decrease lateral vel by dvMax (or clamp to zero)\n    var scaler = (vCurr > dvMax) ? (vCurr - dvMax) / vCurr : 0\n    body.velocity[(axis + 1) % 3] *= scaler\n    body.velocity[(axis + 2) % 3] *= scaler\n}\nvar lateralVel = vec3.create()\n\n\n\n\n\n\n/*\n *    COLLISION HANDLER\n*/\n\n// sweep aabb along velocity vector and set resting vector\nfunction processCollisions(self, box, velocity, resting) {\n    vec3.set(resting, 0, 0, 0)\n    return sweep(self.testSolid, box, velocity, function (dist, axis, dir, vec) {\n        resting[axis] = dir\n        vec[axis] = 0\n    })\n}\n\n\n\n\n\n/*\n *    AUTO-STEPPING\n*/\n\nvar tmpBox = new aabb([], [])\nvar tmpResting = vec3.create()\nvar targetPos = vec3.create()\nvar upvec = vec3.create()\nvar leftover = vec3.create()\n\nfunction tryAutoStepping(self, b, oldBox, dx) {\n    if (b.resting[1] >= 0 && !b.inFluid) return\n\n    // // direction movement was blocked before trying a step\n    var xBlocked = (b.resting[0] !== 0)\n    var zBlocked = (b.resting[2] !== 0)\n    if (!(xBlocked || zBlocked)) return\n\n    // continue autostepping only if headed sufficiently into obstruction\n    var ratio = Math.abs(dx[0] / dx[2])\n    var cutoff = 4\n    if (!xBlocked && ratio > cutoff) return\n    if (!zBlocked && ratio < 1 / cutoff) return\n\n    // original target position before being obstructed\n    vec3.add(targetPos, oldBox.base, dx)\n\n    // move towards the target until the first X/Z collision\n    var getVoxels = self.testSolid\n    sweep(getVoxels, oldBox, dx, function (dist, axis, dir, vec) {\n        if (axis === 1) vec[axis] = 0\n        else return true\n    })\n\n    var y = b.aabb.base[1]\n    var ydist = Math.floor(y + 1.001) - y\n    vec3.set(upvec, 0, ydist, 0)\n    var collided = false\n    // sweep up, bailing on any obstruction\n    sweep(getVoxels, oldBox, upvec, function (dist, axis, dir, vec) {\n        collided = true\n        return true\n    })\n    if (collided) return // could't move upwards\n\n    // now move in X/Z however far was left over before hitting the obstruction\n    vec3.subtract(leftover, targetPos, oldBox.base)\n    leftover[1] = 0\n    processCollisions(self, oldBox, leftover, tmpResting)\n\n    // bail if no movement happened in the originally blocked direction\n    if (xBlocked && !equals(oldBox.base[0], targetPos[0])) return\n    if (zBlocked && !equals(oldBox.base[2], targetPos[2])) return\n\n    // done - oldBox is now at the target autostepped position\n    cloneAABB(b.aabb, oldBox)\n    b.resting[0] = tmpResting[0]\n    b.resting[2] = tmpResting[2]\n    if (b.onStep) b.onStep()\n}\n\n\n\n\n\n/*\n *    SLEEP CHECK\n*/\n\nfunction bodyAsleep(self, body, dt, noGravity) {\n    if (body._sleepFrameCount > 0) return false\n    // without gravity bodies stay asleep until a force/impulse wakes them up\n    if (noGravity) return true\n    // otherwise check body is resting against something\n    // i.e. sweep along by distance d = 1/2 g*t^2\n    // and check there's still a collision\n    var isResting = false\n    var gmult = 0.5 * dt * dt * body.gravityMultiplier\n    vec3.scale(sleepVec, self.gravity, gmult)\n    sweep(self.testSolid, body.aabb, sleepVec, function () {\n        isResting = true\n        return true\n    }, true)\n    return isResting\n}\nvar sleepVec = vec3.create()\n\n\n\n\n\nfunction equals(a, b) { return Math.abs(a - b) < 1e-5 }\n\nfunction cloneAABB(tgt, src) {\n    for (var i = 0; i < 3; i++) {\n        tgt.base[i] = src.base[i]\n        tgt.max[i] = src.max[i]\n        tgt.vec[i] = src.vec[i]\n    }\n}\n\n\n\nvar sanityCheck = function () { }\nif (DEBUG) sanityCheck = function (v) {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ', v\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/src/index.js?");

/***/ }),

/***/ "./node_modules/voxel-physics-engine/src/rigidBody.js":
/*!************************************************************!*\
  !*** ./node_modules/voxel-physics-engine/src/rigidBody.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar aabb = __webpack_require__(/*! aabb-3d */ \"./node_modules/aabb-3d/index.js\")\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/voxel-physics-engine/node_modules/gl-vec3/index.js\")\n\n\nvar DEBUG = 0\n\n\nmodule.exports = RigidBody\n\n\n\n/*\n *    RIGID BODY - internal data structure\n *  Only AABB bodies right now. Someday will likely need spheres?\n*/\n\nfunction RigidBody(_aabb, mass, friction, restitution, gravMult, onCollide, autoStep) {\n    this.aabb = new aabb(_aabb.base, _aabb.vec) // clone\n    this.mass = mass\n    this.friction = friction\n    this.restitution = restitution\n    this.gravityMultiplier = gravMult\n    this.onCollide = onCollide\n    this.autoStep = !!autoStep\n    this.airDrag = -1   // overrides global airDrag when >= 0\n    this.fluidDrag = -1 // overrides global fluidDrag when >= 0\n    this.onStep = null\n    \n    // internals\n    this.velocity = vec3.create()\n    this.resting = [0, 0, 0]\n    this.inFluid = false\n    this._ratioInFluid = 0\n    this._forces = vec3.create()\n    this._impulses = vec3.create()\n    this._sleepFrameCount = 10 | 0\n}\n\nRigidBody.prototype.setPosition = function (p) {\n    sanityCheck(p)\n    vec3.subtract(p, p, this.aabb.base)\n    this.aabb.translate(p)\n    this._markActive()\n}\nRigidBody.prototype.getPosition = function () {\n    return vec3.clone(this.aabb.base)\n}\nRigidBody.prototype.applyForce = function (f) {\n    sanityCheck(f)\n    vec3.add(this._forces, this._forces, f)\n    this._markActive()\n}\nRigidBody.prototype.applyImpulse = function (i) {\n    sanityCheck(i)\n    vec3.add(this._impulses, this._impulses, i)\n    this._markActive()\n}\nRigidBody.prototype._markActive = function () {\n    this._sleepFrameCount = 10 | 0\n}\n\n\n\n// temp\nRigidBody.prototype.atRestX = function () { return this.resting[0] }\nRigidBody.prototype.atRestY = function () { return this.resting[1] }\nRigidBody.prototype.atRestZ = function () { return this.resting[2] }\n\n\n\n\n\nvar sanityCheck = function () { }\nif (DEBUG) sanityCheck = function (v) {\n    if (isNaN(vec3.length(v))) throw 'Vector with NAN: ', v\n}\n\n\n//# sourceURL=webpack:///./node_modules/voxel-physics-engine/src/rigidBody.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string\n\nvar URL = window.URL || window.webkitURL;\n\nmodule.exports = function (content, url) {\n  try {\n    try {\n      var blob;\n\n      try {\n        // BlobBuilder = Deprecated, but widely implemented\n        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;\n\n        blob = new BlobBuilder();\n\n        blob.append(content);\n\n        blob = blob.getBlob();\n      } catch (e) {\n        // The proposed API\n        blob = new Blob([content]);\n      }\n\n      return new Worker(URL.createObjectURL(blob));\n    } catch (e) {\n      return new Worker('data:application/javascript,' + encodeURIComponent(content));\n    }\n  } catch (e) {\n    if (!url) {\n      throw Error('Inline worker is not supported');\n    }\n\n    return new Worker(url);\n  }\n};\n\n//# sourceURL=webpack:///./node_modules/worker-loader/dist/workers/InlineWorker.js?");

/***/ }),

/***/ "./node_modules/xhr/index.js":
/*!***********************************!*\
  !*** ./node_modules/xhr/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar window = __webpack_require__(/*! global/window */ \"./node_modules/global/window.js\")\nvar isFunction = __webpack_require__(/*! is-function */ \"./node_modules/is-function/index.js\")\nvar parseHeaders = __webpack_require__(/*! parse-headers */ \"./node_modules/parse-headers/parse-headers.js\")\nvar xtend = __webpack_require__(/*! xtend */ \"./node_modules/xtend/immutable.js\")\n\nmodule.exports = createXHR\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = createXHR;\ncreateXHR.XMLHttpRequest = window.XMLHttpRequest || noop\ncreateXHR.XDomainRequest = \"withCredentials\" in (new createXHR.XMLHttpRequest()) ? createXHR.XMLHttpRequest : window.XDomainRequest\n\nforEachArray([\"get\", \"put\", \"post\", \"patch\", \"head\", \"delete\"], function(method) {\n    createXHR[method === \"delete\" ? \"del\" : method] = function(uri, options, callback) {\n        options = initParams(uri, options, callback)\n        options.method = method.toUpperCase()\n        return _createXHR(options)\n    }\n})\n\nfunction forEachArray(array, iterator) {\n    for (var i = 0; i < array.length; i++) {\n        iterator(array[i])\n    }\n}\n\nfunction isEmpty(obj){\n    for(var i in obj){\n        if(obj.hasOwnProperty(i)) return false\n    }\n    return true\n}\n\nfunction initParams(uri, options, callback) {\n    var params = uri\n\n    if (isFunction(options)) {\n        callback = options\n        if (typeof uri === \"string\") {\n            params = {uri:uri}\n        }\n    } else {\n        params = xtend(options, {uri: uri})\n    }\n\n    params.callback = callback\n    return params\n}\n\nfunction createXHR(uri, options, callback) {\n    options = initParams(uri, options, callback)\n    return _createXHR(options)\n}\n\nfunction _createXHR(options) {\n    if(typeof options.callback === \"undefined\"){\n        throw new Error(\"callback argument missing\")\n    }\n\n    var called = false\n    var callback = function cbOnce(err, response, body){\n        if(!called){\n            called = true\n            options.callback(err, response, body)\n        }\n    }\n\n    function readystatechange() {\n        if (xhr.readyState === 4) {\n            setTimeout(loadFunc, 0)\n        }\n    }\n\n    function getBody() {\n        // Chrome with requestType=blob throws errors arround when even testing access to responseText\n        var body = undefined\n\n        if (xhr.response) {\n            body = xhr.response\n        } else {\n            body = xhr.responseText || getXml(xhr)\n        }\n\n        if (isJson) {\n            try {\n                body = JSON.parse(body)\n            } catch (e) {}\n        }\n\n        return body\n    }\n\n    function errorFunc(evt) {\n        clearTimeout(timeoutTimer)\n        if(!(evt instanceof Error)){\n            evt = new Error(\"\" + (evt || \"Unknown XMLHttpRequest Error\") )\n        }\n        evt.statusCode = 0\n        return callback(evt, failureResponse)\n    }\n\n    // will load the data & process the response in a special response object\n    function loadFunc() {\n        if (aborted) return\n        var status\n        clearTimeout(timeoutTimer)\n        if(options.useXDR && xhr.status===undefined) {\n            //IE8 CORS GET successful response doesn't have a status field, but body is fine\n            status = 200\n        } else {\n            status = (xhr.status === 1223 ? 204 : xhr.status)\n        }\n        var response = failureResponse\n        var err = null\n\n        if (status !== 0){\n            response = {\n                body: getBody(),\n                statusCode: status,\n                method: method,\n                headers: {},\n                url: uri,\n                rawRequest: xhr\n            }\n            if(xhr.getAllResponseHeaders){ //remember xhr can in fact be XDR for CORS in IE\n                response.headers = parseHeaders(xhr.getAllResponseHeaders())\n            }\n        } else {\n            err = new Error(\"Internal XMLHttpRequest Error\")\n        }\n        return callback(err, response, response.body)\n    }\n\n    var xhr = options.xhr || null\n\n    if (!xhr) {\n        if (options.cors || options.useXDR) {\n            xhr = new createXHR.XDomainRequest()\n        }else{\n            xhr = new createXHR.XMLHttpRequest()\n        }\n    }\n\n    var key\n    var aborted\n    var uri = xhr.url = options.uri || options.url\n    var method = xhr.method = options.method || \"GET\"\n    var body = options.body || options.data\n    var headers = xhr.headers = options.headers || {}\n    var sync = !!options.sync\n    var isJson = false\n    var timeoutTimer\n    var failureResponse = {\n        body: undefined,\n        headers: {},\n        statusCode: 0,\n        method: method,\n        url: uri,\n        rawRequest: xhr\n    }\n\n    if (\"json\" in options && options.json !== false) {\n        isJson = true\n        headers[\"accept\"] || headers[\"Accept\"] || (headers[\"Accept\"] = \"application/json\") //Don't override existing accept header declared by user\n        if (method !== \"GET\" && method !== \"HEAD\") {\n            headers[\"content-type\"] || headers[\"Content-Type\"] || (headers[\"Content-Type\"] = \"application/json\") //Don't override existing accept header declared by user\n            body = JSON.stringify(options.json === true ? body : options.json)\n        }\n    }\n\n    xhr.onreadystatechange = readystatechange\n    xhr.onload = loadFunc\n    xhr.onerror = errorFunc\n    // IE9 must have onprogress be set to a unique function.\n    xhr.onprogress = function () {\n        // IE must die\n    }\n    xhr.onabort = function(){\n        aborted = true;\n    }\n    xhr.ontimeout = errorFunc\n    xhr.open(method, uri, !sync, options.username, options.password)\n    //has to be after open\n    if(!sync) {\n        xhr.withCredentials = !!options.withCredentials\n    }\n    // Cannot set timeout with sync request\n    // not setting timeout on the xhr object, because of old webkits etc. not handling that correctly\n    // both npm's request and jquery 1.x use this kind of timeout, so this is being consistent\n    if (!sync && options.timeout > 0 ) {\n        timeoutTimer = setTimeout(function(){\n            if (aborted) return\n            aborted = true//IE9 may still call readystatechange\n            xhr.abort(\"timeout\")\n            var e = new Error(\"XMLHttpRequest timeout\")\n            e.code = \"ETIMEDOUT\"\n            errorFunc(e)\n        }, options.timeout )\n    }\n\n    if (xhr.setRequestHeader) {\n        for(key in headers){\n            if(headers.hasOwnProperty(key)){\n                xhr.setRequestHeader(key, headers[key])\n            }\n        }\n    } else if (options.headers && !isEmpty(options.headers)) {\n        throw new Error(\"Headers cannot be set on an XDomainRequest object\")\n    }\n\n    if (\"responseType\" in options) {\n        xhr.responseType = options.responseType\n    }\n\n    if (\"beforeSend\" in options &&\n        typeof options.beforeSend === \"function\"\n    ) {\n        options.beforeSend(xhr)\n    }\n\n    // Microsoft Edge browser sends \"undefined\" when send is called with undefined value.\n    // XMLHttpRequest spec says to pass null as body to indicate no body\n    // See https://github.com/naugtur/xhr/issues/100.\n    xhr.send(body || null)\n\n    return xhr\n\n\n}\n\nfunction getXml(xhr) {\n    // xhr.responseXML will throw Exception \"InvalidStateError\" or \"DOMException\"\n    // See https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseXML.\n    try {\n        if (xhr.responseType === \"document\") {\n            return xhr.responseXML\n        }\n        var firefoxBugTakenEffect = xhr.responseXML && xhr.responseXML.documentElement.nodeName === \"parsererror\"\n        if (xhr.responseType === \"\" && !firefoxBugTakenEffect) {\n            return xhr.responseXML\n        }\n    } catch (e) {}\n\n    return null\n}\n\nfunction noop() {}\n\n\n//# sourceURL=webpack:///./node_modules/xhr/index.js?");

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n\n\n//# sourceURL=webpack:///./node_modules/xtend/immutable.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* global BABYLON */\n\n\n\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\")\nvar noa = __webpack_require__(/*! noa-engine */ \"./node_modules/noa-engine/src/index.js\")\nvar Atlas = __webpack_require__(/*! babylon-atlas */ \"./node_modules/babylon-atlas/index.js\")\n\n// local modules\nvar slides = __webpack_require__(/*! ./lib/slides */ \"./src/lib/slides.js\")\nvar createUI = __webpack_require__(/*! ./lib/ui */ \"./src/lib/ui.js\")\nvar createMob = __webpack_require__(/*! ./lib/mob */ \"./src/lib/mob.js\")\nvar initWorldGen = __webpack_require__(/*! ./lib/worldgen */ \"./src/lib/worldgen.js\")\nvar projectile = __webpack_require__(/*! ./lib/projectile */ \"./src/lib/projectile.js\")\nvar makeParticles = __webpack_require__(/*! ./lib/particles */ \"./src/lib/particles.js\")\nvar createHover = __webpack_require__(/*! ./lib/hover */ \"./src/lib/hover.js\")\nvar setUpZoom = __webpack_require__(/*! ./lib/zoom */ \"./src/lib/zoom.js\")\n\nvar opts = {\n  showFPS: false,\n  // inputs\n  pointerLock: true,\n  inverseY: false,\n  blockTestDistance: 30,\n  // world data\n  chunkSize: 24,\n  chunkAddDistance: 4,\n  chunkRemoveDistance: 4.5,\n  // rendering\n  texturePath: 'textures/',\n  maxCameraZoom: 15,\n  // player\n  playerStart: [250, 50, 250],\n  playerHeight: 2,\n  playerWidth: 1,\n  playerAutoStep: true,\n}\nvar numMobs = 15\n\n\n\n// create engine\nvar game = noa(opts)\nvar addParticles = makeParticles(game)\nvar launchProjectile = projectile(game, addParticles)\n\n// set up camera zoom\nsetUpZoom(game)\n\n// set up world generation, passing in slides data\ninitWorldGen(game, slides.slideData)\ngame.setMaxListeners(100)\n\nwindow.noa = game\n\n\n\n\n// events to show/hide slides on mouseover\ngame.on('tick', function () {\n  var slide = null\n  var tgt = game.targetedBlock\n  if (tgt && tgt.blockID === game.slideBlockID) {\n    var loc = tgt.position\n    var dat = slides.slideData.filter(o => {\n      return (o.x === loc[0] && o.y === loc[1] && o.z === loc[2])\n    })[0]\n    if (dat) slide = dat.id\n  }\n  if (slide) slides.showSlide(slide)\n  else slides.hideSlide()\n})\n\n\n\n\n/*\n *    simple mesh for player, using texture atlas\n*/\n\n\n\nvar ownplayer = localStorage.getItem('avatar')\n\nvar atlas = new Atlas('textures/atlas.png', 'textures/atlas.json',\ngame.rendering.getScene(), BABYLON,\ntrue, BABYLON.Texture.NEAREST_SAMPLINGMODE)\n\nif(ownplayer){\n  var avatar = localStorage.getItem(\"avatar\")\n  \n  //var pmesh = Mesh.CreateBox('player', 1, game.rendering.getScene())\n  //var pmesh = new BABYLON.SpriteManager(\"avatarManager\", avatar, 2000, {width: 50, height: 50});\n  var atlas2 = new Atlas(avatar, 'textures/atlas2.json',\n  game.rendering.getScene(), BABYLON,\n  true, BABYLON.Texture.NEAREST_SAMPLINGMODE)\n}\n\n\n\nvar stand_frame = 'player_stand.png'\nvar jump_frame = 'player_stand.png'\n\nif(ownplayer){\n  var pmesh = atlas2.makeSpriteMesh(stand_frame)\n  console.log('avatar!!!')\n}else{\n  var pmesh = atlas.makeSpriteMesh(stand_frame)\n}\nvar ph = opts.playerHeight,\n  pw = opts.playerWidth\n\n// visual width of sprite slightly wider than hitbox\nvar vw = pw //* 1.25\n\n\npmesh.scaling = new BABYLON.Vector3(vw, ph, 1)\npmesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_Y\n\nif(ownplayer){\n  game.ents.addComponent(game.playerEntity, game.ents.names.mesh, {\n    mesh: pmesh,\n    offset: [0, ph, 0],\n  })\n}else{\n  game.ents.addComponent(game.playerEntity, game.ents.names.mesh, {\n    mesh: pmesh,\n    offset: [0, ph/2, 0],\n  })\n}\n\n\n// simplest animation evar\nvar facing = 1\ngame.on('tick',function() {\n  var onground = game.playerBody.resting[1] < 0\n  var fr = (onground) ? stand_frame : jump_frame\n  atlas.setMeshFrame(pmesh, fr)\n  if(ownplayer){\n    atlas2.setMeshFrame(pmesh, fr)\n  }else{\n    atlas.setMeshFrame(pmesh, fr)\n  }\n  if (game.inputs.state.left) facing = -1\n  if (game.inputs.state.right) facing = 1\n  pmesh.scaling.x = vw * facing\n})\n\n\n/*\n *    spawn some simple \"mob\" entities\n*/\n\n\nfor (var i = 0; i < numMobs; ++i) {\n  var size = 1 + Math.random() * 2\n  var x = (250 + 50 * Math.random()) //* (Math.random() > 0.5 ? 1 : -1)\n  var y = 50 + 8 * Math.random()\n  var z = (250 + 50 * Math.random()) //* (Math.random() > 0.5 ? 1 : -1)\n  createMob(game, atlas, size, size, x, y, z)\n}\n\n\n\n\n\n/*\n *      Set inputs to get/set blocks on L/M/R mouse click\n*/\n\n// on left mouse, set targeted block to be air\ngame.inputs.down.on('fire', function () {\n  // skip click if just gaining pointer lock\n  var cont = game.container\n  if (!cont.hasPointerLock && cont.supportsPointerLock) return\n\n  var tgt = game.targetedBlock\n  if (tgt) {\n    var loc = tgt.position\n    // if slide is showing and it has an onclick\n    if (tgt.blockID === game.slideBlockID) {\n      var dat = slides.slideData.filter(o => {\n        return (o.x === loc[0] && o.y === loc[1] && o.z === loc[2])\n      })[0]\n      if (dat && dat.onclick) {\n        dat.onclick()\n      }\n      return\n    }\n    game.setBlock(0, loc)\n    // smoke for removed block\n    var parts = addParticles('blocksmoke')\n    parts.mesh.position.copyFromFloats(loc[0] + 0.5, loc[1] + 0.5, loc[2] + 0.5)\n  }\n})\n\n// on middle mouse, remember type of targeted block\nvar placeBlockID = 1\ngame.inputs.down.on('mid-fire', function () {\n  var tgt = game.targetedBlock\n  if (tgt) {\n    var loc = tgt.position\n    var props = game.world.getBlockProperties(loc[0], loc[1], loc[2])\n    if (props && props.slide) return\n    placeBlockID = game.getBlock(loc);\n  }\n})\n\n// on right mouse, place remembered block adjacent to target\ngame.inputs.down.on('alt-fire', function () {\n  var tgt = game.targetedBlock\n  if (tgt) {\n    var loc = tgt.adjacent\n    game.addBlock(placeBlockID, loc); // addBlock works only if spot is clear\n  }\n})\n\n/**  bind \"i\" key to invert mouse\ngame.inputs.bind('invertY', 'I')\ngame.inputs.down.on('invertY', function () {\n  game.controls.inverseY = !game.controls.inverseY\n})\n*/\n\n// toggle pointerlock on \"L\"\ngame.inputs.bind('toggleLock', 'L')\ngame.inputs.down.on('toggleLock', function () {\n  var locked = game.container.hasPointerLock\n  game.container.setPointerLock(!locked)\n})\n\n\n// toggle pause on \"P\"\nvar paused = false\ngame.inputs.bind('togglePause', 'P')\ngame.inputs.down.on('togglePause', function () {\n  paused = !paused\n  game.setPaused(paused)\n})\n\n\n/*\n *  Minimal 'UI' (help menu) and a button to toggle it\n*/\n\n// createUI(game)\n\n\n\n/*\n *  A couple of sample 'spells' that create entities and do stuff\n*/\n\n\ngame.inputs.bind('blockbomb', '1')\ngame.inputs.down.on('blockbomb', function () {\n  launchProjectile(1, 0.1, 0.5, 0, 0, placeBlockID)\n})\n\ngame.inputs.bind('timebomb', '2')\ngame.inputs.down.on('timebomb', function () {\n  launchProjectile(2, 0.5, 1.5, 10, 0.25)\n})\n\n// hover-pack code in module\ncreateHover(game, addParticles)\n\n\n\n\n/*\n *    ;  - Run a profile for 200 ticks\n *    '  - Run a profile for 200 renders\n*/\n\ngame.inputs.bind('profileTick', ';')\ngame.inputs.bind('profileRender', \"'\")\ngame.inputs.down.on('profileTick', function () {\n  if (!profiling) startProfile(true)\n})\ngame.inputs.down.on('profileRender', function () {\n  if (!profiling) startProfile(false)\n})\ngame.on('tick', function () {\n  if (!profileTick) return\n  if (++pct >= 200) { endProfile() }\n})\ngame.on('render', function () {\n  if (!profileRender) return\n  if (++pct >= 200) { endProfile() }\n})\n\nvar profiling = false\nvar profileTick = false, profileRender = false\nvar pnum = 0\nvar pct = 0\nvar t\nfunction startProfile(isTick) {\n  profiling = true\n  if (isTick) { profileTick = true } else { profileRender = true }\n  pnum++\n  pct = 0\n  var s = (profileTick) ? '200 ticks - ' : '200 renders - '\n  console.profile(s + pnum)\n  t = performance.now()\n}\nfunction endProfile() {\n  var s = (profileTick) ? '200 ticks - ' : '200 renders - '\n  console.profileEnd(s + pnum)\n  profiling = false\n  profileTick = false\n  profileRender = false\n  console.log('end', pct, 'time: ', (performance.now() - t).toFixed(2))\n}\n\n\n\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/lib/hover.js":
/*!**************************!*\
  !*** ./src/lib/hover.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function(game, particleAdder) {\n  return new Hover(game, particleAdder)\n}\n\n\n\n/*\n *    Keybind and implementation for hover-pack thingy to get around better\n*/\n\n\nfunction Hover(game, particleAdder) {\n  var hovering = false\n  var parts = particleAdder('jetpack')\n  parts.parent = game.ents.getMeshData(game.playerEntity).mesh\n\n  game.inputs.bind('hover', 'R')\n  game.inputs.down.on('hover', function() {\n    hovering = true;\n    parts.rate = 100;\n    parts.start();\n  })\n  game.inputs.up.on('hover', function() {\n    hovering = false;\n    parts.rate = 0;\n  })\n\n  game.on('tick', function(dt) {\n    if (hovering) hover(game);\n  })\n}\n\n\n\n\nfunction hover(game) {\n  var b = game.playerBody\n  var f = (b.velocity[1] < 0) ? 40 : 24\n  b.applyForce([0, f, 0])\n}\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/lib/hover.js?");

/***/ }),

/***/ "./src/lib/mob.js":
/*!************************!*\
  !*** ./src/lib/mob.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* globals BABYLON */\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\")\n\nmodule.exports = createMob\n\n\nvar atlas = null\nvar stand_frame = 'mob_stand.png'\nvar jump_frame = 'mob_jump.png'\n\nfunction createMob( game, _atlas, w, h, x, y, z ) {\n  var scene = game.rendering.getScene()\n  atlas = _atlas\n\n  var mesh = atlas.makeSpriteMesh( stand_frame )\n  mesh.scaling = new BABYLON.Vector3(w, h, 1)\n  mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_Y\n  \n  var offset = [0, h/2, 0]\n  var dat = { lastHit:0 }\n  \n  // add an entity for the \"mob\"\n  var ent = game.entities.add(\n    [x,y,z],              // starting loc\n    w, h, mesh, offset,   // size, mesh, mesh offset\n    true, true            // do physics, isSprite\n  )\n  var body = game.ents.getPhysicsBody(ent)\n  body.friction = 5\n  body.gravityMultiplier = 1.5\n  game.on('tick', function(dt) {\n    mobTick(dt, body, mesh)\n  })\n  // on('collideEntity', collideEntity.bind(ent, game))\n}\n\nfunction collideEntity(game, other) {\n  /* jshint validthis:true */\n  if (other==game.playerEntity) {\n    var d = new Date()\n    if (d-this.data.lastHit < 400) return\n    this.data.lastHit = d\n    // repulse along relative vector, angled up a bit\n    var v = vec3.create()\n    vec3.subtract(v, other.getPosition(), this.getPosition() )\n    vec3.normalize(v, v)\n    v[1] = 1\n    vec3.scale(v, v, 15)\n    other.body.applyImpulse(v)\n  }\n}\n\nfunction mobTick(dt, body, mesh) {\n  var onground = body.resting[1] < 0\n  var fr = (onground) ? stand_frame : jump_frame\n  atlas.setMeshFrame(mesh, fr)\n  \n  if (onground && Math.random() < .01) {   // jump!\n    var x = 4-8*Math.random()\n    var z = 4-8*Math.random()\n    var y = 7+5*Math.random()\n    body.applyImpulse([x,y,z])\n  }\n}\n\n\n\n\n\n//# sourceURL=webpack:///./src/lib/mob.js?");

/***/ }),

/***/ "./src/lib/particles.js":
/*!******************************!*\
  !*** ./src/lib/particles.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* globals BABYLON */\n\nvar MPS = __webpack_require__(/*! mesh-particle-system */ \"./node_modules/mesh-particle-system/index.js\")\n\n\nmodule.exports = function(game) {\n  return makeParticleGenerator(game)\n}\n\n// remember that Babylon uses a Vector3 class that's unlike gl-vec3\nvar vec3 = BABYLON.Vector3\nvar col3 = BABYLON.Color3\n\n\n/*\n *    Generate a function to manage mesh-particle-system library\n*/\n\n\nfunction makeParticleGenerator(game) {\n  var scene = game.rendering.getScene()\n\n  var puffTex = new BABYLON.Texture('textures/puff.png', scene, true, false, 1)\n  var gradTex = new BABYLON.Texture('textures/particle_standard.png', scene, true, false)\n\n  var opts = {}\n\n  opts.blocksmoke = {\n    cap: 50\n    , g: 0\n    , emit: 50\n    , rate: 0\n    , tex: puffTex\n    , alphas: [1, 0]\n    , colors: [ col3.White(), col3.White() ]\n    , sizes: [1, 0.5]\n    , init: function(p) {\n      p.position.x = Math.random() * 0.8 - 0.4\n      p.position.y = Math.random() * 0.8 - 0.4\n      p.position.z = Math.random() * 0.8 - 0.4\n      p.velocity.x = p.position.x / 2\n      p.velocity.y = p.position.y / 2\n      p.velocity.z = p.position.z / 2\n      p.size =       0.5\n      p.age = Math.random()/2\n      p.lifetime =   0.6\n    }\n  }\n\n\n  opts.bombsmoke = {\n    cap: 250\n    , g: 0\n    , emit: 250\n    , rate: 0\n    , tex: puffTex\n    , alphas: [1, 0]\n    , colors: [ col3.White(), col3.White() ]\n    , sizes: [1, 0.5]\n    , init: function(p, radius) {\n      // per gl-vec3#random\n      var scale = 2.5\n      var r = Math.random() * 2.0 * Math.PI\n      var z = (Math.random() * 2.0) - 1.0\n      var zScale = Math.sqrt(1.0-z*z) * scale\n      p.position.x = Math.cos(r) * zScale\n      p.position.y = Math.sin(r) * zScale\n      p.position.z = z * scale\n      p.velocity.x = Math.random() - 0.5\n      p.velocity.y = Math.random() - 0.5\n      p.velocity.z = Math.random() - 0.5\n      p.size =       0.5\n      p.age =        Math.random() * 0.4\n      p.lifetime =   0.8\n    }\n  }\n\n\n  opts.jetpack = {\n    cap: 100\n    , g: -3\n    , emit: 0\n    , rate: 100\n    , tex: gradTex\n    , alphas: [0.6, 0]\n    , colors: [ new col3( 1, .1, .1), new col3(.9, .9, .1) ]\n    , sizes: [0.9, 1]\n    , init: function(p) {\n      p.position.x = 0\n      p.position.y = Math.random() * -0.4 - 0.4\n      p.position.z = 0\n      p.velocity.x = Math.random() * 2 - 1\n      p.velocity.y = Math.random() * -1 - 1\n      p.velocity.z = Math.random() * 2 - 1\n      p.size =       Math.random() * 0.75 + 0.5\n      p.age = 0\n      p.lifetime = 0.6\n    }\n  }\n\n  opts.sparks = {\n    cap: 200\n    , g: -5\n    , emit: 0\n    , rate: 100\n    , tex: gradTex\n    , alphas: [0.6, 0]\n    , colors: [ new col3( 1, .1, .1), new col3(.9, .9, .1) ]\n    , sizes: [.1, .01]\n    , init: function(p) {\n      p.position.x = 0\n      p.position.y = 0.4\n      p.position.z = 0\n      p.velocity.x = Math.random() * 4 - 2\n      p.velocity.y = Math.random() * 4 + 1\n      p.velocity.z = Math.random() * 4 - 2\n      p.size =       Math.random() + 1\n      p.age = 0\n      p.lifetime = 1.5\n    }\n  }\n\n\n  opts.smoketrail = {\n    cap: 100\n    , g: 5\n    , emit: 0\n    , rate: 200\n    , tex: gradTex\n    , alphas: [0.9, 0]\n    , colors: [ col3.White(), col3.White() ]\n    , sizes: [0.9, 1]\n    , init: function(p) {\n      //      p.velocity.x = Math.random() * 2 - 1\n      //      p.velocity.y = Math.random() * 2 - 1\n      //      p.velocity.z = Math.random() * 2 - 1\n      p.size =       Math.random() * 0.5 + 0.1\n      p.age = 0\n      p.lifetime = 0.5\n    }\n  }\n\n\n\n\n  return function (type) {\n\n    var o = opts[type]\n    if (!o) return\n    var mps = new MPS(o.cap, o.rate, o.tex, scene)\n    mps.gravity = o.g\n    mps.setAlphaRange( o.alphas[0], o.alphas[1] )\n    mps.setColorRange( o.colors[0], o.colors[1] )\n    mps.setSizeRange( o.sizes[0], o.sizes[1] )\n    mps.initParticle = o.init\n    mps.stopOnEmpty = true\n\n    if (o.emit) {\n      mps.emit(o.emit)\n      mps.disposeOnEmpty = true\n    }\n\n    game.rendering.addMeshToScene(mps.mesh, false)\n\n    return mps\n  }\n}\n\n\n\n\n//# sourceURL=webpack:///./src/lib/particles.js?");

/***/ }),

/***/ "./src/lib/projectile.js":
/*!*******************************!*\
  !*** ./src/lib/projectile.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* globals BABYLON */\n\nvar vec3 = __webpack_require__(/*! gl-vec3 */ \"./node_modules/gl-vec3/index.js\")\n\nmodule.exports = function(game, partAdder) {\n  return makeProjectileLauncher(game, partAdder)\n}\n\n\n/*\n *    example \"spells\" that create entities on keypress\n*/\n\n\nfunction makeProjectileLauncher(game, particleAdder) {\n  var scene = game.rendering.getScene()\n  var baseMesh = BABYLON.Mesh.CreateSphere('p1', 3, 1, scene)\n  baseMesh.material = makeColorMat(scene, .1, .1, .1)\n  // game.registry.registerMesh('projectile', mesh)\n\n\n  return function(spelltype, size, gravMult, friction, restitution, option) {\n    var s = size || 1    \n    var mesh = game.rendering.makeMeshInstance(baseMesh)\n    mesh.scaling.x = mesh.scaling.y = mesh.scaling.z = s\n    var scene = game.rendering.getScene()\n    var pos = game.getPlayerEyePosition()\n    \n    // projectile entity\n    // usage: entities.add( pos, w, h, mesh, meshOffset, doPhysics, shadow )\n    var id = game.entities.add( pos, s, s, mesh, [s/2,s/2,s/2], true, true )\n    \n    // data for the projectile\n    var dat = {}\n\n    // adjust physics properties thusly\n    var body = game.ents.getPhysicsBody(id)\n    body.gravityMultiplier = gravMult\n    body.friction = friction\n    body.restitution = restitution\n\n\t\tgame.entities.addComponent(id, game.entities.names.collideTerrain, {\n\t\t\tcallback: function (impulse) {\n        onCollide(game, dat)\n      }\n    })\n    var tickFn = function(dt) {\n      onTick(game, dat, dt)\n    }\n    game.on('tick', tickFn)\n\n    // flashy particle trail dependent on type\n    var off = (spelltype===1) ? [0,0,0] : [0,s/2,0]\n    var vol = (spelltype===1) ? s/2 : 0\n    var partType = (spelltype===1) ? 'smoketrail' : 'sparks'\n    var parts = particleAdder(partType)\n    \n    parts.disposeOnEmpty = true\n    parts.parent = mesh\n    parts.start()\n    \n    dat.parts = parts\n    dat.particleAdder = particleAdder\n    dat.counter = 0\n    dat.option = option\n    dat.id = id\n    dat.spelltype = spelltype\n\n    dat.remove = function() {\n      game.ents.deleteEntity(id)\n      parts.rate = 0\n      game.removeListener('tick', tickFn)\n    }\n\n    launchAlongCameraVector(game, body, 10)\n  }\n\n\n}\n\n/*\n *    Projectile tick/collide fcns\n*/ \n\nfunction onCollide(game, dat) {\n  if (dat.spelltype==2) return\n  var pos = game.ents.getPosition(dat.id)\n  dat.remove()\n  // do blocks afterwards so entity doesn't collide them\n  addBlocksInSphere(game, dat.option, pos, 2.3)\n}\n\nfunction onTick(game, dat, dt) {\n  if (dat.spelltype==1) return\n  dat.counter += dt\n  //  var blinker = (ct/250>>0) % 2\n  //  entity.mesh.material.diffuseColor.r = (blinker) ? 1 : 0.1\n  if (dat.counter > 2500) { // blow up\n    var pos = game.ents.getPosition(dat.id)\n    addBlocksInSphere(game, 0, pos, 2.75)\n    dat.parts.rate = 0\n    // add smoke\n    var smokeParts = dat.particleAdder('bombsmoke')\n    smokeParts.mesh.position.copyFromFloats( pos[0], pos[1]+0.5, pos[2] )\n    // done\n    dat.remove()\n  }\n}\n\n\n\n\n/*\n *    Helper functions\n*/ \n\nfunction makeColorMat(scene, r, g, b) {\n  var m = new BABYLON.StandardMaterial('m',scene)\n  m.diffuseColor = new BABYLON.Color3(r,g,b)\n  return m\n}\n\nfunction launchAlongCameraVector(game, body, impulse) {\n  var vec = game.getCameraVector()\n  vec3.normalize(vec, vec)\n  vec3.scale(vec, vec, impulse)\n  body.applyImpulse(vec)\n}\n\nfunction addBlocksInSphere(game, id, pos, radius) {\n  var scene = game.rendering.getScene()\n  var loc = pos.map(Math.floor)\n  var rad = Math.ceil(radius)\n  for (var i=-rad; i<=rad; ++i) {\n    for (var j=-rad; j<=rad; ++j) {\n      for (var k=-rad; k<=rad; ++k) {\n        if (i*i + j*j + k*k <= radius*radius) {\n          game.addBlock( id, i+loc[0], j+loc[1], k+loc[2] )\n        }\n      }\n    }\n  }\n}\n\n\n//# sourceURL=webpack:///./src/lib/projectile.js?");

/***/ }),

/***/ "./src/lib/slides.js":
/*!***************************!*\
  !*** ./src/lib/slides.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar slides = {}\nmodule.exports = slides\nslides.slideData = []\n\n\n/*\n *  Define the 'slides' and where they go, what they do, etc.\n*/\n\nvar baseX = 250\nvar baseY = 31\nvar baseZ = 250\n\n\nadd( 'intro1',   1,  0, 1  )\n\nadd( 'intro3',   -5,  0,  -5,     openlink.bind(null, 'twit') )\n\n\n\nfunction openlink(name) {\n  var urls = {\n    twit:   'https://twitter.com/metamapsnft',\n   \n  }\n  if (urls[name]) {\n    window.open(urls[name], '_blank')\n  } else {\n    console.log(name,'???')\n  }\n}\n\n\nvar mutey = 5\nfunction muteWorld(x, z) {\n  for (var y=-5; y<mutey; ++y) {\n    noa.setBlock(1,x,y,z+5)\n  }\n  mutey+=2\n}\n\n\n\n\n/*\n *  Logic below\n*/\n\n// add a slide to the exported array\nfunction add(id, x, y, z, onclick) {\n  baseX += x\n  baseY += y\n  baseZ += z\n  slides.slideData.push({\n    id: id,\n    // coords are offset by base location matched to worldgen\n    x: baseX, \n    y: baseY, \n    z: baseZ,\n    onclick:onclick || null,\n  })\n}\n\n\n                        \n                        \n// All slides start out hidden\n\n// accessor functions to show/hide them:\n\nvar currslide = null\nslides.showSlide = function(id) {\n  if (currslide===id) return\n  slides.hideSlide()\n  var el = document.getElementById(id)\n  if (el) {\n    setElementVisibility(el, true)\n    currslide = id\n  }\n}\n\n\nslides.hideSlide = function() {\n  if (!currslide) return\n  setElementVisibility(document.getElementById(currslide), false)\n  currslide = null\n}\n\n\n\nfunction setElementVisibility(el, vis) {\n  if (vis) el.style.display = \"flex\"\n  else el.style.display = \"none\";\n}\n\n\n\n\n//# sourceURL=webpack:///./src/lib/slides.js?");

/***/ }),

/***/ "./src/lib/ui.js":
/*!***********************!*\
  !*** ./src/lib/ui.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function(game) {\n  return new UI(game)\n}\n\n\n\n/*\n *    minimal UI management (help menu)\n*/\n\n\nfunction UI(game) {\n  var toggled = false\n  var showing = true\n  \n  game.inputs.bind('help', 'H')\n  game.inputs.down.on('help', function() {\n    toggled = true\n    showing = !showing\n    setVis(showing)\n  })\n  \n  game.container.on('gainedPointerLock', function() {\n    if (toggled) return\n    showing = false\n    setVis(showing)\n  })\n  game.container.on('lostPointerLock', function() {\n    if (toggled) return\n    showing = true\n    setVis(showing)\n  })\n}\n\n\nfunction setVis(show) {\n  var el = document.getElementById('help')\n  el.hidden = !show\n}\n\n\n\n\n//# sourceURL=webpack:///./src/lib/ui.js?");

/***/ }),

/***/ "./src/lib/worldgen.js":
/*!*****************************!*\
  !*** ./src/lib/worldgen.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/* globals BABYLON */\n\nvar url_stringz = window.location.href\nvar urlz = new URL(url_stringz);\nvar idz = urlz.searchParams.get(\"id\");\n\n\n//var SimplexNoise = require('simplex-noise')\n//var simplex = new SimplexNoise()\n//var hash = require('ndhash')\nvar ndarray = __webpack_require__(/*! ndarray */ \"./node_modules/ndarray/ndarray.js\")\nvar Worker = __webpack_require__(/*! ./worldgen_worker */ \"./src/lib/worldgen_worker.js\")\n\nmodule.exports = function setupFunction(game, slideData) {\n  registerBlocks(game)\n  initSpecials(game, slideData)\n  initWorldGen(game)\n}\n\n\nvar _blockID = 1\nfunction getBlockID() {\n  return _blockID++\n}\n\n\n/*\n *      Slides/slide block-related setup\n*/\n\n\nfunction initSpecials(game, slides) {\n  var reg = game.registry\n\n  // block mat for slide blocks\n  reg.registerMaterial('slide', [1, 0.1, 0.05])\n  reg.registerMaterial('block-face', [0, 0, 0], 'block-face.png')\n  reg.registerMaterial('block-top', [0, 0, 0], 'block-top.png')\n  reg.registerMaterial('block-bot', [0, 0, 0], 'block-bot.png')\n  reg.registerMaterial('block-side', [0, 0, 0], 'block-side.png')\n\n  // slides is array of data objects\n  var mats = ['block-side', 'block-side', 'block-top', 'block-bot', 'block-side', 'block-face']\n  var blockid = reg.registerBlock(getBlockID(), {\n    material: mats,\n  })\n\n  // ad-hoc - decorate game object with block ID\n  game.slideBlockID = blockid\n\n  slides.map(function (s) {\n    addOverlay(blockid, s.x, s.y, s.z)\n  })\n\n  // add player platform\n\n  function overlayRect(id, x0, x1, y0, y1, z0, z1) {\n    for (var x = x0; x < x1; x++) {\n      for (var y = y0; y < y1; y++) {\n        for (var z = z0; z < z1; z++) {\n          addOverlay(id, x, y, z)\n        }\n      }\n    }\n  }\n\n  overlayRect(0, 245, 255, 32, 32, 245, 255)\n  overlayRect(stoneID, 245, 255, 30, 31, 245, 255)\n  //overlayRect(stoneID, -1, 42, -10, 1, -1, 4)\n\n}\n\nvar special_overlays = []\n\nfunction addOverlay(id, x, y, z) {\n  if (!special_overlays[x]) special_overlays[x] = []\n  if (!special_overlays[x][y]) special_overlays[x][y] = []\n  special_overlays[x][y][z] = id\n}\n\n// used by generateWorld\nfunction getOverlay(x, y, z) {\n  if (!special_overlays[x]) return -1\n  if (!special_overlays[x][y]) return -1\n  return special_overlays[x][y][z]\n}\n\n\n\n// random color generation - last minute hack\nvar please = __webpack_require__(/*! pleasejs */ \"./node_modules/pleasejs/dist/Please.js\")\nfunction getColor() {\n  var res = please.make_color()\n  // returns array of one color in \"#ffffff\" format\n  var hex = res[0].substring(1)\n  var num = parseInt(hex, 16)\n  var r = (num & 0xFF0000) >> 16\n  var g = (num & 0xFF00) >> 8\n  var b = (num & 0xFF)\n  return [r / 255, g / 255, b / 255]\n}\n\n\n\n\n/*\n *   Block registration - register blocktypes used in world\n*/\n\n\n\nvar dirtID, grassID, stoneID, sandID, block1ID, cloudID, leafID, flowerID, woodID, waterID\nvar plant1ID, plant2ID, plant3ID, plant4ID, plant5ID, treasureID\n\n\nfunction registerBlocks(game) {\n  var reg = game.registry\n\n  // materials used by block faces\n  reg.registerMaterial('dirt', [0.45, 0.36, 0.22], 'dirt.png')\n  reg.registerMaterial('grass', [0.22, 0.38, 0.01], 'grass.png')\n  reg.registerMaterial('grass_side', [0.30, 0.34, 0.09], 'grass_dirt.png')\n  reg.registerMaterial('stone', [0.50, 0.50, 0.50], 'cobblestone.png')\n  reg.registerMaterial('sand', [0.50, 0.50, 0.50], 'sand.png')\n  reg.registerMaterial('leaf', [0.31, 0.45, 0.03], 'leaf.png', true)\n  reg.registerMaterial('wood_face', [0.60, 0.50, 0.10], 'wood_face.png')\n  reg.registerMaterial('wood_side', [0.55, 0.45, 0.05], 'wood_side.png')\n  reg.registerMaterial('water', [0.20, 0.85, 0.95, 0.5], null)\n  for (var i = 1; i < 30; i++) {\n    var color = getColor()\n    reg.registerMaterial('color' + i, color, null)\n  }\n  reg.registerMaterial('white', [1, 1, 1, 0.5], null)\n  reg.registerMaterial('flowerMat', [1, 1, 1], null)\n  reg.registerMaterial('objMat', [1, 1, 1], null)\n\n  // block types and the faces they use\n\n  dirtID = reg.registerBlock(getBlockID(), { material: 'dirt' })\n  grassID = reg.registerBlock(getBlockID(), { material: ['grass', 'dirt', 'grass_side'] })\n  stoneID = reg.registerBlock(getBlockID(), { material: 'stone' })\n  sandID = reg.registerBlock(getBlockID(), { material: 'sand' })\n  leafID = reg.registerBlock(getBlockID(), { material: 'leaf', opaque: false })\n  cloudID = reg.registerBlock(getBlockID(), { material: 'white' })\n  woodID = reg.registerBlock(getBlockID(), { material: ['wood_face', 'wood_face', 'wood_side'] })\n  var waterprop = { material: 'water', fluid: true, fluidDensity: 1.0, viscosity: 0.5 }\n  waterID = reg.registerBlock(getBlockID(), waterprop)\n\n  /*\n  for (i = 1; i < 40; i++) {\n    var id = getBlockID()\n    if (i === 1) block1ID = id\n    reg.registerBlock(id, { material: 'color' + i })\n  } */\n\n  // create a custom mesh to be used for occurrences of the block\n  var scene = game.rendering.getScene()\n\n  /**\n  var flowerMesh = makeFlowerSpriteMesh(scene, 'textures/flower.png', 'flower')\n\n  // object blocks - i.e. non-terrain\n  flowerID = reg.registerBlock(getBlockID(), {\n    solid: false,\n    opaque: false,\n    blockMesh: flowerMesh,\n    material: 'flowerMat',\n    onCustomMeshCreate: function (mesh) {\n      mesh.rotation.y = Math.random() * Math.PI * 2\n    }\n  })\n */\n  \n  \n\n  \n  var treasureMesh = makeObjMesh(scene, 'textures/6.png', 'treasure')\n  treasureID = reg.registerBlock(getBlockID(), {solid: false ,opaque: false,blockMesh: treasureMesh,\n        material: 'objMat'\n      })\n\n\n  /*\nvar plantMesh17 = makeFlowerSpriteMesh(scene, 'textures/crystal.png', 'plant17')\nplant17ID = reg.registerBlock(getBlockID(), {solid: false,opaque: false,blockMesh: plantMesh17,\n      material: 'flowerMat', onCustomMeshCreate: function (mesh) {\n        mesh.rotation.y = Math.random() * Math.PI * 2\n      }\n    })\n\nvar plantMesh18 = makeFlowerSpriteMesh(scene, 'textures/emerald.png', 'plant18')\nplant18ID = reg.registerBlock(getBlockID(), {solid: false,opaque: false,blockMesh: plantMesh18,\n      material: 'flowerMat', onCustomMeshCreate: function (mesh) {\n        mesh.rotation.y = Math.random() * Math.PI * 2\n      }\n    })\n\n\n*/\n\n  var plantMesh1 = makeFlowerSpriteMesh(scene, 'textures/1.png', 'plant1')\nplant1ID = reg.registerBlock(getBlockID(), {solid: false,opaque: false,blockMesh: plantMesh1,\n      material: 'flowerMat', onCustomMeshCreate: function (mesh) {\n        mesh.rotation.y = Math.random() * Math.PI * 2\n      }\n    })\n\nvar plantMesh2 = makeFlowerSpriteMesh(scene, 'textures/2.png', 'plant2')\nplant2ID = reg.registerBlock(getBlockID(), {solid: false,opaque: false,blockMesh: plantMesh2,\n      material: 'flowerMat', onCustomMeshCreate: function (mesh) {\n        mesh.rotation.y = Math.random() * Math.PI * 2\n      }\n    })\n\nvar plantMesh3 = makeFlowerSpriteMesh(scene, 'textures/3.png', 'plant3')\nplant3ID = reg.registerBlock(getBlockID(), {solid: false,opaque: false,blockMesh: plantMesh3,\n      material: 'flowerMat', onCustomMeshCreate: function (mesh) {\n        mesh.rotation.y = Math.random() * Math.PI * 2\n      }\n    })\n\nvar plantMesh4 = makeFlowerSpriteMesh(scene, 'textures/4.png', 'plant4')\nplant4ID = reg.registerBlock(getBlockID(), {solid: false,opaque: false,blockMesh: plantMesh4,\n      material: 'flowerMat', onCustomMeshCreate: function (mesh) {\n        mesh.rotation.y = Math.random() * Math.PI * 2\n      }\n    })\n\nvar plantMesh5 = makeFlowerSpriteMesh(scene, 'textures/5.png', 'plant5')\nplant5ID = reg.registerBlock(getBlockID(), {solid: false,opaque: false,blockMesh: plantMesh5,\n      material: 'flowerMat', onCustomMeshCreate: function (mesh) {\n        mesh.rotation.y = Math.random() * Math.PI * 2\n      }\n    })\n\n  \n}\n\n\n\n\n/*\n *   Worldgen - simple terrain/cloud generator\n*/\n\n\nfunction initWorldGen(game) {\n  // set up worldgen web worker\n  var worker = new Worker()\n\n  // send block id values to worker\n  worker.postMessage({\n    msg: idz\n  })\n\n  worker.postMessage({\n    msg: 'init',\n    ids: getBlockIDObject()\n  })\n\n  \n  // game listener for when worldgen is requested (array is an ndarray)\n  game.world.on('worldDataNeeded', function (id, array, x, y, z) {\n    worker.postMessage({\n      msg: 'generate',\n      data: array.data,\n      shape: array.shape,\n      id: id,\n      x: x, y: y, z: z,\n    })\n  }) \n\n  // worker listener for when chunk generation is finished\n  worker.addEventListener('message', function (ev) {\n    if (ev.data.msg == 'generated') {\n      // wrap result (copied from worker) in a new ndarray before returning\n      var id = ev.data.id\n      var array = new ndarray(ev.data.data, ev.data.shape)\n      // send result to game for processing\n      game.world.setChunkData(id, array)\n    }\n  })\n\n}\n\n\nfunction getBlockIDObject() {\n  return {\n    dirtID: dirtID,\n    grassID: grassID,\n    stoneID: stoneID,\n    sandID: sandID,\n    block1ID: block1ID,\n    cloudID: cloudID,\n    leafID: leafID,\n    flowerID: flowerID,\n    woodID: woodID,\n    waterID: waterID,\n    plant1ID: plant1ID,\n    plant2ID: plant2ID,\n    plant3ID: plant3ID,\n    plant4ID: plant4ID,\n    plant5ID: plant5ID,\n    treasureID: treasureID,\n    overlays: special_overlays,\n  }\n}\n\n\n\n\n\n\n\n\n// helper function to make a billboard plane mesh showing a given sprite texture\nfunction makeFlowerSpriteMesh(scene, url, name) {\n  var matname = name || 'sprite-mat'\n  var tex = new BABYLON.Texture(url, scene, true, true,\n    BABYLON.Texture.NEAREST_SAMPLINGMODE)\n  tex.hasAlpha = true\n  var mesh = BABYLON.Mesh.CreatePlane('sprite-' + matname, 1, scene)\n  var mat = new BABYLON.StandardMaterial('sprite-mat-' + matname, scene)\n  mat.specularColor = new BABYLON.Color3(0, 0, 0)\n  mat.emissiveColor = new BABYLON.Color3(1, 1, 1)\n  mat.backFaceCulling = false\n  mat.diffuseTexture = tex\n  mesh.material = mat\n\n  var offset = BABYLON.Matrix.Translation(0, 0.5, 0)\n  mesh.bakeTransformIntoVertices(offset)\n  var clone = mesh.clone()\n  clone.rotation.y += 0.7\n\n  return BABYLON.Mesh.MergeMeshes([mesh, clone], true)\n}\n\n\nfunction makeObjMesh(scene, url, name) {\n  var matname = name || 'sprite-mat'\n  var tex = new BABYLON.Texture(url, scene, true, true,\n    BABYLON.Texture.NEAREST_SAMPLINGMODE)\n  tex.hasAlpha = true //transparent colour!\n  //var mesh = atlas.makeSpriteMesh( 'sprite-' + matname )\n  var mesh = BABYLON.Mesh.CreatePlane('sprite-' + matname, 1, scene)\n  mesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_Y\n  \n  \n  \n  var mat = new BABYLON.StandardMaterial('sprite-mat-' + matname, scene)\n  mat.specularColor = new BABYLON.Color3(0, 0, 0)\n  mat.emissiveColor = new BABYLON.Color3(1, 1, 1)\n  mat.backFaceCulling = false\n  mat.diffuseTexture = tex\n  mesh.material = mat\n  \n  var offset = BABYLON.Matrix.Translation(0, 0.5, 0)\n  mesh.bakeTransformIntoVertices(offset)\n  \n\n  return mesh\n}\n\nfunction makeObjMesh2() {\n  // Create a sprite manager\n  var spriteManagerTrees = new BABYLON.SpriteManager(\"treesManagr\", \"Assets/Palm-arecaceae.png\", 2000, 800, scene);\n  var spriteManagerPlayer = new BABYLON.SpriteManager(\"playerManagr\",\"Assets/Player.png\", 2, 64, scene);\n\n  var playerInstance = new BABYLON.Sprite(\"player\", spriteManagerPlayer);\n}\n\n/*var pmesh = atlas.makeSpriteMesh(stand_frame)\n\nvar ph = opts.playerHeight,\n  pw = opts.playerWidth\n\n// visual width of sprite slightly wider than hitbox\nvar vw = pw * 1.25\n\nvar stand_frame = 'player_stand.png'\nvar jump_frame = 'player_jump.png'\n\npmesh.scaling = new BABYLON.Vector3(vw, ph, 1)\npmesh.billboardMode = BABYLON.Mesh.BILLBOARDMODE_Y\ngame.ents.addComponent(game.playerEntity, game.ents.names.mesh, {\n  mesh: pmesh,\n  offset: [0, ph/2, 0],\n}) */\n\n//# sourceURL=webpack:///./src/lib/worldgen.js?");

/***/ }),

/***/ "./src/lib/worldgen_worker.js":
/*!************************************!*\
  !*** ./src/lib/worldgen_worker.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function() {\n  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ \"./node_modules/worker-loader/dist/workers/InlineWorker.js\")(\"/******/ (function(modules) { // webpackBootstrap\\n/******/ \\t// The module cache\\n/******/ \\tvar installedModules = {};\\n/******/\\n/******/ \\t// The require function\\n/******/ \\tfunction __webpack_require__(moduleId) {\\n/******/\\n/******/ \\t\\t// Check if module is in cache\\n/******/ \\t\\tif(installedModules[moduleId]) {\\n/******/ \\t\\t\\treturn installedModules[moduleId].exports;\\n/******/ \\t\\t}\\n/******/ \\t\\t// Create a new module (and put it into the cache)\\n/******/ \\t\\tvar module = installedModules[moduleId] = {\\n/******/ \\t\\t\\ti: moduleId,\\n/******/ \\t\\t\\tl: false,\\n/******/ \\t\\t\\texports: {}\\n/******/ \\t\\t};\\n/******/\\n/******/ \\t\\t// Execute the module function\\n/******/ \\t\\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\\n/******/\\n/******/ \\t\\t// Flag the module as loaded\\n/******/ \\t\\tmodule.l = true;\\n/******/\\n/******/ \\t\\t// Return the exports of the module\\n/******/ \\t\\treturn module.exports;\\n/******/ \\t}\\n/******/\\n/******/\\n/******/ \\t// expose the modules object (__webpack_modules__)\\n/******/ \\t__webpack_require__.m = modules;\\n/******/\\n/******/ \\t// expose the module cache\\n/******/ \\t__webpack_require__.c = installedModules;\\n/******/\\n/******/ \\t// define getter function for harmony exports\\n/******/ \\t__webpack_require__.d = function(exports, name, getter) {\\n/******/ \\t\\tif(!__webpack_require__.o(exports, name)) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\\n/******/ \\t\\t}\\n/******/ \\t};\\n/******/\\n/******/ \\t// define __esModule on exports\\n/******/ \\t__webpack_require__.r = function(exports) {\\n/******/ \\t\\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\\n/******/ \\t\\t\\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\\n/******/ \\t\\t}\\n/******/ \\t\\tObject.defineProperty(exports, '__esModule', { value: true });\\n/******/ \\t};\\n/******/\\n/******/ \\t// create a fake namespace object\\n/******/ \\t// mode & 1: value is a module id, require it\\n/******/ \\t// mode & 2: merge all properties of value into the ns\\n/******/ \\t// mode & 4: return value when already ns object\\n/******/ \\t// mode & 8|1: behave like require\\n/******/ \\t__webpack_require__.t = function(value, mode) {\\n/******/ \\t\\tif(mode & 1) value = __webpack_require__(value);\\n/******/ \\t\\tif(mode & 8) return value;\\n/******/ \\t\\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\\n/******/ \\t\\tvar ns = Object.create(null);\\n/******/ \\t\\t__webpack_require__.r(ns);\\n/******/ \\t\\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\\n/******/ \\t\\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\\n/******/ \\t\\treturn ns;\\n/******/ \\t};\\n/******/\\n/******/ \\t// getDefaultExport function for compatibility with non-harmony modules\\n/******/ \\t__webpack_require__.n = function(module) {\\n/******/ \\t\\tvar getter = module && module.__esModule ?\\n/******/ \\t\\t\\tfunction getDefault() { return module['default']; } :\\n/******/ \\t\\t\\tfunction getModuleExports() { return module; };\\n/******/ \\t\\t__webpack_require__.d(getter, 'a', getter);\\n/******/ \\t\\treturn getter;\\n/******/ \\t};\\n/******/\\n/******/ \\t// Object.prototype.hasOwnProperty.call\\n/******/ \\t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\\n/******/\\n/******/ \\t// __webpack_public_path__\\n/******/ \\t__webpack_require__.p = \\\"\\\";\\n/******/\\n/******/\\n/******/ \\t// Load entry module and return exports\\n/******/ \\treturn __webpack_require__(__webpack_require__.s = \\\"./src/lib/worldgen_worker.js\\\");\\n/******/ })\\n/************************************************************************/\\n/******/ ({\\n\\n/***/ \\\"./node_modules/events/events.js\\\":\\n/*!***************************************!*\\\\\\n  !*** ./node_modules/events/events.js ***!\\n  \\\\***************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"// Copyright Joyent, Inc. and other Node contributors.\\\\n//\\\\n// Permission is hereby granted, free of charge, to any person obtaining a\\\\n// copy of this software and associated documentation files (the\\\\n// \\\\\\\"Software\\\\\\\"), to deal in the Software without restriction, including\\\\n// without limitation the rights to use, copy, modify, merge, publish,\\\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\\\n// persons to whom the Software is furnished to do so, subject to the\\\\n// following conditions:\\\\n//\\\\n// The above copyright notice and this permission notice shall be included\\\\n// in all copies or substantial portions of the Software.\\\\n//\\\\n// THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\\\n\\\\n\\\\n\\\\nvar R = typeof Reflect === 'object' ? Reflect : null\\\\nvar ReflectApply = R && typeof R.apply === 'function'\\\\n  ? R.apply\\\\n  : function ReflectApply(target, receiver, args) {\\\\n    return Function.prototype.apply.call(target, receiver, args);\\\\n  }\\\\n\\\\nvar ReflectOwnKeys\\\\nif (R && typeof R.ownKeys === 'function') {\\\\n  ReflectOwnKeys = R.ownKeys\\\\n} else if (Object.getOwnPropertySymbols) {\\\\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\\\\n    return Object.getOwnPropertyNames(target)\\\\n      .concat(Object.getOwnPropertySymbols(target));\\\\n  };\\\\n} else {\\\\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\\\\n    return Object.getOwnPropertyNames(target);\\\\n  };\\\\n}\\\\n\\\\nfunction ProcessEmitWarning(warning) {\\\\n  if (console && console.warn) console.warn(warning);\\\\n}\\\\n\\\\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\\\\n  return value !== value;\\\\n}\\\\n\\\\nfunction EventEmitter() {\\\\n  EventEmitter.init.call(this);\\\\n}\\\\nmodule.exports = EventEmitter;\\\\n\\\\n// Backwards-compat with node 0.10.x\\\\nEventEmitter.EventEmitter = EventEmitter;\\\\n\\\\nEventEmitter.prototype._events = undefined;\\\\nEventEmitter.prototype._eventsCount = 0;\\\\nEventEmitter.prototype._maxListeners = undefined;\\\\n\\\\n// By default EventEmitters will print a warning if more than 10 listeners are\\\\n// added to it. This is a useful default which helps finding memory leaks.\\\\nvar defaultMaxListeners = 10;\\\\n\\\\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\\\\n  enumerable: true,\\\\n  get: function() {\\\\n    return defaultMaxListeners;\\\\n  },\\\\n  set: function(arg) {\\\\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\\\\n      throw new RangeError('The value of \\\\\\\"defaultMaxListeners\\\\\\\" is out of range. It must be a non-negative number. Received ' + arg + '.');\\\\n    }\\\\n    defaultMaxListeners = arg;\\\\n  }\\\\n});\\\\n\\\\nEventEmitter.init = function() {\\\\n\\\\n  if (this._events === undefined ||\\\\n      this._events === Object.getPrototypeOf(this)._events) {\\\\n    this._events = Object.create(null);\\\\n    this._eventsCount = 0;\\\\n  }\\\\n\\\\n  this._maxListeners = this._maxListeners || undefined;\\\\n};\\\\n\\\\n// Obviously not all Emitters should be limited to 10. This function allows\\\\n// that to be increased. Set to zero for unlimited.\\\\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\\\\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\\\\n    throw new RangeError('The value of \\\\\\\"n\\\\\\\" is out of range. It must be a non-negative number. Received ' + n + '.');\\\\n  }\\\\n  this._maxListeners = n;\\\\n  return this;\\\\n};\\\\n\\\\nfunction $getMaxListeners(that) {\\\\n  if (that._maxListeners === undefined)\\\\n    return EventEmitter.defaultMaxListeners;\\\\n  return that._maxListeners;\\\\n}\\\\n\\\\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\\\\n  return $getMaxListeners(this);\\\\n};\\\\n\\\\nEventEmitter.prototype.emit = function emit(type) {\\\\n  var args = [];\\\\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\\\\n  var doError = (type === 'error');\\\\n\\\\n  var events = this._events;\\\\n  if (events !== undefined)\\\\n    doError = (doError && events.error === undefined);\\\\n  else if (!doError)\\\\n    return false;\\\\n\\\\n  // If there is no 'error' event listener then throw.\\\\n  if (doError) {\\\\n    var er;\\\\n    if (args.length > 0)\\\\n      er = args[0];\\\\n    if (er instanceof Error) {\\\\n      // Note: The comments on the `throw` lines are intentional, they show\\\\n      // up in Node's output if this results in an unhandled exception.\\\\n      throw er; // Unhandled 'error' event\\\\n    }\\\\n    // At least give some kind of context to the user\\\\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\\\\n    err.context = er;\\\\n    throw err; // Unhandled 'error' event\\\\n  }\\\\n\\\\n  var handler = events[type];\\\\n\\\\n  if (handler === undefined)\\\\n    return false;\\\\n\\\\n  if (typeof handler === 'function') {\\\\n    ReflectApply(handler, this, args);\\\\n  } else {\\\\n    var len = handler.length;\\\\n    var listeners = arrayClone(handler, len);\\\\n    for (var i = 0; i < len; ++i)\\\\n      ReflectApply(listeners[i], this, args);\\\\n  }\\\\n\\\\n  return true;\\\\n};\\\\n\\\\nfunction _addListener(target, type, listener, prepend) {\\\\n  var m;\\\\n  var events;\\\\n  var existing;\\\\n\\\\n  if (typeof listener !== 'function') {\\\\n    throw new TypeError('The \\\\\\\"listener\\\\\\\" argument must be of type Function. Received type ' + typeof listener);\\\\n  }\\\\n\\\\n  events = target._events;\\\\n  if (events === undefined) {\\\\n    events = target._events = Object.create(null);\\\\n    target._eventsCount = 0;\\\\n  } else {\\\\n    // To avoid recursion in the case that type === \\\\\\\"newListener\\\\\\\"! Before\\\\n    // adding it to the listeners, first emit \\\\\\\"newListener\\\\\\\".\\\\n    if (events.newListener !== undefined) {\\\\n      target.emit('newListener', type,\\\\n                  listener.listener ? listener.listener : listener);\\\\n\\\\n      // Re-assign `events` because a newListener handler could have caused the\\\\n      // this._events to be assigned to a new object\\\\n      events = target._events;\\\\n    }\\\\n    existing = events[type];\\\\n  }\\\\n\\\\n  if (existing === undefined) {\\\\n    // Optimize the case of one listener. Don't need the extra array object.\\\\n    existing = events[type] = listener;\\\\n    ++target._eventsCount;\\\\n  } else {\\\\n    if (typeof existing === 'function') {\\\\n      // Adding the second element, need to change to array.\\\\n      existing = events[type] =\\\\n        prepend ? [listener, existing] : [existing, listener];\\\\n      // If we've already got an array, just append.\\\\n    } else if (prepend) {\\\\n      existing.unshift(listener);\\\\n    } else {\\\\n      existing.push(listener);\\\\n    }\\\\n\\\\n    // Check for listener leak\\\\n    m = $getMaxListeners(target);\\\\n    if (m > 0 && existing.length > m && !existing.warned) {\\\\n      existing.warned = true;\\\\n      // No error code for this since it is a Warning\\\\n      // eslint-disable-next-line no-restricted-syntax\\\\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\\\\n                          existing.length + ' ' + String(type) + ' listeners ' +\\\\n                          'added. Use emitter.setMaxListeners() to ' +\\\\n                          'increase limit');\\\\n      w.name = 'MaxListenersExceededWarning';\\\\n      w.emitter = target;\\\\n      w.type = type;\\\\n      w.count = existing.length;\\\\n      ProcessEmitWarning(w);\\\\n    }\\\\n  }\\\\n\\\\n  return target;\\\\n}\\\\n\\\\nEventEmitter.prototype.addListener = function addListener(type, listener) {\\\\n  return _addListener(this, type, listener, false);\\\\n};\\\\n\\\\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\\\\n\\\\nEventEmitter.prototype.prependListener =\\\\n    function prependListener(type, listener) {\\\\n      return _addListener(this, type, listener, true);\\\\n    };\\\\n\\\\nfunction onceWrapper() {\\\\n  var args = [];\\\\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\\\\n  if (!this.fired) {\\\\n    this.target.removeListener(this.type, this.wrapFn);\\\\n    this.fired = true;\\\\n    ReflectApply(this.listener, this.target, args);\\\\n  }\\\\n}\\\\n\\\\nfunction _onceWrap(target, type, listener) {\\\\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\\\\n  var wrapped = onceWrapper.bind(state);\\\\n  wrapped.listener = listener;\\\\n  state.wrapFn = wrapped;\\\\n  return wrapped;\\\\n}\\\\n\\\\nEventEmitter.prototype.once = function once(type, listener) {\\\\n  if (typeof listener !== 'function') {\\\\n    throw new TypeError('The \\\\\\\"listener\\\\\\\" argument must be of type Function. Received type ' + typeof listener);\\\\n  }\\\\n  this.on(type, _onceWrap(this, type, listener));\\\\n  return this;\\\\n};\\\\n\\\\nEventEmitter.prototype.prependOnceListener =\\\\n    function prependOnceListener(type, listener) {\\\\n      if (typeof listener !== 'function') {\\\\n        throw new TypeError('The \\\\\\\"listener\\\\\\\" argument must be of type Function. Received type ' + typeof listener);\\\\n      }\\\\n      this.prependListener(type, _onceWrap(this, type, listener));\\\\n      return this;\\\\n    };\\\\n\\\\n// Emits a 'removeListener' event if and only if the listener was removed.\\\\nEventEmitter.prototype.removeListener =\\\\n    function removeListener(type, listener) {\\\\n      var list, events, position, i, originalListener;\\\\n\\\\n      if (typeof listener !== 'function') {\\\\n        throw new TypeError('The \\\\\\\"listener\\\\\\\" argument must be of type Function. Received type ' + typeof listener);\\\\n      }\\\\n\\\\n      events = this._events;\\\\n      if (events === undefined)\\\\n        return this;\\\\n\\\\n      list = events[type];\\\\n      if (list === undefined)\\\\n        return this;\\\\n\\\\n      if (list === listener || list.listener === listener) {\\\\n        if (--this._eventsCount === 0)\\\\n          this._events = Object.create(null);\\\\n        else {\\\\n          delete events[type];\\\\n          if (events.removeListener)\\\\n            this.emit('removeListener', type, list.listener || listener);\\\\n        }\\\\n      } else if (typeof list !== 'function') {\\\\n        position = -1;\\\\n\\\\n        for (i = list.length - 1; i >= 0; i--) {\\\\n          if (list[i] === listener || list[i].listener === listener) {\\\\n            originalListener = list[i].listener;\\\\n            position = i;\\\\n            break;\\\\n          }\\\\n        }\\\\n\\\\n        if (position < 0)\\\\n          return this;\\\\n\\\\n        if (position === 0)\\\\n          list.shift();\\\\n        else {\\\\n          spliceOne(list, position);\\\\n        }\\\\n\\\\n        if (list.length === 1)\\\\n          events[type] = list[0];\\\\n\\\\n        if (events.removeListener !== undefined)\\\\n          this.emit('removeListener', type, originalListener || listener);\\\\n      }\\\\n\\\\n      return this;\\\\n    };\\\\n\\\\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\\\\n\\\\nEventEmitter.prototype.removeAllListeners =\\\\n    function removeAllListeners(type) {\\\\n      var listeners, events, i;\\\\n\\\\n      events = this._events;\\\\n      if (events === undefined)\\\\n        return this;\\\\n\\\\n      // not listening for removeListener, no need to emit\\\\n      if (events.removeListener === undefined) {\\\\n        if (arguments.length === 0) {\\\\n          this._events = Object.create(null);\\\\n          this._eventsCount = 0;\\\\n        } else if (events[type] !== undefined) {\\\\n          if (--this._eventsCount === 0)\\\\n            this._events = Object.create(null);\\\\n          else\\\\n            delete events[type];\\\\n        }\\\\n        return this;\\\\n      }\\\\n\\\\n      // emit removeListener for all listeners on all events\\\\n      if (arguments.length === 0) {\\\\n        var keys = Object.keys(events);\\\\n        var key;\\\\n        for (i = 0; i < keys.length; ++i) {\\\\n          key = keys[i];\\\\n          if (key === 'removeListener') continue;\\\\n          this.removeAllListeners(key);\\\\n        }\\\\n        this.removeAllListeners('removeListener');\\\\n        this._events = Object.create(null);\\\\n        this._eventsCount = 0;\\\\n        return this;\\\\n      }\\\\n\\\\n      listeners = events[type];\\\\n\\\\n      if (typeof listeners === 'function') {\\\\n        this.removeListener(type, listeners);\\\\n      } else if (listeners !== undefined) {\\\\n        // LIFO order\\\\n        for (i = listeners.length - 1; i >= 0; i--) {\\\\n          this.removeListener(type, listeners[i]);\\\\n        }\\\\n      }\\\\n\\\\n      return this;\\\\n    };\\\\n\\\\nfunction _listeners(target, type, unwrap) {\\\\n  var events = target._events;\\\\n\\\\n  if (events === undefined)\\\\n    return [];\\\\n\\\\n  var evlistener = events[type];\\\\n  if (evlistener === undefined)\\\\n    return [];\\\\n\\\\n  if (typeof evlistener === 'function')\\\\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\\\\n\\\\n  return unwrap ?\\\\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\\\\n}\\\\n\\\\nEventEmitter.prototype.listeners = function listeners(type) {\\\\n  return _listeners(this, type, true);\\\\n};\\\\n\\\\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\\\\n  return _listeners(this, type, false);\\\\n};\\\\n\\\\nEventEmitter.listenerCount = function(emitter, type) {\\\\n  if (typeof emitter.listenerCount === 'function') {\\\\n    return emitter.listenerCount(type);\\\\n  } else {\\\\n    return listenerCount.call(emitter, type);\\\\n  }\\\\n};\\\\n\\\\nEventEmitter.prototype.listenerCount = listenerCount;\\\\nfunction listenerCount(type) {\\\\n  var events = this._events;\\\\n\\\\n  if (events !== undefined) {\\\\n    var evlistener = events[type];\\\\n\\\\n    if (typeof evlistener === 'function') {\\\\n      return 1;\\\\n    } else if (evlistener !== undefined) {\\\\n      return evlistener.length;\\\\n    }\\\\n  }\\\\n\\\\n  return 0;\\\\n}\\\\n\\\\nEventEmitter.prototype.eventNames = function eventNames() {\\\\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\\\\n};\\\\n\\\\nfunction arrayClone(arr, n) {\\\\n  var copy = new Array(n);\\\\n  for (var i = 0; i < n; ++i)\\\\n    copy[i] = arr[i];\\\\n  return copy;\\\\n}\\\\n\\\\nfunction spliceOne(list, index) {\\\\n  for (; index + 1 < list.length; index++)\\\\n    list[index] = list[index + 1];\\\\n  list.pop();\\\\n}\\\\n\\\\nfunction unwrapListeners(arr) {\\\\n  var ret = new Array(arr.length);\\\\n  for (var i = 0; i < ret.length; ++i) {\\\\n    ret[i] = arr[i].listener || arr[i];\\\\n  }\\\\n  return ret;\\\\n}\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/events/events.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/iota-array/iota.js\\\":\\n/*!*****************************************!*\\\\\\n  !*** ./node_modules/iota-array/iota.js ***!\\n  \\\\*****************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\nfunction iota(n) {\\\\n  var result = new Array(n)\\\\n  for(var i=0; i<n; ++i) {\\\\n    result[i] = i\\\\n  }\\\\n  return result\\\\n}\\\\n\\\\nmodule.exports = iota\\\\n\\\\n//# sourceURL=webpack:///./node_modules/iota-array/iota.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/is-buffer/index.js\\\":\\n/*!*****************************************!*\\\\\\n  !*** ./node_modules/is-buffer/index.js ***!\\n  \\\\*****************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\neval(\\\"/*!\\\\n * Determine if an object is a Buffer\\\\n *\\\\n * @author   Feross Aboukhadijeh <https://feross.org>\\\\n * @license  MIT\\\\n */\\\\n\\\\n// The _isBuffer check is for Safari 5-7 support, because it's missing\\\\n// Object.prototype.constructor. Remove this eventually\\\\nmodule.exports = function (obj) {\\\\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\\\\n}\\\\n\\\\nfunction isBuffer (obj) {\\\\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\\\\n}\\\\n\\\\n// For Node v0.10 support. Remove this eventually.\\\\nfunction isSlowBuffer (obj) {\\\\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\\\\n}\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/is-buffer/index.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/ndarray/ndarray.js\\\":\\n/*!*****************************************!*\\\\\\n  !*** ./node_modules/ndarray/ndarray.js ***!\\n  \\\\*****************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"var iota = __webpack_require__(/*! iota-array */ \\\\\\\"./node_modules/iota-array/iota.js\\\\\\\")\\\\nvar isBuffer = __webpack_require__(/*! is-buffer */ \\\\\\\"./node_modules/is-buffer/index.js\\\\\\\")\\\\n\\\\nvar hasTypedArrays  = ((typeof Float64Array) !== \\\\\\\"undefined\\\\\\\")\\\\n\\\\nfunction compare1st(a, b) {\\\\n  return a[0] - b[0]\\\\n}\\\\n\\\\nfunction order() {\\\\n  var stride = this.stride\\\\n  var terms = new Array(stride.length)\\\\n  var i\\\\n  for(i=0; i<terms.length; ++i) {\\\\n    terms[i] = [Math.abs(stride[i]), i]\\\\n  }\\\\n  terms.sort(compare1st)\\\\n  var result = new Array(terms.length)\\\\n  for(i=0; i<result.length; ++i) {\\\\n    result[i] = terms[i][1]\\\\n  }\\\\n  return result\\\\n}\\\\n\\\\nfunction compileConstructor(dtype, dimension) {\\\\n  var className = [\\\\\\\"View\\\\\\\", dimension, \\\\\\\"d\\\\\\\", dtype].join(\\\\\\\"\\\\\\\")\\\\n  if(dimension < 0) {\\\\n    className = \\\\\\\"View_Nil\\\\\\\" + dtype\\\\n  }\\\\n  var useGetters = (dtype === \\\\\\\"generic\\\\\\\")\\\\n\\\\n  if(dimension === -1) {\\\\n    //Special case for trivial arrays\\\\n    var code =\\\\n      \\\\\\\"function \\\\\\\"+className+\\\\\\\"(a){this.data=a;};\\\\\\\\\\\\nvar proto=\\\\\\\"+className+\\\\\\\".prototype;\\\\\\\\\\\\nproto.dtype='\\\\\\\"+dtype+\\\\\\\"';\\\\\\\\\\\\nproto.index=function(){return -1};\\\\\\\\\\\\nproto.size=0;\\\\\\\\\\\\nproto.dimension=-1;\\\\\\\\\\\\nproto.shape=proto.stride=proto.order=[];\\\\\\\\\\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\\\\\\\\\\nfunction(){return new \\\\\\\"+className+\\\\\\\"(this.data);};\\\\\\\\\\\\nproto.get=proto.set=function(){};\\\\\\\\\\\\nproto.pick=function(){return null};\\\\\\\\\\\\nreturn function construct_\\\\\\\"+className+\\\\\\\"(a){return new \\\\\\\"+className+\\\\\\\"(a);}\\\\\\\"\\\\n    var procedure = new Function(code)\\\\n    return procedure()\\\\n  } else if(dimension === 0) {\\\\n    //Special case for 0d arrays\\\\n    var code =\\\\n      \\\\\\\"function \\\\\\\"+className+\\\\\\\"(a,d) {\\\\\\\\\\\\nthis.data = a;\\\\\\\\\\\\nthis.offset = d\\\\\\\\\\\\n};\\\\\\\\\\\\nvar proto=\\\\\\\"+className+\\\\\\\".prototype;\\\\\\\\\\\\nproto.dtype='\\\\\\\"+dtype+\\\\\\\"';\\\\\\\\\\\\nproto.index=function(){return this.offset};\\\\\\\\\\\\nproto.dimension=0;\\\\\\\\\\\\nproto.size=1;\\\\\\\\\\\\nproto.shape=\\\\\\\\\\\\nproto.stride=\\\\\\\\\\\\nproto.order=[];\\\\\\\\\\\\nproto.lo=\\\\\\\\\\\\nproto.hi=\\\\\\\\\\\\nproto.transpose=\\\\\\\\\\\\nproto.step=function \\\\\\\"+className+\\\\\\\"_copy() {\\\\\\\\\\\\nreturn new \\\\\\\"+className+\\\\\\\"(this.data,this.offset)\\\\\\\\\\\\n};\\\\\\\\\\\\nproto.pick=function \\\\\\\"+className+\\\\\\\"_pick(){\\\\\\\\\\\\nreturn TrivialArray(this.data);\\\\\\\\\\\\n};\\\\\\\\\\\\nproto.valueOf=proto.get=function \\\\\\\"+className+\\\\\\\"_get(){\\\\\\\\\\\\nreturn \\\\\\\"+(useGetters ? \\\\\\\"this.data.get(this.offset)\\\\\\\" : \\\\\\\"this.data[this.offset]\\\\\\\")+\\\\n\\\\\\\"};\\\\\\\\\\\\nproto.set=function \\\\\\\"+className+\\\\\\\"_set(v){\\\\\\\\\\\\nreturn \\\\\\\"+(useGetters ? \\\\\\\"this.data.set(this.offset,v)\\\\\\\" : \\\\\\\"this.data[this.offset]=v\\\\\\\")+\\\\\\\"\\\\\\\\\\\\n};\\\\\\\\\\\\nreturn function construct_\\\\\\\"+className+\\\\\\\"(a,b,c,d){return new \\\\\\\"+className+\\\\\\\"(a,d)}\\\\\\\"\\\\n    var procedure = new Function(\\\\\\\"TrivialArray\\\\\\\", code)\\\\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\\\\n  }\\\\n\\\\n  var code = [\\\\\\\"'use strict'\\\\\\\"]\\\\n\\\\n  //Create constructor for view\\\\n  var indices = iota(dimension)\\\\n  var args = indices.map(function(i) { return \\\\\\\"i\\\\\\\"+i })\\\\n  var index_str = \\\\\\\"this.offset+\\\\\\\" + indices.map(function(i) {\\\\n        return \\\\\\\"this.stride[\\\\\\\" + i + \\\\\\\"]*i\\\\\\\" + i\\\\n      }).join(\\\\\\\"+\\\\\\\")\\\\n  var shapeArg = indices.map(function(i) {\\\\n      return \\\\\\\"b\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")\\\\n  var strideArg = indices.map(function(i) {\\\\n      return \\\\\\\"c\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")\\\\n  code.push(\\\\n    \\\\\\\"function \\\\\\\"+className+\\\\\\\"(a,\\\\\\\" + shapeArg + \\\\\\\",\\\\\\\" + strideArg + \\\\\\\",d){this.data=a\\\\\\\",\\\\n      \\\\\\\"this.shape=[\\\\\\\" + shapeArg + \\\\\\\"]\\\\\\\",\\\\n      \\\\\\\"this.stride=[\\\\\\\" + strideArg + \\\\\\\"]\\\\\\\",\\\\n      \\\\\\\"this.offset=d|0}\\\\\\\",\\\\n    \\\\\\\"var proto=\\\\\\\"+className+\\\\\\\".prototype\\\\\\\",\\\\n    \\\\\\\"proto.dtype='\\\\\\\"+dtype+\\\\\\\"'\\\\\\\",\\\\n    \\\\\\\"proto.dimension=\\\\\\\"+dimension)\\\\n\\\\n  //view.size:\\\\n  code.push(\\\\\\\"Object.defineProperty(proto,'size',{get:function \\\\\\\"+className+\\\\\\\"_size(){\\\\\\\\\\\\nreturn \\\\\\\"+indices.map(function(i) { return \\\\\\\"this.shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\" }).join(\\\\\\\"*\\\\\\\"),\\\\n\\\\\\\"}})\\\\\\\")\\\\n\\\\n  //view.order:\\\\n  if(dimension === 1) {\\\\n    code.push(\\\\\\\"proto.order=[0]\\\\\\\")\\\\n  } else {\\\\n    code.push(\\\\\\\"Object.defineProperty(proto,'order',{get:\\\\\\\")\\\\n    if(dimension < 4) {\\\\n      code.push(\\\\\\\"function \\\\\\\"+className+\\\\\\\"_order(){\\\\\\\")\\\\n      if(dimension === 2) {\\\\n        code.push(\\\\\\\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\\\\\\\")\\\\n      } else if(dimension === 3) {\\\\n        code.push(\\\\n\\\\\\\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\\\\\\\\\\nif(s0>s1){\\\\\\\\\\\\nif(s1>s2){\\\\\\\\\\\\nreturn [2,1,0];\\\\\\\\\\\\n}else if(s0>s2){\\\\\\\\\\\\nreturn [1,2,0];\\\\\\\\\\\\n}else{\\\\\\\\\\\\nreturn [1,0,2];\\\\\\\\\\\\n}\\\\\\\\\\\\n}else if(s0>s2){\\\\\\\\\\\\nreturn [2,0,1];\\\\\\\\\\\\n}else if(s2>s1){\\\\\\\\\\\\nreturn [0,1,2];\\\\\\\\\\\\n}else{\\\\\\\\\\\\nreturn [0,2,1];\\\\\\\\\\\\n}}})\\\\\\\")\\\\n      }\\\\n    } else {\\\\n      code.push(\\\\\\\"ORDER})\\\\\\\")\\\\n    }\\\\n  }\\\\n\\\\n  //view.set(i0, ..., v):\\\\n  code.push(\\\\n\\\\\\\"proto.set=function \\\\\\\"+className+\\\\\\\"_set(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\",v){\\\\\\\")\\\\n  if(useGetters) {\\\\n    code.push(\\\\\\\"return this.data.set(\\\\\\\"+index_str+\\\\\\\",v)}\\\\\\\")\\\\n  } else {\\\\n    code.push(\\\\\\\"return this.data[\\\\\\\"+index_str+\\\\\\\"]=v}\\\\\\\")\\\\n  }\\\\n\\\\n  //view.get(i0, ...):\\\\n  code.push(\\\\\\\"proto.get=function \\\\\\\"+className+\\\\\\\"_get(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){\\\\\\\")\\\\n  if(useGetters) {\\\\n    code.push(\\\\\\\"return this.data.get(\\\\\\\"+index_str+\\\\\\\")}\\\\\\\")\\\\n  } else {\\\\n    code.push(\\\\\\\"return this.data[\\\\\\\"+index_str+\\\\\\\"]}\\\\\\\")\\\\n  }\\\\n\\\\n  //view.index:\\\\n  code.push(\\\\n    \\\\\\\"proto.index=function \\\\\\\"+className+\\\\\\\"_index(\\\\\\\", args.join(), \\\\\\\"){return \\\\\\\"+index_str+\\\\\\\"}\\\\\\\")\\\\n\\\\n  //view.hi():\\\\n  code.push(\\\\\\\"proto.hi=function \\\\\\\"+className+\\\\\\\"_hi(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return [\\\\\\\"(typeof i\\\\\\\",i,\\\\\\\"!=='number'||i\\\\\\\",i,\\\\\\\"<0)?this.shape[\\\\\\\", i, \\\\\\\"]:i\\\\\\\", i,\\\\\\\"|0\\\\\\\"].join(\\\\\\\"\\\\\\\")\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"this.stride[\\\\\\\"+i + \\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",this.offset)}\\\\\\\")\\\\n\\\\n  //view.lo():\\\\n  var a_vars = indices.map(function(i) { return \\\\\\\"a\\\\\\\"+i+\\\\\\\"=this.shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\" })\\\\n  var c_vars = indices.map(function(i) { return \\\\\\\"c\\\\\\\"+i+\\\\\\\"=this.stride[\\\\\\\"+i+\\\\\\\"]\\\\\\\" })\\\\n  code.push(\\\\\\\"proto.lo=function \\\\\\\"+className+\\\\\\\"_lo(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){var b=this.offset,d=0,\\\\\\\"+a_vars.join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+c_vars.join(\\\\\\\",\\\\\\\"))\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    code.push(\\\\n\\\\\\\"if(typeof i\\\\\\\"+i+\\\\\\\"==='number'&&i\\\\\\\"+i+\\\\\\\">=0){\\\\\\\\\\\\nd=i\\\\\\\"+i+\\\\\\\"|0;\\\\\\\\\\\\nb+=c\\\\\\\"+i+\\\\\\\"*d;\\\\\\\\\\\\na\\\\\\\"+i+\\\\\\\"-=d}\\\\\\\")\\\\n  }\\\\n  code.push(\\\\\\\"return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"a\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"c\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",b)}\\\\\\\")\\\\n\\\\n  //view.step():\\\\n  code.push(\\\\\\\"proto.step=function \\\\\\\"+className+\\\\\\\"_step(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){var \\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"a\\\\\\\"+i+\\\\\\\"=this.shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"b\\\\\\\"+i+\\\\\\\"=this.stride[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",c=this.offset,d=0,ceil=Math.ceil\\\\\\\")\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    code.push(\\\\n\\\\\\\"if(typeof i\\\\\\\"+i+\\\\\\\"==='number'){\\\\\\\\\\\\nd=i\\\\\\\"+i+\\\\\\\"|0;\\\\\\\\\\\\nif(d<0){\\\\\\\\\\\\nc+=b\\\\\\\"+i+\\\\\\\"*(a\\\\\\\"+i+\\\\\\\"-1);\\\\\\\\\\\\na\\\\\\\"+i+\\\\\\\"=ceil(-a\\\\\\\"+i+\\\\\\\"/d)\\\\\\\\\\\\n}else{\\\\\\\\\\\\na\\\\\\\"+i+\\\\\\\"=ceil(a\\\\\\\"+i+\\\\\\\"/d)\\\\\\\\\\\\n}\\\\\\\\\\\\nb\\\\\\\"+i+\\\\\\\"*=d\\\\\\\\\\\\n}\\\\\\\")\\\\n  }\\\\n  code.push(\\\\\\\"return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"a\\\\\\\" + i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"b\\\\\\\" + i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",c)}\\\\\\\")\\\\n\\\\n  //view.transpose():\\\\n  var tShape = new Array(dimension)\\\\n  var tStride = new Array(dimension)\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    tShape[i] = \\\\\\\"a[i\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    tStride[i] = \\\\\\\"b[i\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n  }\\\\n  code.push(\\\\\\\"proto.transpose=function \\\\\\\"+className+\\\\\\\"_transpose(\\\\\\\"+args+\\\\\\\"){\\\\\\\"+\\\\n    args.map(function(n,idx) { return n + \\\\\\\"=(\\\\\\\" + n + \\\\\\\"===undefined?\\\\\\\" + idx + \\\\\\\":\\\\\\\" + n + \\\\\\\"|0)\\\\\\\"}).join(\\\\\\\";\\\\\\\"),\\\\n    \\\\\\\"var a=this.shape,b=this.stride;return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+tShape.join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+tStride.join(\\\\\\\",\\\\\\\")+\\\\\\\",this.offset)}\\\\\\\")\\\\n\\\\n  //view.pick():\\\\n  code.push(\\\\\\\"proto.pick=function \\\\\\\"+className+\\\\\\\"_pick(\\\\\\\"+args+\\\\\\\"){var a=[],b=[],c=this.offset\\\\\\\")\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    code.push(\\\\\\\"if(typeof i\\\\\\\"+i+\\\\\\\"==='number'&&i\\\\\\\"+i+\\\\\\\">=0){c=(c+this.stride[\\\\\\\"+i+\\\\\\\"]*i\\\\\\\"+i+\\\\\\\")|0}else{a.push(this.shape[\\\\\\\"+i+\\\\\\\"]);b.push(this.stride[\\\\\\\"+i+\\\\\\\"])}\\\\\\\")\\\\n  }\\\\n  code.push(\\\\\\\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\\\\\\\")\\\\n\\\\n  //Add return statement\\\\n  code.push(\\\\\\\"return function construct_\\\\\\\"+className+\\\\\\\"(data,shape,stride,offset){return new \\\\\\\"+className+\\\\\\\"(data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"stride[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",offset)}\\\\\\\")\\\\n\\\\n  //Compile procedure\\\\n  var procedure = new Function(\\\\\\\"CTOR_LIST\\\\\\\", \\\\\\\"ORDER\\\\\\\", code.join(\\\\\\\"\\\\\\\\n\\\\\\\"))\\\\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\\\\n}\\\\n\\\\nfunction arrayDType(data) {\\\\n  if(isBuffer(data)) {\\\\n    return \\\\\\\"buffer\\\\\\\"\\\\n  }\\\\n  if(hasTypedArrays) {\\\\n    switch(Object.prototype.toString.call(data)) {\\\\n      case \\\\\\\"[object Float64Array]\\\\\\\":\\\\n        return \\\\\\\"float64\\\\\\\"\\\\n      case \\\\\\\"[object Float32Array]\\\\\\\":\\\\n        return \\\\\\\"float32\\\\\\\"\\\\n      case \\\\\\\"[object Int8Array]\\\\\\\":\\\\n        return \\\\\\\"int8\\\\\\\"\\\\n      case \\\\\\\"[object Int16Array]\\\\\\\":\\\\n        return \\\\\\\"int16\\\\\\\"\\\\n      case \\\\\\\"[object Int32Array]\\\\\\\":\\\\n        return \\\\\\\"int32\\\\\\\"\\\\n      case \\\\\\\"[object Uint8Array]\\\\\\\":\\\\n        return \\\\\\\"uint8\\\\\\\"\\\\n      case \\\\\\\"[object Uint16Array]\\\\\\\":\\\\n        return \\\\\\\"uint16\\\\\\\"\\\\n      case \\\\\\\"[object Uint32Array]\\\\\\\":\\\\n        return \\\\\\\"uint32\\\\\\\"\\\\n      case \\\\\\\"[object Uint8ClampedArray]\\\\\\\":\\\\n        return \\\\\\\"uint8_clamped\\\\\\\"\\\\n    }\\\\n  }\\\\n  if(Array.isArray(data)) {\\\\n    return \\\\\\\"array\\\\\\\"\\\\n  }\\\\n  return \\\\\\\"generic\\\\\\\"\\\\n}\\\\n\\\\nvar CACHED_CONSTRUCTORS = {\\\\n  \\\\\\\"float32\\\\\\\":[],\\\\n  \\\\\\\"float64\\\\\\\":[],\\\\n  \\\\\\\"int8\\\\\\\":[],\\\\n  \\\\\\\"int16\\\\\\\":[],\\\\n  \\\\\\\"int32\\\\\\\":[],\\\\n  \\\\\\\"uint8\\\\\\\":[],\\\\n  \\\\\\\"uint16\\\\\\\":[],\\\\n  \\\\\\\"uint32\\\\\\\":[],\\\\n  \\\\\\\"array\\\\\\\":[],\\\\n  \\\\\\\"uint8_clamped\\\\\\\":[],\\\\n  \\\\\\\"buffer\\\\\\\":[],\\\\n  \\\\\\\"generic\\\\\\\":[]\\\\n}\\\\n\\\\n;(function() {\\\\n  for(var id in CACHED_CONSTRUCTORS) {\\\\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\\\\n  }\\\\n});\\\\n\\\\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\\\\n  if(data === undefined) {\\\\n    var ctor = CACHED_CONSTRUCTORS.array[0]\\\\n    return ctor([])\\\\n  } else if(typeof data === \\\\\\\"number\\\\\\\") {\\\\n    data = [data]\\\\n  }\\\\n  if(shape === undefined) {\\\\n    shape = [ data.length ]\\\\n  }\\\\n  var d = shape.length\\\\n  if(stride === undefined) {\\\\n    stride = new Array(d)\\\\n    for(var i=d-1, sz=1; i>=0; --i) {\\\\n      stride[i] = sz\\\\n      sz *= shape[i]\\\\n    }\\\\n  }\\\\n  if(offset === undefined) {\\\\n    offset = 0\\\\n    for(var i=0; i<d; ++i) {\\\\n      if(stride[i] < 0) {\\\\n        offset -= (shape[i]-1)*stride[i]\\\\n      }\\\\n    }\\\\n  }\\\\n  var dtype = arrayDType(data)\\\\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\\\\n  while(ctor_list.length <= d+1) {\\\\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\\\\n  }\\\\n  var ctor = ctor_list[d+1]\\\\n  return ctor(data, shape, stride, offset)\\\\n}\\\\n\\\\nmodule.exports = wrappedNDArrayCtor\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/ndarray/ndarray.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/ndhash/hash.js\\\":\\n/*!*************************************!*\\\\\\n  !*** ./node_modules/ndhash/hash.js ***!\\n  \\\\*************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports) {\\n\\neval(\\\"\\\\n/*\\\\n *  ndhash\\\\n * \\\\n *  simple n-D hash function with random-looking output\\\\n * \\\\n*/\\\\n\\\\n\\\\nvar A = Math.sqrt(5)\\\\nvar B = Math.sqrt(7)\\\\nvar h, accum, i, k\\\\n\\\\nvar floor = Math.floor\\\\nfunction frac(n) {\\\\n  return n-floor(n)\\\\n}\\\\n\\\\nfunction hash() {\\\\n  h = A\\\\n  accum = B\\\\n\\\\n  for (i=0; i<arguments.length; ++i) {\\\\n    k = arguments[i]\\\\n    h = frac( h * (k+B) )\\\\n    accum *= (k+A)\\\\n  }\\\\n\\\\n  h = frac( h * accum )\\\\n  return h\\\\n}\\\\n\\\\nmodule.exports = hash\\\\n\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/ndhash/hash.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js\\\":\\n/*!*********************************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js ***!\\n  \\\\*********************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\r\\\\n\\\\r\\\\nvar ndarray = __webpack_require__(/*! ndarray */ \\\\\\\"./node_modules/noa-engine/node_modules/ndarray/ndarray.js\\\\\\\")\\\\r\\\\nvar useMaps = !(typeof Map === \\\\\\\"undefined\\\\\\\")\\\\r\\\\n\\\\r\\\\nfunction HashMap(n) {\\\\r\\\\n  this.length = n\\\\r\\\\n  this.store = useMaps ? new Map() : {}\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nif (useMaps) {\\\\r\\\\n  HashMap.prototype.get = function(i) {\\\\r\\\\n    return this.store.get(i) || 0\\\\r\\\\n  }\\\\r\\\\n  HashMap.prototype.set = function(i,v) {\\\\r\\\\n    if (v===0) {\\\\r\\\\n      this.store.delete(i)\\\\r\\\\n    } else {\\\\r\\\\n      this.store.set(i, v)\\\\r\\\\n    }\\\\r\\\\n    return v\\\\r\\\\n  }\\\\r\\\\n} else { // Using a polyfill would be neater, but this works as well \\\\r\\\\n  HashMap.prototype.get = function(i) {\\\\r\\\\n    return this.store[i] || 0\\\\r\\\\n  }\\\\r\\\\n  HashMap.prototype.set = function(i,v) {\\\\r\\\\n    if (v===0) {\\\\r\\\\n      delete this.store[i]\\\\r\\\\n    } else {\\\\r\\\\n      this.store[i] = v\\\\r\\\\n    }\\\\r\\\\n    return v\\\\r\\\\n  }\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nfunction createNDHash(shape) {\\\\r\\\\n  var sz = 1\\\\r\\\\n  for(var i=0; i<shape.length; ++i) {\\\\r\\\\n    sz *= shape[i]\\\\r\\\\n  }\\\\r\\\\n  return ndarray(new HashMap(sz), shape)\\\\r\\\\n}\\\\r\\\\n\\\\r\\\\nmodule.exports = createNDHash\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/node_modules/ndarray/ndarray.js\\\":\\n/*!*****************************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/node_modules/ndarray/ndarray.js ***!\\n  \\\\*****************************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"var iota = __webpack_require__(/*! iota-array */ \\\\\\\"./node_modules/iota-array/iota.js\\\\\\\")\\\\nvar isBuffer = __webpack_require__(/*! is-buffer */ \\\\\\\"./node_modules/is-buffer/index.js\\\\\\\")\\\\n\\\\nvar hasTypedArrays  = ((typeof Float64Array) !== \\\\\\\"undefined\\\\\\\")\\\\n\\\\nfunction compare1st(a, b) {\\\\n  return a[0] - b[0]\\\\n}\\\\n\\\\nfunction order() {\\\\n  var stride = this.stride\\\\n  var terms = new Array(stride.length)\\\\n  var i\\\\n  for(i=0; i<terms.length; ++i) {\\\\n    terms[i] = [Math.abs(stride[i]), i]\\\\n  }\\\\n  terms.sort(compare1st)\\\\n  var result = new Array(terms.length)\\\\n  for(i=0; i<result.length; ++i) {\\\\n    result[i] = terms[i][1]\\\\n  }\\\\n  return result\\\\n}\\\\n\\\\nfunction compileConstructor(dtype, dimension) {\\\\n  var className = [\\\\\\\"View\\\\\\\", dimension, \\\\\\\"d\\\\\\\", dtype].join(\\\\\\\"\\\\\\\")\\\\n  if(dimension < 0) {\\\\n    className = \\\\\\\"View_Nil\\\\\\\" + dtype\\\\n  }\\\\n  var useGetters = (dtype === \\\\\\\"generic\\\\\\\")\\\\n\\\\n  if(dimension === -1) {\\\\n    //Special case for trivial arrays\\\\n    var code =\\\\n      \\\\\\\"function \\\\\\\"+className+\\\\\\\"(a){this.data=a;};\\\\\\\\\\\\nvar proto=\\\\\\\"+className+\\\\\\\".prototype;\\\\\\\\\\\\nproto.dtype='\\\\\\\"+dtype+\\\\\\\"';\\\\\\\\\\\\nproto.index=function(){return -1};\\\\\\\\\\\\nproto.size=0;\\\\\\\\\\\\nproto.dimension=-1;\\\\\\\\\\\\nproto.shape=proto.stride=proto.order=[];\\\\\\\\\\\\nproto.lo=proto.hi=proto.transpose=proto.step=\\\\\\\\\\\\nfunction(){return new \\\\\\\"+className+\\\\\\\"(this.data);};\\\\\\\\\\\\nproto.get=proto.set=function(){};\\\\\\\\\\\\nproto.pick=function(){return null};\\\\\\\\\\\\nreturn function construct_\\\\\\\"+className+\\\\\\\"(a){return new \\\\\\\"+className+\\\\\\\"(a);}\\\\\\\"\\\\n    var procedure = new Function(code)\\\\n    return procedure()\\\\n  } else if(dimension === 0) {\\\\n    //Special case for 0d arrays\\\\n    var code =\\\\n      \\\\\\\"function \\\\\\\"+className+\\\\\\\"(a,d) {\\\\\\\\\\\\nthis.data = a;\\\\\\\\\\\\nthis.offset = d\\\\\\\\\\\\n};\\\\\\\\\\\\nvar proto=\\\\\\\"+className+\\\\\\\".prototype;\\\\\\\\\\\\nproto.dtype='\\\\\\\"+dtype+\\\\\\\"';\\\\\\\\\\\\nproto.index=function(){return this.offset};\\\\\\\\\\\\nproto.dimension=0;\\\\\\\\\\\\nproto.size=1;\\\\\\\\\\\\nproto.shape=\\\\\\\\\\\\nproto.stride=\\\\\\\\\\\\nproto.order=[];\\\\\\\\\\\\nproto.lo=\\\\\\\\\\\\nproto.hi=\\\\\\\\\\\\nproto.transpose=\\\\\\\\\\\\nproto.step=function \\\\\\\"+className+\\\\\\\"_copy() {\\\\\\\\\\\\nreturn new \\\\\\\"+className+\\\\\\\"(this.data,this.offset)\\\\\\\\\\\\n};\\\\\\\\\\\\nproto.pick=function \\\\\\\"+className+\\\\\\\"_pick(){\\\\\\\\\\\\nreturn TrivialArray(this.data);\\\\\\\\\\\\n};\\\\\\\\\\\\nproto.valueOf=proto.get=function \\\\\\\"+className+\\\\\\\"_get(){\\\\\\\\\\\\nreturn \\\\\\\"+(useGetters ? \\\\\\\"this.data.get(this.offset)\\\\\\\" : \\\\\\\"this.data[this.offset]\\\\\\\")+\\\\n\\\\\\\"};\\\\\\\\\\\\nproto.set=function \\\\\\\"+className+\\\\\\\"_set(v){\\\\\\\\\\\\nreturn \\\\\\\"+(useGetters ? \\\\\\\"this.data.set(this.offset,v)\\\\\\\" : \\\\\\\"this.data[this.offset]=v\\\\\\\")+\\\\\\\"\\\\\\\\\\\\n};\\\\\\\\\\\\nreturn function construct_\\\\\\\"+className+\\\\\\\"(a,b,c,d){return new \\\\\\\"+className+\\\\\\\"(a,d)}\\\\\\\"\\\\n    var procedure = new Function(\\\\\\\"TrivialArray\\\\\\\", code)\\\\n    return procedure(CACHED_CONSTRUCTORS[dtype][0])\\\\n  }\\\\n\\\\n  var code = [\\\\\\\"'use strict'\\\\\\\"]\\\\n\\\\n  //Create constructor for view\\\\n  var indices = iota(dimension)\\\\n  var args = indices.map(function(i) { return \\\\\\\"i\\\\\\\"+i })\\\\n  var index_str = \\\\\\\"this.offset+\\\\\\\" + indices.map(function(i) {\\\\n        return \\\\\\\"this.stride[\\\\\\\" + i + \\\\\\\"]*i\\\\\\\" + i\\\\n      }).join(\\\\\\\"+\\\\\\\")\\\\n  var shapeArg = indices.map(function(i) {\\\\n      return \\\\\\\"b\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")\\\\n  var strideArg = indices.map(function(i) {\\\\n      return \\\\\\\"c\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")\\\\n  code.push(\\\\n    \\\\\\\"function \\\\\\\"+className+\\\\\\\"(a,\\\\\\\" + shapeArg + \\\\\\\",\\\\\\\" + strideArg + \\\\\\\",d){this.data=a\\\\\\\",\\\\n      \\\\\\\"this.shape=[\\\\\\\" + shapeArg + \\\\\\\"]\\\\\\\",\\\\n      \\\\\\\"this.stride=[\\\\\\\" + strideArg + \\\\\\\"]\\\\\\\",\\\\n      \\\\\\\"this.offset=d|0}\\\\\\\",\\\\n    \\\\\\\"var proto=\\\\\\\"+className+\\\\\\\".prototype\\\\\\\",\\\\n    \\\\\\\"proto.dtype='\\\\\\\"+dtype+\\\\\\\"'\\\\\\\",\\\\n    \\\\\\\"proto.dimension=\\\\\\\"+dimension)\\\\n\\\\n  //view.size:\\\\n  code.push(\\\\\\\"Object.defineProperty(proto,'size',{get:function \\\\\\\"+className+\\\\\\\"_size(){\\\\\\\\\\\\nreturn \\\\\\\"+indices.map(function(i) { return \\\\\\\"this.shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\" }).join(\\\\\\\"*\\\\\\\"),\\\\n\\\\\\\"}})\\\\\\\")\\\\n\\\\n  //view.order:\\\\n  if(dimension === 1) {\\\\n    code.push(\\\\\\\"proto.order=[0]\\\\\\\")\\\\n  } else {\\\\n    code.push(\\\\\\\"Object.defineProperty(proto,'order',{get:\\\\\\\")\\\\n    if(dimension < 4) {\\\\n      code.push(\\\\\\\"function \\\\\\\"+className+\\\\\\\"_order(){\\\\\\\")\\\\n      if(dimension === 2) {\\\\n        code.push(\\\\\\\"return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})\\\\\\\")\\\\n      } else if(dimension === 3) {\\\\n        code.push(\\\\n\\\\\\\"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\\\\\\\\\\\\nif(s0>s1){\\\\\\\\\\\\nif(s1>s2){\\\\\\\\\\\\nreturn [2,1,0];\\\\\\\\\\\\n}else if(s0>s2){\\\\\\\\\\\\nreturn [1,2,0];\\\\\\\\\\\\n}else{\\\\\\\\\\\\nreturn [1,0,2];\\\\\\\\\\\\n}\\\\\\\\\\\\n}else if(s0>s2){\\\\\\\\\\\\nreturn [2,0,1];\\\\\\\\\\\\n}else if(s2>s1){\\\\\\\\\\\\nreturn [0,1,2];\\\\\\\\\\\\n}else{\\\\\\\\\\\\nreturn [0,2,1];\\\\\\\\\\\\n}}})\\\\\\\")\\\\n      }\\\\n    } else {\\\\n      code.push(\\\\\\\"ORDER})\\\\\\\")\\\\n    }\\\\n  }\\\\n\\\\n  //view.set(i0, ..., v):\\\\n  code.push(\\\\n\\\\\\\"proto.set=function \\\\\\\"+className+\\\\\\\"_set(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\",v){\\\\\\\")\\\\n  if(useGetters) {\\\\n    code.push(\\\\\\\"return this.data.set(\\\\\\\"+index_str+\\\\\\\",v)}\\\\\\\")\\\\n  } else {\\\\n    code.push(\\\\\\\"return this.data[\\\\\\\"+index_str+\\\\\\\"]=v}\\\\\\\")\\\\n  }\\\\n\\\\n  //view.get(i0, ...):\\\\n  code.push(\\\\\\\"proto.get=function \\\\\\\"+className+\\\\\\\"_get(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){\\\\\\\")\\\\n  if(useGetters) {\\\\n    code.push(\\\\\\\"return this.data.get(\\\\\\\"+index_str+\\\\\\\")}\\\\\\\")\\\\n  } else {\\\\n    code.push(\\\\\\\"return this.data[\\\\\\\"+index_str+\\\\\\\"]}\\\\\\\")\\\\n  }\\\\n\\\\n  //view.index:\\\\n  code.push(\\\\n    \\\\\\\"proto.index=function \\\\\\\"+className+\\\\\\\"_index(\\\\\\\", args.join(), \\\\\\\"){return \\\\\\\"+index_str+\\\\\\\"}\\\\\\\")\\\\n\\\\n  //view.hi():\\\\n  code.push(\\\\\\\"proto.hi=function \\\\\\\"+className+\\\\\\\"_hi(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return [\\\\\\\"(typeof i\\\\\\\",i,\\\\\\\"!=='number'||i\\\\\\\",i,\\\\\\\"<0)?this.shape[\\\\\\\", i, \\\\\\\"]:i\\\\\\\", i,\\\\\\\"|0\\\\\\\"].join(\\\\\\\"\\\\\\\")\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"this.stride[\\\\\\\"+i + \\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",this.offset)}\\\\\\\")\\\\n\\\\n  //view.lo():\\\\n  var a_vars = indices.map(function(i) { return \\\\\\\"a\\\\\\\"+i+\\\\\\\"=this.shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\" })\\\\n  var c_vars = indices.map(function(i) { return \\\\\\\"c\\\\\\\"+i+\\\\\\\"=this.stride[\\\\\\\"+i+\\\\\\\"]\\\\\\\" })\\\\n  code.push(\\\\\\\"proto.lo=function \\\\\\\"+className+\\\\\\\"_lo(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){var b=this.offset,d=0,\\\\\\\"+a_vars.join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+c_vars.join(\\\\\\\",\\\\\\\"))\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    code.push(\\\\n\\\\\\\"if(typeof i\\\\\\\"+i+\\\\\\\"==='number'&&i\\\\\\\"+i+\\\\\\\">=0){\\\\\\\\\\\\nd=i\\\\\\\"+i+\\\\\\\"|0;\\\\\\\\\\\\nb+=c\\\\\\\"+i+\\\\\\\"*d;\\\\\\\\\\\\na\\\\\\\"+i+\\\\\\\"-=d}\\\\\\\")\\\\n  }\\\\n  code.push(\\\\\\\"return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"a\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"c\\\\\\\"+i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",b)}\\\\\\\")\\\\n\\\\n  //view.step():\\\\n  code.push(\\\\\\\"proto.step=function \\\\\\\"+className+\\\\\\\"_step(\\\\\\\"+args.join(\\\\\\\",\\\\\\\")+\\\\\\\"){var \\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"a\\\\\\\"+i+\\\\\\\"=this.shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"b\\\\\\\"+i+\\\\\\\"=this.stride[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",c=this.offset,d=0,ceil=Math.ceil\\\\\\\")\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    code.push(\\\\n\\\\\\\"if(typeof i\\\\\\\"+i+\\\\\\\"==='number'){\\\\\\\\\\\\nd=i\\\\\\\"+i+\\\\\\\"|0;\\\\\\\\\\\\nif(d<0){\\\\\\\\\\\\nc+=b\\\\\\\"+i+\\\\\\\"*(a\\\\\\\"+i+\\\\\\\"-1);\\\\\\\\\\\\na\\\\\\\"+i+\\\\\\\"=ceil(-a\\\\\\\"+i+\\\\\\\"/d)\\\\\\\\\\\\n}else{\\\\\\\\\\\\na\\\\\\\"+i+\\\\\\\"=ceil(a\\\\\\\"+i+\\\\\\\"/d)\\\\\\\\\\\\n}\\\\\\\\\\\\nb\\\\\\\"+i+\\\\\\\"*=d\\\\\\\\\\\\n}\\\\\\\")\\\\n  }\\\\n  code.push(\\\\\\\"return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"a\\\\\\\" + i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"b\\\\\\\" + i\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",c)}\\\\\\\")\\\\n\\\\n  //view.transpose():\\\\n  var tShape = new Array(dimension)\\\\n  var tStride = new Array(dimension)\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    tShape[i] = \\\\\\\"a[i\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    tStride[i] = \\\\\\\"b[i\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n  }\\\\n  code.push(\\\\\\\"proto.transpose=function \\\\\\\"+className+\\\\\\\"_transpose(\\\\\\\"+args+\\\\\\\"){\\\\\\\"+\\\\n    args.map(function(n,idx) { return n + \\\\\\\"=(\\\\\\\" + n + \\\\\\\"===undefined?\\\\\\\" + idx + \\\\\\\":\\\\\\\" + n + \\\\\\\"|0)\\\\\\\"}).join(\\\\\\\";\\\\\\\"),\\\\n    \\\\\\\"var a=this.shape,b=this.stride;return new \\\\\\\"+className+\\\\\\\"(this.data,\\\\\\\"+tShape.join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+tStride.join(\\\\\\\",\\\\\\\")+\\\\\\\",this.offset)}\\\\\\\")\\\\n\\\\n  //view.pick():\\\\n  code.push(\\\\\\\"proto.pick=function \\\\\\\"+className+\\\\\\\"_pick(\\\\\\\"+args+\\\\\\\"){var a=[],b=[],c=this.offset\\\\\\\")\\\\n  for(var i=0; i<dimension; ++i) {\\\\n    code.push(\\\\\\\"if(typeof i\\\\\\\"+i+\\\\\\\"==='number'&&i\\\\\\\"+i+\\\\\\\">=0){c=(c+this.stride[\\\\\\\"+i+\\\\\\\"]*i\\\\\\\"+i+\\\\\\\")|0}else{a.push(this.shape[\\\\\\\"+i+\\\\\\\"]);b.push(this.stride[\\\\\\\"+i+\\\\\\\"])}\\\\\\\")\\\\n  }\\\\n  code.push(\\\\\\\"var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}\\\\\\\")\\\\n\\\\n  //Add return statement\\\\n  code.push(\\\\\\\"return function construct_\\\\\\\"+className+\\\\\\\"(data,shape,stride,offset){return new \\\\\\\"+className+\\\\\\\"(data,\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"shape[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",\\\\\\\"+\\\\n    indices.map(function(i) {\\\\n      return \\\\\\\"stride[\\\\\\\"+i+\\\\\\\"]\\\\\\\"\\\\n    }).join(\\\\\\\",\\\\\\\")+\\\\\\\",offset)}\\\\\\\")\\\\n\\\\n  //Compile procedure\\\\n  var procedure = new Function(\\\\\\\"CTOR_LIST\\\\\\\", \\\\\\\"ORDER\\\\\\\", code.join(\\\\\\\"\\\\\\\\n\\\\\\\"))\\\\n  return procedure(CACHED_CONSTRUCTORS[dtype], order)\\\\n}\\\\n\\\\nfunction arrayDType(data) {\\\\n  if(isBuffer(data)) {\\\\n    return \\\\\\\"buffer\\\\\\\"\\\\n  }\\\\n  if(hasTypedArrays) {\\\\n    switch(Object.prototype.toString.call(data)) {\\\\n      case \\\\\\\"[object Float64Array]\\\\\\\":\\\\n        return \\\\\\\"float64\\\\\\\"\\\\n      case \\\\\\\"[object Float32Array]\\\\\\\":\\\\n        return \\\\\\\"float32\\\\\\\"\\\\n      case \\\\\\\"[object Int8Array]\\\\\\\":\\\\n        return \\\\\\\"int8\\\\\\\"\\\\n      case \\\\\\\"[object Int16Array]\\\\\\\":\\\\n        return \\\\\\\"int16\\\\\\\"\\\\n      case \\\\\\\"[object Int32Array]\\\\\\\":\\\\n        return \\\\\\\"int32\\\\\\\"\\\\n      case \\\\\\\"[object Uint8Array]\\\\\\\":\\\\n        return \\\\\\\"uint8\\\\\\\"\\\\n      case \\\\\\\"[object Uint16Array]\\\\\\\":\\\\n        return \\\\\\\"uint16\\\\\\\"\\\\n      case \\\\\\\"[object Uint32Array]\\\\\\\":\\\\n        return \\\\\\\"uint32\\\\\\\"\\\\n      case \\\\\\\"[object Uint8ClampedArray]\\\\\\\":\\\\n        return \\\\\\\"uint8_clamped\\\\\\\"\\\\n    }\\\\n  }\\\\n  if(Array.isArray(data)) {\\\\n    return \\\\\\\"array\\\\\\\"\\\\n  }\\\\n  return \\\\\\\"generic\\\\\\\"\\\\n}\\\\n\\\\nvar CACHED_CONSTRUCTORS = {\\\\n  \\\\\\\"float32\\\\\\\":[],\\\\n  \\\\\\\"float64\\\\\\\":[],\\\\n  \\\\\\\"int8\\\\\\\":[],\\\\n  \\\\\\\"int16\\\\\\\":[],\\\\n  \\\\\\\"int32\\\\\\\":[],\\\\n  \\\\\\\"uint8\\\\\\\":[],\\\\n  \\\\\\\"uint16\\\\\\\":[],\\\\n  \\\\\\\"uint32\\\\\\\":[],\\\\n  \\\\\\\"array\\\\\\\":[],\\\\n  \\\\\\\"uint8_clamped\\\\\\\":[],\\\\n  \\\\\\\"buffer\\\\\\\":[],\\\\n  \\\\\\\"generic\\\\\\\":[]\\\\n}\\\\n\\\\n;(function() {\\\\n  for(var id in CACHED_CONSTRUCTORS) {\\\\n    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))\\\\n  }\\\\n});\\\\n\\\\nfunction wrappedNDArrayCtor(data, shape, stride, offset) {\\\\n  if(data === undefined) {\\\\n    var ctor = CACHED_CONSTRUCTORS.array[0]\\\\n    return ctor([])\\\\n  } else if(typeof data === \\\\\\\"number\\\\\\\") {\\\\n    data = [data]\\\\n  }\\\\n  if(shape === undefined) {\\\\n    shape = [ data.length ]\\\\n  }\\\\n  var d = shape.length\\\\n  if(stride === undefined) {\\\\n    stride = new Array(d)\\\\n    for(var i=d-1, sz=1; i>=0; --i) {\\\\n      stride[i] = sz\\\\n      sz *= shape[i]\\\\n    }\\\\n  }\\\\n  if(offset === undefined) {\\\\n    offset = 0\\\\n    for(var i=0; i<d; ++i) {\\\\n      if(stride[i] < 0) {\\\\n        offset -= (shape[i]-1)*stride[i]\\\\n      }\\\\n    }\\\\n  }\\\\n  var dtype = arrayDType(data)\\\\n  var ctor_list = CACHED_CONSTRUCTORS[dtype]\\\\n  while(ctor_list.length <= d+1) {\\\\n    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))\\\\n  }\\\\n  var ctor = ctor_list[d+1]\\\\n  return ctor(data, shape, stride, offset)\\\\n}\\\\n\\\\nmodule.exports = wrappedNDArrayCtor\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/node_modules/ndarray/ndarray.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/src/lib/chunk.js\\\":\\n/*!**************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/src/lib/chunk.js ***!\\n  \\\\**************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\nvar constants = __webpack_require__(/*! ./constants */ \\\\\\\"./node_modules/noa-engine/src/lib/constants.js\\\\\\\")\\\\nvar ndarray = __webpack_require__(/*! ndarray */ \\\\\\\"./node_modules/noa-engine/node_modules/ndarray/ndarray.js\\\\\\\")\\\\n\\\\n\\\\n\\\\nmodule.exports = Chunk\\\\n\\\\n\\\\n// shared references to terrain/object meshers\\\\nvar terrainMesher = __webpack_require__(/*! ./terrainMesher */ \\\\\\\"./node_modules/noa-engine/src/lib/terrainMesher.js\\\\\\\")\\\\nvar objectMesher = __webpack_require__(/*! ./objectMesher */ \\\\\\\"./node_modules/noa-engine/src/lib/objectMesher.js\\\\\\\")\\\\n\\\\n\\\\n\\\\n\\\\n/* \\\\n * \\\\n *   Chunk\\\\n * \\\\n *  Stores and manages voxel ids and flags for each voxel within chunk\\\\n *  See constants.js for internal data representation\\\\n * \\\\n */\\\\n\\\\n\\\\n\\\\n// data representation\\\\nvar ID_MASK = constants.ID_MASK\\\\n// var VAR_MASK = constants.VAR_MASK // NYI\\\\nvar SOLID_BIT = constants.SOLID_BIT\\\\nvar OPAQUE_BIT = constants.OPAQUE_BIT\\\\nvar OBJECT_BIT = constants.OBJECT_BIT\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n *\\\\n *    Chunk constructor\\\\n *\\\\n */\\\\n\\\\nfunction Chunk(noa, id, i, j, k, size) {\\\\n    this.id = id\\\\n\\\\n    this.noa = noa\\\\n    this.isDisposed = false\\\\n    this.isGenerated = false\\\\n    this.inInvalid = false\\\\n    this.octreeBlock = null\\\\n    this._terrainMesh = null\\\\n\\\\n    this.isEmpty = false\\\\n    this.isFull = false\\\\n\\\\n    // packed data storage\\\\n    var s = size + 2 // 1 block of padding on each side\\\\n    var arr = new Uint16Array(s * s * s)\\\\n    this.array = new ndarray(arr, [s, s, s])\\\\n    this.i = i\\\\n    this.j = j\\\\n    this.k = k\\\\n    this.size = size\\\\n    this.x = i * size\\\\n    this.y = j * size\\\\n    this.z = k * size\\\\n\\\\n    // flags to track if things need re-meshing\\\\n    this._terrainDirty = false\\\\n    this._objectsDirty = false\\\\n\\\\n    // init references shared among all chunks\\\\n    setBlockLookups(noa)\\\\n\\\\n    // build unpadded and transposed array views for internal use\\\\n    rebuildArrayViews(this)\\\\n\\\\n    // adds some properties to the chunk for handling object meshes\\\\n    objectMesher.initChunk(this)\\\\n\\\\n}\\\\n\\\\n\\\\n\\\\n// Registry lookup references shared by all chunks\\\\nvar solidLookup\\\\nvar opaqueLookup\\\\nvar objectMeshLookup\\\\nvar blockHandlerLookup\\\\n\\\\nfunction setBlockLookups(noa) {\\\\n    solidLookup = noa.registry._solidityLookup\\\\n    opaqueLookup = noa.registry._opacityLookup\\\\n    objectMeshLookup = noa.registry._blockMeshLookup\\\\n    blockHandlerLookup = noa.registry._blockHandlerLookup\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n *\\\\n *    Chunk API\\\\n *\\\\n */\\\\n\\\\n// get/set deal with block IDs, so that this class acts like an ndarray\\\\n\\\\nChunk.prototype.get = function (x, y, z) {\\\\n    return ID_MASK & this._unpaddedView.get(x, y, z)\\\\n}\\\\n\\\\nChunk.prototype.getSolidityAt = function (x, y, z) {\\\\n    return (SOLID_BIT & this._unpaddedView.get(x, y, z)) ? true : false\\\\n}\\\\n\\\\nChunk.prototype.set = function (x, y, z, id) {\\\\n    var oldID = this._unpaddedView.get(x, y, z)\\\\n    var oldIDnum = oldID & ID_MASK\\\\n    if (id === oldIDnum) return\\\\n\\\\n    // manage data\\\\n    var newID = packID(id)\\\\n    this._unpaddedView.set(x, y, z, newID)\\\\n\\\\n    // handle object meshes\\\\n    if (oldID & OBJECT_BIT) removeObjectBlock(this, x, y, z)\\\\n    if (newID & OBJECT_BIT) addObjectBlock(this, id, x, y, z)\\\\n\\\\n    // track full/emptyness\\\\n    if (newID !== 0) this.isEmpty = false\\\\n    if (!(newID & OPAQUE_BIT)) this.isFull = false\\\\n\\\\n    // call block handlers\\\\n    callBlockHandler(this, oldIDnum, 'onUnset', x, y, z)\\\\n    callBlockHandler(this, id, 'onSet', x, y, z)\\\\n\\\\n    // mark terrain dirty unless neither block was terrain\\\\n    if (isTerrain(oldID) || isTerrain(newID)) this._terrainDirty = true\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// helper to call handler of a given type at a particular xyz\\\\n\\\\nfunction callBlockHandler(chunk, blockID, type, x, y, z) {\\\\n    var hobj = blockHandlerLookup[blockID]\\\\n    if (!hobj) return\\\\n    var handler = hobj[type]\\\\n    if (!handler) return\\\\n    // ignore all handlers if block is in chunk's edge padding blocks\\\\n    var s = chunk.size\\\\n    if (x < 0 || y < 0 || z < 0 || x >= s || y >= s || z >= s) return\\\\n    handler(chunk.x + x, chunk.y + y, chunk.z + z)\\\\n}\\\\n\\\\n\\\\n\\\\n// Convert chunk's voxel terrain into a babylon.js mesh\\\\n// Used internally, but needs to be public so mesh-building hacks can call it\\\\nChunk.prototype.mesh = function (matGetter, colGetter, useAO, aoVals, revAoVal) {\\\\n    return terrainMesher.meshChunk(this, matGetter, colGetter, useAO, aoVals, revAoVal)\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// gets called by World when this chunk has been queued for remeshing\\\\nChunk.prototype.updateMeshes = function () {\\\\n    if (this._terrainDirty) {\\\\n        this.noa.rendering.removeTerrainMesh(this)\\\\n        var mesh = this.mesh()\\\\n        if (mesh) this.noa.rendering.addTerrainMesh(this, mesh)\\\\n        this._terrainDirty = false\\\\n    }\\\\n    if (this._objectsDirty) {\\\\n        objectMesher.buildObjectMesh(this)\\\\n        this._objectsDirty = false\\\\n    }\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// helper to determine if a block counts as \\\\\\\"terrain\\\\\\\" (non-air, non-object)\\\\nfunction isTerrain(id) {\\\\n    if (id === 0) return false\\\\n    // treat object blocks as terrain if solid (they affect AO)\\\\n    if (id & OBJECT_BIT) return !!(id & SOLID_BIT)\\\\n    return true\\\\n}\\\\n\\\\n// helper to pack a block ID into the internally stored form, given lookup tables\\\\nfunction packID(id) {\\\\n    var newID = id\\\\n    if (solidLookup[id]) newID |= SOLID_BIT\\\\n    if (opaqueLookup[id]) newID |= OPAQUE_BIT\\\\n    if (objectMeshLookup[id]) newID |= OBJECT_BIT\\\\n    return newID\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n * \\\\n *      Init\\\\n * \\\\n *  Gets called right after client filled the voxel ID data array\\\\n */\\\\n\\\\n\\\\n\\\\nChunk.prototype.initData = function () {\\\\n    // remake other views, assuming that data has changed\\\\n    rebuildArrayViews(this)\\\\n    // flags for tracking if chunk is entirely opaque or transparent\\\\n    var fullyOpaque = OPAQUE_BIT\\\\n    var fullyAir = true\\\\n\\\\n    // init everything in one big scan\\\\n    var arr = this.array\\\\n    var data = arr.data\\\\n    var len = arr.shape[0]\\\\n    var kstride = arr.stride[2]\\\\n    for (var i = 0; i < len; ++i) {\\\\n        var edge1 = (i === 0 || i === len - 1)\\\\n        for (var j = 0; j < len; ++j) {\\\\n            var d0 = arr.index(i, j, 0)\\\\n            var edge2 = edge1 || (j === 0 || j === len - 1)\\\\n            for (var k = 0; k < len; ++k, d0 += kstride) {\\\\n                // pull raw ID - could in principle be packed, so mask it\\\\n                var id = data[d0] & ID_MASK\\\\n                // skip air blocks\\\\n                if (id === 0) {\\\\n                    fullyOpaque = 0\\\\n                    continue\\\\n                }\\\\n                // store ID as packed internal representation\\\\n                var packed = packID(id) | 0\\\\n                data[d0] = packed\\\\n                // track whether chunk is entirely full or empty\\\\n                fullyOpaque &= packed\\\\n                fullyAir = false\\\\n                // within unpadded view, handle object blocks and handlers\\\\n                var atEdge = edge2 || (k === 0 || k === len - 1)\\\\n                if (!atEdge) {\\\\n                    if (OBJECT_BIT & packed) {\\\\n                        addObjectBlock(this, id, i - 1, j - 1, k - 1)\\\\n                    }\\\\n                    callBlockHandler(this, id, 'onLoad', i - 1, j - 1, k - 1)\\\\n                }\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n    this.isFull = !!(fullyOpaque & OPAQUE_BIT)\\\\n    this.isEmpty = !!(fullyAir)\\\\n    this._terrainDirty = !(this.isFull || this.isEmpty)\\\\n\\\\n    this.isGenerated = true\\\\n}\\\\n\\\\n\\\\n// helper to rebuild several transformed views on the data array\\\\n\\\\nfunction rebuildArrayViews(chunk) {\\\\n    var arr = chunk.array\\\\n    var size = chunk.size\\\\n    chunk._unpaddedView = arr.lo(1, 1, 1).hi(size, size, size)\\\\n}\\\\n\\\\n\\\\n\\\\n// accessors related to meshing\\\\n\\\\nfunction addObjectBlock(chunk, id, x, y, z) {\\\\n    objectMesher.addObjectBlock(chunk, id, x, y, z)\\\\n    chunk._objectsDirty = true\\\\n}\\\\n\\\\nfunction removeObjectBlock(chunk, x, y, z) {\\\\n    objectMesher.removeObjectBlock(chunk, x, y, z)\\\\n    chunk._objectsDirty = true\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// dispose function - just clears properties and references\\\\n\\\\nChunk.prototype.dispose = function () {\\\\n    // look through the data for onUnload handlers\\\\n    callAllBlockHandlers(this, 'onUnload')\\\\n\\\\n    // let meshers dispose their stuff\\\\n    objectMesher.disposeChunk(this)\\\\n\\\\n    // apparently there's no way to dispose typed arrays, so just null everything\\\\n    this.array.data = null\\\\n    this.array = null\\\\n    this._unpaddedView = null\\\\n\\\\n    this.isGenerated = false\\\\n    this.isDisposed = true\\\\n}\\\\n\\\\n\\\\n// helper to call a given handler for all blocks in the chunk\\\\n\\\\nfunction callAllBlockHandlers(chunk, type) {\\\\n    var view = chunk._unpaddedView\\\\n    var data = view.data\\\\n    var si = view.stride[0]\\\\n    var sj = view.stride[1]\\\\n    var sk = view.stride[2]\\\\n    var size = view.shape[0]\\\\n    var d0 = view.offset\\\\n    for (var i = 0; i < size; ++i) {\\\\n        for (var j = 0; j < size; ++j) {\\\\n            for (var k = 0; k < size; ++k) {\\\\n                var id = ID_MASK & data[d0]\\\\n                callBlockHandler(chunk, id, type, i, j, k)\\\\n                d0 += sk\\\\n            }\\\\n            d0 -= sk * size\\\\n            d0 += sj\\\\n        }\\\\n        d0 -= sj * size\\\\n        d0 += si\\\\n    }\\\\n}\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/chunk.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/src/lib/constants.js\\\":\\n/*!******************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/src/lib/constants.js ***!\\n  \\\\******************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\nvar constants = {}\\\\nmodule.exports = constants\\\\n\\\\n\\\\n/* \\\\n *  Internal voxel data representation\\\\n *\\\\n *  Each voxel is stored as a Uint16.\\\\n *  Voxel id is stored in lowest bits, and flags stored in upper bits for fast retrieval\\\\n *  \\\\n *  Stores, from right to left:\\\\n *     9 bits of voxel ID\\\\n *     4 bits of variation (e.g. orientation)  --- Not yet being used!\\\\n *     1 bit solidity (i.e. physics-wise)\\\\n *     1 bit opacity (whether voxel obscures neighboring faces)\\\\n *     1 bit object marker (marks non-terrain blocks with custom meshes)\\\\n */\\\\n\\\\n\\\\nvar ID_BITS = 9\\\\nvar ID_MASK = (1 << ID_BITS) - 1\\\\n\\\\nvar VAR_BITS = 4\\\\nvar VAR_OFFSET = ID_BITS\\\\nvar VAR_MASK = ((1 << VAR_BITS) - 1) << VAR_OFFSET\\\\n\\\\nvar n = ID_BITS + VAR_BITS\\\\nvar SOLID_BIT = 1 << n++\\\\nvar OPAQUE_BIT = 1 << n++\\\\nvar OBJECT_BIT = 1 << n++\\\\n\\\\n// exports\\\\n\\\\nconstants.ID_MASK = ID_MASK\\\\nconstants.VAR_MASK = VAR_MASK\\\\nconstants.SOLID_BIT = SOLID_BIT\\\\nconstants.OPAQUE_BIT = OPAQUE_BIT\\\\nconstants.OBJECT_BIT = OBJECT_BIT\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/constants.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/src/lib/objectMesher.js\\\":\\n/*!*********************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/src/lib/objectMesher.js ***!\\n  \\\\*********************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\n\\\\nvar removeUnorderedListItem = __webpack_require__(/*! ./util */ \\\\\\\"./node_modules/noa-engine/src/lib/util.js\\\\\\\").removeUnorderedListItem\\\\n\\\\n\\\\nmodule.exports = new ObjectMesher()\\\\n\\\\n\\\\n// enable for profiling..\\\\nvar PROFILE = 0\\\\n\\\\n\\\\n\\\\n\\\\n// helper class to hold data about a single object mesh\\\\nfunction ObjMeshDat(id, x, y, z) {\\\\n    this.id = id | 0\\\\n    this.x = x | 0\\\\n    this.y = y | 0\\\\n    this.z = z | 0\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n * \\\\n * \\\\n *          Object meshing\\\\n *  Per-chunk handling of the creation/disposal of voxels with static meshes\\\\n * \\\\n * \\\\n */\\\\n\\\\n\\\\nfunction ObjectMesher() {\\\\n\\\\n\\\\n    // adds properties to the new chunk that will be used when processing\\\\n    this.initChunk = function (chunk) {\\\\n        chunk._objectBlocks = {}\\\\n        chunk._mergedObjectSystems = []\\\\n    }\\\\n\\\\n    this.disposeChunk = function (chunk) {\\\\n        removeCurrentSystems(chunk)\\\\n        chunk._objectBlocks = null\\\\n    }\\\\n\\\\n    function removeCurrentSystems(chunk) {\\\\n        var systems = chunk._mergedObjectSystems\\\\n        while (systems.length) {\\\\n            var sps = systems.pop()\\\\n            if (sps.mesh && chunk.octreeBlock && chunk.octreeBlock.entries) {\\\\n                removeUnorderedListItem(chunk.octreeBlock.entries, sps.mesh)\\\\n            }\\\\n            if (sps.mesh) sps.mesh.dispose()\\\\n            sps.dispose()\\\\n        }\\\\n    }\\\\n\\\\n\\\\n\\\\n    // accessors for the chunk to regester as object voxels are set/unset\\\\n    this.addObjectBlock = function (chunk, id, x, y, z) {\\\\n        var key = x + '|' + y + '|' + z\\\\n        chunk._objectBlocks[key] = new ObjMeshDat(id, x, y, z, null)\\\\n    }\\\\n\\\\n    this.removeObjectBlock = function (chunk, x, y, z) {\\\\n        var key = x + '|' + y + '|' + z\\\\n        if (chunk._objectBlocks[key]) delete chunk._objectBlocks[key]\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n    /*\\\\n     * \\\\n     *    main implementation - re-creates all needed object mesh instances\\\\n     * \\\\n     */\\\\n\\\\n    this.buildObjectMesh = function (chunk) {\\\\n        profile_hook('start')\\\\n        // remove the current (if any) sps/mesh\\\\n        removeCurrentSystems(chunk)\\\\n\\\\n        var scene = chunk.noa.rendering.getScene()\\\\n        var objectMeshLookup = chunk.noa.registry._blockMeshLookup\\\\n\\\\n        // preprocess everything to build lists of object block keys\\\\n        // hashed by material ID and then by block ID\\\\n        var matIndexes = {}\\\\n        for (var key in chunk._objectBlocks) {\\\\n            var blockDat = chunk._objectBlocks[key]\\\\n            var blockID = blockDat.id\\\\n            var mat = objectMeshLookup[blockID].material\\\\n            var matIndex = (mat) ? scene.materials.indexOf(mat) : -1\\\\n            if (!matIndexes[matIndex]) matIndexes[matIndex] = {}\\\\n            if (!matIndexes[matIndex][blockID]) matIndexes[matIndex][blockID] = []\\\\n            matIndexes[matIndex][blockID].push(key)\\\\n        }\\\\n        profile_hook('preprocess')\\\\n\\\\n        // data structure now looks like:\\\\n        // matIndexes = {\\\\n        //      2: {                    // i.e. 2nd material in scene\\\\n        //          14: {               // i.e. voxel ID 14 from registry\\\\n        //              [ '2|3|4' ]     // key of block's local coords\\\\n        //          }\\\\n        //      }\\\\n        // }\\\\n\\\\n        var x0 = chunk.i * chunk.size\\\\n        var y0 = chunk.j * chunk.size\\\\n        var z0 = chunk.k * chunk.size\\\\n\\\\n        // build one SPS for each material\\\\n        for (var ix in matIndexes) {\\\\n\\\\n            var meshHash = matIndexes[ix]\\\\n            var sps = buildSPSforMaterialIndex(chunk, scene, meshHash, x0, y0, z0)\\\\n            profile_hook('made SPS')\\\\n\\\\n            // build SPS into the scene\\\\n            var merged = sps.buildMesh()\\\\n            profile_hook('built mesh')\\\\n\\\\n            // finish up\\\\n            merged.material = (ix > -1) ? scene.materials[ix] : null\\\\n            merged.position.x = x0\\\\n            merged.position.y = y0\\\\n            merged.position.z = z0\\\\n            merged.freezeWorldMatrix()\\\\n            merged.freezeNormals()\\\\n\\\\n            chunk.octreeBlock.entries.push(merged)\\\\n            chunk._mergedObjectSystems.push(sps)\\\\n        }\\\\n\\\\n        profile_hook('end')\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n    function buildSPSforMaterialIndex(chunk, scene, meshHash, x0, y0, z0) {\\\\n        var blockHash = chunk._objectBlocks\\\\n        // base sps\\\\n        var sps = new BABYLON.SolidParticleSystem('object_sps_' + chunk.id, scene, {\\\\n            updatable: false,\\\\n        })\\\\n\\\\n        var blockHandlerLookup = chunk.noa.registry._blockHandlerLookup\\\\n        var objectMeshLookup = chunk.noa.registry._blockMeshLookup\\\\n\\\\n        // run through mesh hash adding shapes and position functions\\\\n        for (var blockID in meshHash) {\\\\n            var mesh = objectMeshLookup[blockID]\\\\n            var blockArr = meshHash[blockID]\\\\n            var count = blockArr.length\\\\n\\\\n            var handlerFn\\\\n            var handlers = blockHandlerLookup[blockID]\\\\n            if (handlers) handlerFn = handlers.onCustomMeshCreate\\\\n            // jshint -W083\\\\n            var setShape = function (particle, partIndex, shapeIndex) {\\\\n                var key = blockArr[shapeIndex]\\\\n                var dat = blockHash[key]\\\\n                // set global positions for the custom handler, if any\\\\n                particle.position.set(x0 + dat.x + 0.5, y0 + dat.y, z0 + dat.z + 0.5)\\\\n                if (handlerFn) handlerFn(particle, x0 + dat.x, y0 + dat.y, z0 + dat.z)\\\\n                // revert to local positions\\\\n                particle.position.x -= x0\\\\n                particle.position.y -= y0\\\\n                particle.position.z -= z0\\\\n            }\\\\n            sps.addShape(mesh, count, { positionFunction: setShape })\\\\n            blockArr.length = 0\\\\n        }\\\\n\\\\n        return sps\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nvar profile_hook = (function () {\\\\n    if (!PROFILE) return function () {}\\\\n    var every = 50\\\\n    var timer = new(__webpack_require__(/*! ./util */ \\\\\\\"./node_modules/noa-engine/src/lib/util.js\\\\\\\").Timer)(every, 'Object meshing')\\\\n    return function (state) {\\\\n        if (state === 'start') timer.start()\\\\n        else if (state === 'end') timer.report()\\\\n        else timer.add(state)\\\\n    }\\\\n})()\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/objectMesher.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/src/lib/terrainMesher.js\\\":\\n/*!**********************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/src/lib/terrainMesher.js ***!\\n  \\\\**********************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\n\\\\n\\\\n\\\\nmodule.exports = new TerrainMesher()\\\\n\\\\n\\\\n\\\\n\\\\n// enable for profiling..\\\\nvar PROFILE = 0\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n * \\\\n *          TERRAIN MESHER!!\\\\n * \\\\n */\\\\n\\\\n\\\\nfunction TerrainMesher() {\\\\n\\\\n    var greedyMesher = new GreedyMesher()\\\\n    var meshBuilder = new MeshBuilder()\\\\n\\\\n\\\\n    /*\\\\n     * \\\\n     * Entry point and high-level flow\\\\n     * \\\\n     */\\\\n\\\\n    this.meshChunk = function (chunk, matGetter, colGetter, ignoreMaterials, useAO, aoVals, revAoVal) {\\\\n        profile_hook('start')\\\\n        var noa = chunk.noa\\\\n\\\\n        // args\\\\n        var array = chunk.array\\\\n        var mats = matGetter || noa.registry.getBlockFaceMaterial\\\\n        var cols = colGetter || noa.registry._getMaterialVertexColor\\\\n        var ao = (useAO === undefined) ? noa.rendering.useAO : useAO\\\\n        var vals = aoVals || noa.rendering.aoVals\\\\n        var rev = isNaN(revAoVal) ? noa.rendering.revAoVal : revAoVal\\\\n\\\\n        // greedy mesher creates an array of Submesh structs\\\\n        var subMeshes = greedyMesher.mesh(array, mats, cols, ao, vals, rev)\\\\n\\\\n        // builds the babylon mesh that will be added to the scene\\\\n        var mesh\\\\n        if (Object.keys(subMeshes).length) {\\\\n            mesh = meshBuilder.build(chunk, subMeshes, ignoreMaterials)\\\\n            profile_hook('built terrain')\\\\n        }\\\\n\\\\n        profile_hook('end')\\\\n        return mesh || null\\\\n    }\\\\n\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n * \\\\n *  Submesh - holds one submesh worth of greedy-meshed data\\\\n * \\\\n *  Basically, the greedy mesher builds these and the mesh builder consumes them\\\\n * \\\\n */\\\\n\\\\nfunction Submesh(id) {\\\\n    this.id = id | 0\\\\n    this.positions = []\\\\n    this.indices = []\\\\n    this.normals = []\\\\n    this.colors = []\\\\n    this.uvs = []\\\\n}\\\\n\\\\nSubmesh.prototype.dispose = function () {\\\\n    this.positions = null\\\\n    this.indices = null\\\\n    this.normals = null\\\\n    this.colors = null\\\\n    this.uvs = null\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n * \\\\n *  Mesh Builder - turns an array of Submesh data into a \\\\n *  Babylon.js mesh/submeshes, ready to be added to the scene\\\\n * \\\\n */\\\\n\\\\nfunction MeshBuilder() {\\\\n\\\\n    var noa\\\\n\\\\n\\\\n    // core\\\\n    this.build = function (chunk, meshdata, ignoreMaterials) {\\\\n        noa = chunk.noa\\\\n\\\\n        // preprocess meshdata entries to merge those that will use default terrain material\\\\n        var mergeCriteria = function (mdat) {\\\\n            if (ignoreMaterials) return true\\\\n            if (mdat.renderMat) return false\\\\n            var url = noa.registry.getMaterialTexture(mdat.id)\\\\n            var alpha = noa.registry.getMaterialData(mdat.id).alpha\\\\n            if (url || alpha < 1) return false\\\\n        }\\\\n        mergeSubmeshes(meshdata, mergeCriteria)\\\\n\\\\n        // now merge everything, keeping track of vertices/indices/materials\\\\n        var results = mergeSubmeshes(meshdata, () => true)\\\\n\\\\n        // merge sole remaining submesh instance into a babylon mesh\\\\n        var mdat = meshdata[results.mergedID]\\\\n        var name = 'chunk_' + chunk.id\\\\n        var mats = results.matIDs.map(id => getTerrainMaterial(id, ignoreMaterials))\\\\n        var mesh = buildMeshFromSubmesh(mdat, name, mats, results.vertices, results.indices)\\\\n\\\\n        // position, freeze and exit\\\\n        var x = chunk.i * chunk.size\\\\n        var y = chunk.j * chunk.size\\\\n        var z = chunk.k * chunk.size\\\\n        mesh.position.x = x\\\\n        mesh.position.y = y\\\\n        mesh.position.z = z\\\\n\\\\n        mesh.freezeWorldMatrix()\\\\n        mesh.freezeNormals()\\\\n        return mesh\\\\n    }\\\\n\\\\n\\\\n\\\\n    // this version builds a parent mesh + child meshes, rather than\\\\n    // one big mesh with submeshes and a multimaterial.\\\\n    // This should be obsolete, unless the first one has problems..\\\\n    this.buildWithoutMultimats = function (chunk, meshdata, ignoreMaterials) {\\\\n        noa = chunk.noa\\\\n\\\\n        // preprocess meshdata entries to merge those that use default terrain material\\\\n        var mergeCriteria = function (mdat) {\\\\n            if (ignoreMaterials) return true\\\\n            if (mdat.renderMat) return false\\\\n            var url = noa.registry.getMaterialTexture(mdat.id)\\\\n            var alpha = noa.registry.getMaterialData(mdat.id).alpha\\\\n            if (url || alpha < 1) return false\\\\n        }\\\\n        mergeSubmeshes(meshdata, mergeCriteria)\\\\n\\\\n        // go through (remaining) meshdata entries and create a mesh for each\\\\n        // call the first one the parent, and attach others to it\\\\n        var parent = null\\\\n        var keylist = Object.keys(meshdata)\\\\n        for (var i = 0; i < keylist.length; ++i) {\\\\n            var mdat = meshdata[keylist[i]]\\\\n            var matID = mdat.id\\\\n            var mat = getTerrainMaterial(matID, ignoreMaterials)\\\\n            var name = 'chunk_inner_' + chunk.id + ' ' + matID\\\\n            var mesh = buildMeshFromSubmesh(mdat, name, [mat])\\\\n\\\\n            if (!parent) {\\\\n                parent = mesh\\\\n                // position the parent globally\\\\n                var x = chunk.i * chunk.size\\\\n                var y = chunk.j * chunk.size\\\\n                var z = chunk.k * chunk.size\\\\n                parent.position.x = x\\\\n                parent.position.y = y\\\\n                parent.position.z = z\\\\n            } else {\\\\n                mesh.parent = parent\\\\n            }\\\\n\\\\n            mesh.freezeWorldMatrix()\\\\n            mesh.freezeNormals()\\\\n        }\\\\n\\\\n        return parent\\\\n    }\\\\n\\\\n\\\\n\\\\n    // given a set of submesh objects, merge all those that \\\\n    // meet some criteria into the first such submesh\\\\n    //      modifies meshDataList in place!\\\\n    function mergeSubmeshes(meshDataList, criteria) {\\\\n        var vertices = []\\\\n        var indices = []\\\\n        var matIDs = []\\\\n\\\\n        var keylist = Object.keys(meshDataList)\\\\n        var target = null\\\\n        var targetID\\\\n        for (var i = 0; i < keylist.length; ++i) {\\\\n            var mdat = meshDataList[keylist[i]]\\\\n            if (!criteria(mdat)) continue\\\\n\\\\n            vertices.push(mdat.positions.length)\\\\n            indices.push(mdat.indices.length)\\\\n            matIDs.push(mdat.id)\\\\n\\\\n            if (!target) {\\\\n                target = mdat\\\\n                targetID = keylist[i]\\\\n\\\\n            } else {\\\\n                var indexOffset = target.positions.length / 3\\\\n                // merge data in \\\\\\\"mdat\\\\\\\" onto \\\\\\\"target\\\\\\\"\\\\n                target.positions = target.positions.concat(mdat.positions)\\\\n                target.normals = target.normals.concat(mdat.normals)\\\\n                target.colors = target.colors.concat(mdat.colors)\\\\n                target.uvs = target.uvs.concat(mdat.uvs)\\\\n                // indices must be offset relative to data being merged onto\\\\n                for (var j = 0, len = mdat.indices.length; j < len; ++j) {\\\\n                    target.indices.push(mdat.indices[j] + indexOffset)\\\\n                }\\\\n                // get rid of entry that's been merged\\\\n                mdat.dispose()\\\\n                delete meshDataList[keylist[i]]\\\\n            }\\\\n        }\\\\n\\\\n        return {\\\\n            mergedID: targetID,\\\\n            vertices: vertices,\\\\n            indices: indices,\\\\n            matIDs: matIDs,\\\\n        }\\\\n    }\\\\n\\\\n\\\\n\\\\n    function buildMeshFromSubmesh(submesh, name, mats, verts, inds) {\\\\n\\\\n        // base mesh and vertexData object\\\\n        var scene = noa.rendering.getScene()\\\\n        var mesh = new BABYLON.Mesh(name, scene)\\\\n        var vdat = new BABYLON.VertexData()\\\\n        vdat.positions = submesh.positions\\\\n        vdat.indices = submesh.indices\\\\n        vdat.normals = submesh.normals\\\\n        vdat.colors = submesh.colors\\\\n        vdat.uvs = submesh.uvs\\\\n        vdat.applyToMesh(mesh)\\\\n        submesh.dispose()\\\\n\\\\n        if (mats.length === 1) {\\\\n            // if only one material ID, assign as a regular mesh and return\\\\n            mesh.material = mats[0]\\\\n\\\\n        } else {\\\\n            // else we need to make a multimaterial and define (babylon) submeshes\\\\n            var multiMat = new BABYLON.MultiMaterial('multimat ' + name, scene)\\\\n            mesh.subMeshes = []\\\\n            // var totalVerts = vdat.positions.length\\\\n            // var totalInds = vdat.indices.length\\\\n            var vertStart = 0\\\\n            var indStart = 0\\\\n            for (var i = 0; i < mats.length; i++) {\\\\n                multiMat.subMaterials[i] = mats[i]\\\\n                var sub = new BABYLON.SubMesh(i, vertStart, verts[i], indStart, inds[i], mesh)\\\\n                mesh.subMeshes[i] = sub\\\\n                vertStart += verts[i]\\\\n                indStart += inds[i]\\\\n            }\\\\n            mesh.material = multiMat\\\\n        }\\\\n\\\\n        return mesh\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n    //                         Material wrangling\\\\n\\\\n\\\\n    var materialCache = {}\\\\n\\\\n    // manage materials/textures to avoid duplicating them\\\\n    function getTerrainMaterial(matID, ignore) {\\\\n        if (ignore) return noa.rendering.flatMaterial\\\\n        var name = 'terrain mat ' + matID\\\\n        if (!materialCache[name]) materialCache[name] = makeTerrainMaterial(matID)\\\\n        return materialCache[name]\\\\n    }\\\\n\\\\n\\\\n    // canonical function to make a terrain material\\\\n    function makeTerrainMaterial(id) {\\\\n        // if user-specified render material is defined, use it\\\\n        var matData = noa.registry.getMaterialData(id)\\\\n        if (matData.renderMat) return matData.renderMat\\\\n        // otherwise determine which built-in material to use\\\\n        var url = noa.registry.getMaterialTexture(id)\\\\n        var alpha = matData.alpha\\\\n        if (!url && alpha == 1) {\\\\n            // base material is fine for non-textured case, if no alpha\\\\n            return noa.rendering.flatMaterial\\\\n        }\\\\n        var mat = noa.rendering.flatMaterial.clone('terrain' + id)\\\\n        if (url) {\\\\n            var scene = noa.rendering.getScene()\\\\n            var tex = new BABYLON.Texture(url, scene, true, false, BABYLON.Texture.NEAREST_SAMPLINGMODE)\\\\n            if (matData.textureAlpha) tex.hasAlpha = true\\\\n            mat.diffuseTexture = tex\\\\n        }\\\\n        if (matData.alpha < 1) {\\\\n            mat.alpha = matData.alpha\\\\n        }\\\\n        return mat\\\\n    }\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n *    Greedy voxel meshing algorithm\\\\n *        based initially on algo by Mikola Lysenko:\\\\n *          http://0fps.net/2012/07/07/meshing-minecraft-part-2/\\\\n *          but evolved quite a bit since then\\\\n *        AO handling by me, stitched together out of cobwebs and dreams\\\\n *    \\\\n *    Arguments:\\\\n *        arr: 3D ndarray of dimensions X,Y,Z\\\\n *             packed with solidity/opacity booleans in higher bits\\\\n *        getMaterial: function( blockID, dir )\\\\n *             returns a material ID based on block id and which cube face it is\\\\n *             (assume for now that each mat ID should get its own mesh)\\\\n *        getColor: function( materialID )\\\\n *             looks up a color (3-array) by material ID\\\\n *             TODO: replace this with a lookup array?\\\\n *        doAO: whether or not to bake ambient occlusion into vertex colors\\\\n *        aoValues: array[3] of color multipliers for AO (least to most occluded)\\\\n *        revAoVal: \\\\\\\"reverse ao\\\\\\\" - color multiplier for unoccluded exposed edges\\\\n *\\\\n *    Return object: array of mesh objects keyed by material ID\\\\n *        arr[id] = {\\\\n *          id:       material id for mesh\\\\n *          vertices: ints, range 0 .. X/Y/Z\\\\n *          indices:  ints\\\\n *          normals:  ints,   -1 .. 1\\\\n *          colors:   floats,  0 .. 1\\\\n *          uvs:      floats,  0 .. X/Y/Z\\\\n *        }\\\\n */\\\\n\\\\nfunction GreedyMesher() {\\\\n\\\\n    // data representation constants\\\\n    var constants = __webpack_require__(/*! ./constants */ \\\\\\\"./node_modules/noa-engine/src/lib/constants.js\\\\\\\")\\\\n\\\\n    var ID_MASK = constants.ID_MASK\\\\n    // var VAR_MASK = constants.VAR_MASK // NYI\\\\n    var SOLID_BIT = constants.SOLID_BIT\\\\n    var OPAQUE_BIT = constants.OPAQUE_BIT\\\\n    var OBJECT_BIT = constants.OBJECT_BIT\\\\n\\\\n\\\\n    var maskCache = new Int16Array(16)\\\\n    var aomaskCache = new Uint16Array(16)\\\\n\\\\n\\\\n\\\\n\\\\n    this.mesh = function (arr, getMaterial, getColor, doAO, aoValues, revAoVal) {\\\\n\\\\n        // return object, holder for Submeshes\\\\n        var subMeshes = {}\\\\n\\\\n        // precalc how to apply AO packing in first masking function\\\\n        var skipReverseAO = (doAO && (revAoVal === aoValues[0]))\\\\n        var aoPackFcn\\\\n        if (doAO) aoPackFcn = (skipReverseAO) ? packAOMaskNoReverse : packAOMask\\\\n\\\\n\\\\n        //Sweep over each axis, mapping axes to [d,u,v]\\\\n        for (var d = 0; d < 3; ++d) {\\\\n            var u = (d + 1) % 3\\\\n            var v = (d + 2) % 3\\\\n\\\\n            // make transposed ndarray so index i is the axis we're sweeping\\\\n            var arrT = arr.transpose(d, u, v).lo(1, 1, 1).hi(arr.shape[d] - 2, arr.shape[u] - 2, arr.shape[v] - 2)\\\\n\\\\n            // shorten len0 by 1 so faces at edges don't get drawn in both chunks\\\\n            var len0 = arrT.shape[0] - 1\\\\n            var len1 = arrT.shape[1]\\\\n            var len2 = arrT.shape[2]\\\\n\\\\n            // create bigger mask arrays as needed\\\\n            if (maskCache.length < len1 * len2) {\\\\n                maskCache = new Int16Array(len1 * len2)\\\\n                aomaskCache = new Uint16Array(len1 * len2)\\\\n            }\\\\n\\\\n            // iterate along current major axis..\\\\n            for (var i = 0; i <= len0; ++i) {\\\\n\\\\n                // fills mask and aomask arrays with values\\\\n                constructMeshMasks(i, d, arrT, getMaterial, aoPackFcn)\\\\n                profile_hook('built masks')\\\\n\\\\n                // parses the masks to do greedy meshing\\\\n                constructMeshDataFromMasks(i, d, u, v, len1, len2,\\\\n                    doAO, subMeshes, getColor, aoValues, revAoVal)\\\\n\\\\n                profile_hook('build submeshes')\\\\n            }\\\\n        }\\\\n\\\\n        // done, return array of submeshes\\\\n        return subMeshes\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    //      Greedy meshing inner loop one\\\\n    //\\\\n    // iterating across ith 2d plane, with n being index into masks\\\\n\\\\n    function constructMeshMasks(i, d, arrT, getMaterial, aoPackFcn) {\\\\n        var len = arrT.shape[1]\\\\n        var mask = maskCache\\\\n        var aomask = aomaskCache\\\\n        // set up for quick array traversals\\\\n        var n = 0\\\\n        var data = arrT.data\\\\n        var dbase = arrT.index(i - 1, 0, 0)\\\\n        var istride = arrT.stride[0]\\\\n        var jstride = arrT.stride[1]\\\\n        var kstride = arrT.stride[2]\\\\n\\\\n        for (var k = 0; k < len; ++k) {\\\\n            var d0 = dbase\\\\n            dbase += kstride\\\\n            for (var j = 0; j < len; j++, n++, d0 += jstride) {\\\\n\\\\n                // mask[n] will represent the face needed between i-1,j,k and i,j,k\\\\n                // for now, assume we never have two faces in both directions\\\\n\\\\n                // IDs at i-1,j,k  and  i,j,k\\\\n                var id0 = data[d0]\\\\n                var id1 = data[d0 + istride]\\\\n\\\\n                var faceDir = getFaceDir(id0, id1)\\\\n                if (faceDir) {\\\\n                    // set regular mask value to material ID, sign indicating direction\\\\n                    mask[n] = (faceDir > 0) ?\\\\n                        getMaterial(id0 & ID_MASK, d * 2) :\\\\n                        -getMaterial(id1 & ID_MASK, d * 2 + 1)\\\\n\\\\n                    // if doing AO, precalculate AO level for each face into second mask\\\\n                    if (aoPackFcn) {\\\\n                        // i values in direction face is/isn't pointing\\\\n                        var ipos = (faceDir > 0) ? i : i - 1\\\\n                        var ineg = (faceDir > 0) ? i - 1 : i\\\\n\\\\n                        // this got so big I rolled it into a function\\\\n                        aomask[n] = aoPackFcn(arrT, ipos, ineg, j, k)\\\\n                    }\\\\n                } else {\\\\n                    // unneeded, mesher zeroes out mask as it goes\\\\n                    // mask[n] = 0\\\\n                }\\\\n\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n\\\\n\\\\n    function getFaceDir(id0, id1) {\\\\n        // no face if both blocks are opaque, or if ids match\\\\n        if (id0 === id1) return 0\\\\n        var op0 = id0 & OPAQUE_BIT\\\\n        var op1 = id1 & OPAQUE_BIT\\\\n        if (op0 && op1) return 0\\\\n        // if either block is opaque draw a face for it\\\\n        if (op0) return 1\\\\n        if (op1) return -1\\\\n        // if one block is air or an object block draw face for the other\\\\n        if (id1 === 0 || (id1 & OBJECT_BIT)) return 1\\\\n        if (id0 === 0 || (id0 & OBJECT_BIT)) return -1\\\\n        // only remaining case is two different non-opaque non-air blocks that are adjacent\\\\n        // really we should draw both faces here; draw neither for now\\\\n        return 0\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    //      Greedy meshing inner loop two\\\\n    //\\\\n    // construct data for mesh using the masks\\\\n\\\\n    function constructMeshDataFromMasks(i, d, u, v, len1, len2,\\\\n        doAO, submeshes, getColor, aoValues, revAoVal) {\\\\n        var n = 0\\\\n        var mask = maskCache\\\\n        var aomask = aomaskCache\\\\n\\\\n        // some logic is broken into helper functions for AO and non-AO\\\\n        // this fixes deopts in Chrome (for reasons unknown)\\\\n        var maskCompareFcn = (doAO) ? maskCompare : maskCompare_noAO\\\\n        var meshColorFcn = (doAO) ? pushMeshColors : pushMeshColors_noAO\\\\n\\\\n        for (var k = 0; k < len2; ++k) {\\\\n            var w = 1\\\\n            var h = 1\\\\n            for (var j = 0; j < len1; j += w, n += w) {\\\\n\\\\n                var maskVal = mask[n] | 0\\\\n                if (!maskVal) {\\\\n                    w = 1\\\\n                    continue\\\\n                }\\\\n                var ao = aomask[n] | 0\\\\n\\\\n                // Compute width and height of area with same mask/aomask values\\\\n                for (w = 1; w < len1 - j; ++w) {\\\\n                    if (!maskCompareFcn(n + w, mask, maskVal, aomask, ao)) break\\\\n                }\\\\n\\\\n                OUTER:\\\\n                    for (h = 1; h < len2 - k; ++h) {\\\\n                        for (var m = 0; m < w; ++m) {\\\\n                            var ix = n + m + h * len1\\\\n                            if (!maskCompareFcn(ix, mask, maskVal, aomask, ao)) break OUTER\\\\n                        }\\\\n                    }\\\\n\\\\n                // for testing: doing the following will disable greediness\\\\n                //w=h=1\\\\n\\\\n                // material and mesh for this face\\\\n                var matID = Math.abs(maskVal)\\\\n                if (!submeshes[matID]) submeshes[matID] = new Submesh(matID)\\\\n                var mesh = submeshes[matID]\\\\n                var colors = mesh.colors\\\\n                var c = getColor(matID)\\\\n\\\\n                // colors are pushed in helper function - avoids deopts\\\\n                // tridir is boolean for which way to split the quad into triangles\\\\n\\\\n                var triDir = meshColorFcn(colors, c, ao, aoValues, revAoVal)\\\\n\\\\n\\\\n                //Add quad, vertices = x -> x+du -> x+du+dv -> x+dv\\\\n                var x = [0, 0, 0]\\\\n                x[d] = i\\\\n                x[u] = j\\\\n                x[v] = k\\\\n                var du = [0, 0, 0]\\\\n                var dv = [0, 0, 0]\\\\n                du[u] = w\\\\n                dv[v] = h\\\\n\\\\n                var pos = mesh.positions\\\\n                pos.push(\\\\n                    x[0], x[1], x[2],\\\\n                    x[0] + du[0], x[1] + du[1], x[2] + du[2],\\\\n                    x[0] + du[0] + dv[0], x[1] + du[1] + dv[1], x[2] + du[2] + dv[2],\\\\n                    x[0] + dv[0], x[1] + dv[1], x[2] + dv[2])\\\\n\\\\n\\\\n                // add uv values, with the order and sign depending on \\\\n                // axis and direction so as to avoid mirror-image textures\\\\n                var dir = (maskVal > 0) ? 1 : -1\\\\n\\\\n                if (d === 2) {\\\\n                    mesh.uvs.push(\\\\n                        0, h,\\\\n                        -dir * w, h,\\\\n                        -dir * w, 0,\\\\n                        0, 0)\\\\n                } else {\\\\n                    mesh.uvs.push(\\\\n                        0, w,\\\\n                        0, 0,\\\\n                        dir * h, 0,\\\\n                        dir * h, w)\\\\n                }\\\\n\\\\n\\\\n                // Add indexes, ordered clockwise for the facing direction;\\\\n\\\\n                var vs = pos.length / 3 - 4\\\\n\\\\n                if (maskVal < 0) {\\\\n                    if (triDir) {\\\\n                        mesh.indices.push(vs, vs + 1, vs + 2, vs, vs + 2, vs + 3)\\\\n                    } else {\\\\n                        mesh.indices.push(vs + 1, vs + 2, vs + 3, vs, vs + 1, vs + 3)\\\\n                    }\\\\n                } else {\\\\n                    if (triDir) {\\\\n                        mesh.indices.push(vs, vs + 2, vs + 1, vs, vs + 3, vs + 2)\\\\n                    } else {\\\\n                        mesh.indices.push(vs + 3, vs + 1, vs, vs + 3, vs + 2, vs + 1)\\\\n                    }\\\\n                }\\\\n\\\\n\\\\n                // norms depend on which direction the mask was solid in..\\\\n                var norm0 = d === 0 ? dir : 0\\\\n                var norm1 = d === 1 ? dir : 0\\\\n                var norm2 = d === 2 ? dir : 0\\\\n\\\\n                // same norm for all vertices\\\\n                mesh.normals.push(\\\\n                    norm0, norm1, norm2,\\\\n                    norm0, norm1, norm2,\\\\n                    norm0, norm1, norm2,\\\\n                    norm0, norm1, norm2)\\\\n\\\\n\\\\n                //Zero-out mask\\\\n                for (var hx = 0; hx < h; ++hx) {\\\\n                    for (var wx = 0; wx < w; ++wx) {\\\\n                        mask[n + wx + hx * len1] = 0\\\\n                    }\\\\n                }\\\\n\\\\n            }\\\\n        }\\\\n    }\\\\n\\\\n\\\\n\\\\n    // Two helper functions with AO and non-AO implementations:\\\\n\\\\n    function maskCompare(index, mask, maskVal, aomask, aoVal) {\\\\n        if (maskVal !== mask[index]) return false\\\\n        if (aoVal !== aomask[index]) return false\\\\n        return true\\\\n    }\\\\n\\\\n    function maskCompare_noAO(index, mask, maskVal, aomask, aoVal) {\\\\n        if (maskVal !== mask[index]) return false\\\\n        return true\\\\n    }\\\\n\\\\n    function pushMeshColors_noAO(colors, c, ao, aoValues, revAoVal) {\\\\n        colors.push(c[0], c[1], c[2], 1)\\\\n        colors.push(c[0], c[1], c[2], 1)\\\\n        colors.push(c[0], c[1], c[2], 1)\\\\n        colors.push(c[0], c[1], c[2], 1)\\\\n        return true // triangle direction doesn't matter for non-AO\\\\n    }\\\\n\\\\n    function pushMeshColors(colors, c, ao, aoValues, revAoVal) {\\\\n        var ao00 = unpackAOMask(ao, 0, 0)\\\\n        var ao10 = unpackAOMask(ao, 1, 0)\\\\n        var ao11 = unpackAOMask(ao, 1, 1)\\\\n        var ao01 = unpackAOMask(ao, 0, 1)\\\\n        pushAOColor(colors, c, ao00, aoValues, revAoVal)\\\\n        pushAOColor(colors, c, ao10, aoValues, revAoVal)\\\\n        pushAOColor(colors, c, ao11, aoValues, revAoVal)\\\\n        pushAOColor(colors, c, ao01, aoValues, revAoVal)\\\\n\\\\n        // this bit is pretty magical..\\\\n        var triDir = true\\\\n        if (ao00 === ao11) {\\\\n            triDir = (ao01 === ao10) ? (ao01 == 2) : true\\\\n        } else {\\\\n            triDir = (ao01 === ao10) ? false : (ao00 + ao11 > ao01 + ao10)\\\\n        }\\\\n        return triDir\\\\n    }\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n    /* \\\\n     *  packAOMask:\\\\n     *\\\\n     *    For a given face, find occlusion levels for each vertex, then\\\\n     *    pack 4 such (2-bit) values into one Uint8 value\\\\n     * \\\\n     *  Occlusion levels:\\\\n     *    1 is flat ground, 2 is partial occlusion, 3 is max (corners)\\\\n     *    0 is \\\\\\\"reverse occlusion\\\\\\\" - an unoccluded exposed edge \\\\n     *  Packing order var(bit offset):\\\\n     *      a01(2)  -   a11(6)   ^  K\\\\n     *        -     -            +> J\\\\n     *      a00(0)  -   a10(4)\\\\n     */\\\\n\\\\n    // when skipping reverse AO, uses this simpler version of the function:\\\\n\\\\n    function packAOMaskNoReverse(data, ipos, ineg, j, k) {\\\\n        var a00 = 1\\\\n        var a01 = 1\\\\n        var a10 = 1\\\\n        var a11 = 1\\\\n        var solidBit = SOLID_BIT\\\\n\\\\n        // facing into a solid (non-opaque) block?\\\\n        var facingSolid = (solidBit & data.get(ipos, j, k))\\\\n\\\\n        // inc occlusion of vertex next to obstructed side\\\\n        if (data.get(ipos, j + 1, k) & solidBit) {++a10;++a11 }\\\\n        if (data.get(ipos, j - 1, k) & solidBit) {++a00;++a01 }\\\\n        if (data.get(ipos, j, k + 1) & solidBit) {++a01;++a11 }\\\\n        if (data.get(ipos, j, k - 1) & solidBit) {++a00;++a10 }\\\\n\\\\n        // treat corners differently based when facing a solid block\\\\n        if (facingSolid) {\\\\n            // always 2, or 3 in corners\\\\n            a11 = (a11 == 3 || data.get(ipos, j + 1, k + 1) & solidBit) ? 3 : 2\\\\n            a01 = (a01 == 3 || data.get(ipos, j - 1, k + 1) & solidBit) ? 3 : 2\\\\n            a10 = (a10 == 3 || data.get(ipos, j + 1, k - 1) & solidBit) ? 3 : 2\\\\n            a00 = (a00 == 3 || data.get(ipos, j - 1, k - 1) & solidBit) ? 3 : 2\\\\n        } else {\\\\n            // treat corner as occlusion 3 only if not occluded already\\\\n            if (a11 === 1 && (data.get(ipos, j + 1, k + 1) & solidBit)) { a11 = 2 }\\\\n            if (a01 === 1 && (data.get(ipos, j - 1, k + 1) & solidBit)) { a01 = 2 }\\\\n            if (a10 === 1 && (data.get(ipos, j + 1, k - 1) & solidBit)) { a10 = 2 }\\\\n            if (a00 === 1 && (data.get(ipos, j - 1, k - 1) & solidBit)) { a00 = 2 }\\\\n        }\\\\n\\\\n        return a11 << 6 | a10 << 4 | a01 << 2 | a00\\\\n    }\\\\n\\\\n    // more complicated AO packing when doing reverse AO on corners\\\\n\\\\n    function packAOMask(data, ipos, ineg, j, k) {\\\\n        var a00 = 1\\\\n        var a01 = 1\\\\n        var a10 = 1\\\\n        var a11 = 1\\\\n        var solidBit = SOLID_BIT\\\\n\\\\n        // facing into a solid (non-opaque) block?\\\\n        var facingSolid = (solidBit & data.get(ipos, j, k))\\\\n\\\\n        // inc occlusion of vertex next to obstructed side\\\\n        if (data.get(ipos, j + 1, k) & solidBit) {++a10;++a11 }\\\\n        if (data.get(ipos, j - 1, k) & solidBit) {++a00;++a01 }\\\\n        if (data.get(ipos, j, k + 1) & solidBit) {++a01;++a11 }\\\\n        if (data.get(ipos, j, k - 1) & solidBit) {++a00;++a10 }\\\\n\\\\n        if (facingSolid) {\\\\n            // always 2, or 3 in corners\\\\n            a11 = (a11 == 3 || data.get(ipos, j + 1, k + 1) & solidBit) ? 3 : 2\\\\n            a01 = (a01 == 3 || data.get(ipos, j - 1, k + 1) & solidBit) ? 3 : 2\\\\n            a10 = (a10 == 3 || data.get(ipos, j + 1, k - 1) & solidBit) ? 3 : 2\\\\n            a00 = (a00 == 3 || data.get(ipos, j - 1, k - 1) & solidBit) ? 3 : 2\\\\n        } else {\\\\n\\\\n            // check each corner, and if not present do reverse AO\\\\n            if (a11 === 1) {\\\\n                if (data.get(ipos, j + 1, k + 1) & solidBit) {\\\\n                    a11 = 2\\\\n                } else if (!(data.get(ineg, j, k + 1) & solidBit) ||\\\\n                    !(data.get(ineg, j + 1, k) & solidBit) ||\\\\n                    !(data.get(ineg, j + 1, k + 1) & solidBit)) {\\\\n                    a11 = 0\\\\n                }\\\\n            }\\\\n\\\\n            if (a10 === 1) {\\\\n                if (data.get(ipos, j + 1, k - 1) & solidBit) {\\\\n                    a10 = 2\\\\n                } else if (!(data.get(ineg, j, k - 1) & solidBit) ||\\\\n                    !(data.get(ineg, j + 1, k) & solidBit) ||\\\\n                    !(data.get(ineg, j + 1, k - 1) & solidBit)) {\\\\n                    a10 = 0\\\\n                }\\\\n            }\\\\n\\\\n            if (a01 === 1) {\\\\n                if (data.get(ipos, j - 1, k + 1) & solidBit) {\\\\n                    a01 = 2\\\\n                } else if (!(data.get(ineg, j, k + 1) & solidBit) ||\\\\n                    !(data.get(ineg, j - 1, k) & solidBit) ||\\\\n                    !(data.get(ineg, j - 1, k + 1) & solidBit)) {\\\\n                    a01 = 0\\\\n                }\\\\n            }\\\\n\\\\n            if (a00 === 1) {\\\\n                if (data.get(ipos, j - 1, k - 1) & solidBit) {\\\\n                    a00 = 2\\\\n                } else if (!(data.get(ineg, j, k - 1) & solidBit) ||\\\\n                    !(data.get(ineg, j - 1, k) & solidBit) ||\\\\n                    !(data.get(ineg, j - 1, k - 1) & solidBit)) {\\\\n                    a00 = 0\\\\n                }\\\\n            }\\\\n        }\\\\n\\\\n        return a11 << 6 | a10 << 4 | a01 << 2 | a00\\\\n    }\\\\n\\\\n\\\\n\\\\n    // unpack (2 bit) ao value from ao mask\\\\n    // see above for details\\\\n    function unpackAOMask(aomask, jpos, kpos) {\\\\n        var offset = jpos ? (kpos ? 6 : 4) : (kpos ? 2 : 0)\\\\n        return aomask >> offset & 3\\\\n    }\\\\n\\\\n\\\\n    // premultiply vertex colors by value depending on AO level\\\\n    // then push them into color array\\\\n    function pushAOColor(colors, baseCol, ao, aoVals, revAoVal) {\\\\n        var mult = (ao === 0) ? revAoVal : aoVals[ao - 1]\\\\n        colors.push(baseCol[0] * mult, baseCol[1] * mult, baseCol[2] * mult, 1)\\\\n    }\\\\n\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nvar profile_hook = (function () {\\\\n    if (!PROFILE) return function () {}\\\\n    var every = 50\\\\n    var timer = new(__webpack_require__(/*! ./util */ \\\\\\\"./node_modules/noa-engine/src/lib/util.js\\\\\\\").Timer)(every, 'Terrain meshing')\\\\n    return function (state) {\\\\n        if (state === 'start') timer.start()\\\\n        else if (state === 'end') timer.report()\\\\n        else timer.add(state)\\\\n    }\\\\n})()\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/terrainMesher.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/src/lib/util.js\\\":\\n/*!*************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/src/lib/util.js ***!\\n  \\\\*************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\n\\\\nmodule.exports = {\\\\n    Timer: Timer,\\\\n    removeUnorderedListItem: removeUnorderedListItem,\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n// helper to swap item to end and pop(), instead of splice()ing\\\\nfunction removeUnorderedListItem(list, item) {\\\\n    var i = list.indexOf(item)\\\\n    if (i < 0) { return }\\\\n    if (i === list.length - 1) {\\\\n        list.pop()\\\\n    } else {\\\\n        list[i] = list.pop()\\\\n    }\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n// simple thing for reporting time split up between several activities\\\\nfunction Timer(_every, _title) {\\\\n    var title = _title || ''\\\\n    var every = _every || 1\\\\n    var times = []\\\\n    var names = []\\\\n    var started = 0\\\\n    var last = 0\\\\n    var iter = 0\\\\n    var total = 0\\\\n    var clearNext = true\\\\n\\\\n    this.start = function () {\\\\n        if (clearNext) {\\\\n            times.length = names.length = 0\\\\n            clearNext = false\\\\n        }\\\\n        started = last = performance.now()\\\\n        iter++\\\\n    }\\\\n    this.add = function (name) {\\\\n        var t = performance.now()\\\\n        if (names.indexOf(name) < 0) names.push(name)\\\\n        var i = names.indexOf(name)\\\\n        if (!times[i]) times[i] = 0\\\\n        times[i] += t - last\\\\n        last = t\\\\n    }\\\\n    this.report = function () {\\\\n        total += performance.now() - started\\\\n        if (iter === every) {\\\\n            var head = title + ' total ' + (total / every).toFixed(2) + 'ms (avg, ' + every + ' runs)    '\\\\n            console.log(head, names.map(function (name, i) {\\\\n                return name + ': ' + (times[i] / every).toFixed(2) + 'ms    '\\\\n            }).join(''))\\\\n            clearNext = true\\\\n            iter = 0\\\\n            total = 0\\\\n        }\\\\n    }\\\\n}\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/util.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/noa-engine/src/lib/world.js\\\":\\n/*!**************************************************!*\\\\\\n  !*** ./node_modules/noa-engine/src/lib/world.js ***!\\n  \\\\**************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\n\\\"use strict\\\";\\neval(\\\"\\\\n\\\\nvar ndHash = __webpack_require__(/*! ndarray-hash */ \\\\\\\"./node_modules/noa-engine/node_modules/ndarray-hash/ndhash.js\\\\\\\")\\\\nvar EventEmitter = __webpack_require__(/*! events */ \\\\\\\"./node_modules/events/events.js\\\\\\\").EventEmitter\\\\nvar Chunk = __webpack_require__(/*! ./chunk */ \\\\\\\"./node_modules/noa-engine/src/lib/chunk.js\\\\\\\")\\\\n\\\\n\\\\nmodule.exports = function (noa, opts) {\\\\n    return new World(noa, opts)\\\\n}\\\\n\\\\n\\\\nvar PROFILE = 0\\\\nvar PROFILE_QUEUES = 0\\\\n\\\\n\\\\nvar defaultOptions = {\\\\n    chunkSize: 24,\\\\n    chunkAddDistance: 3,\\\\n    chunkRemoveDistance: 4\\\\n}\\\\n\\\\n/**\\\\n * Module for managing the world, and its chunks\\\\n * @class noa.world\\\\n * \\\\n * Emits:\\\\n *  * worldDataNeeded  (id, ndarray, x, y, z)\\\\n *  * chunkAdded (chunk)\\\\n *  * chunkChanged (chunk)\\\\n *  * chunkBeingRemoved (id, ndarray, userData)\\\\n */\\\\n\\\\nfunction World(noa, opts) {\\\\n    this.noa = noa\\\\n    opts = Object.assign({}, defaultOptions, opts)\\\\n\\\\n    this.userData = null\\\\n    this.playerChunkLoaded = false\\\\n    this.Chunk = Chunk\\\\n\\\\n    this.chunkSize = opts.chunkSize\\\\n    this.chunkAddDistance = opts.chunkAddDistance\\\\n    this.chunkRemoveDistance = opts.chunkRemoveDistance\\\\n    if (this.chunkRemoveDistance < this.chunkAddDistance) {\\\\n        this.chunkRemoveDistance = this.chunkAddDistance\\\\n    }\\\\n\\\\n    // internals\\\\n    this._chunkIDsToAdd = []\\\\n    this._chunkIDsToRemove = []\\\\n    this._chunkIDsInMemory = []\\\\n    this._chunkIDsToCreate = []\\\\n    this._chunkIDsToMesh = []\\\\n    this._chunkIDsToMeshFirst = []\\\\n    this._maxChunksPendingCreation = 20\\\\n    this._maxChunksPendingMeshing = 20\\\\n    this._maxProcessingPerTick = 9 // ms\\\\n    this._maxProcessingPerRender = 5 // ms\\\\n\\\\n    // triggers a short visit to the meshing queue before renders\\\\n    var self = this\\\\n    noa.on('beforeRender', function () { beforeRender(self) })\\\\n\\\\n    // actual chunk storage - hash size hard coded for now\\\\n    this._chunkHash = ndHash([1024, 1024, 1024])\\\\n\\\\n    // instantiate coord conversion functions based on the chunk size\\\\n    // use bit twiddling if chunk size is a power of 2\\\\n    var cs = this.chunkSize\\\\n    if (cs & cs - 1 === 0) {\\\\n        var shift = Math.log2(cs) | 0\\\\n        var mask = (cs - 1) | 0\\\\n        worldCoordToChunkCoord = coord => (coord >> shift) | 0\\\\n        worldCoordToChunkIndex = coord => (coord & mask) | 0\\\\n    } else {\\\\n        worldCoordToChunkCoord = coord => Math.floor(coord / cs) | 0\\\\n        worldCoordToChunkIndex = coord => (((coord % cs) + cs) % cs) | 0\\\\n    }\\\\n\\\\n}\\\\nWorld.prototype = Object.create(EventEmitter.prototype)\\\\n\\\\nvar worldCoordToChunkCoord\\\\nvar worldCoordToChunkIndex\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n *   PUBLIC API \\\\n */\\\\n\\\\n\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.getBlockID = function (x, y, z) {\\\\n    var chunk = this._getChunkByCoords(x, y, z)\\\\n    if (!chunk) return 0\\\\n\\\\n    var ix = worldCoordToChunkIndex(x)\\\\n    var iy = worldCoordToChunkIndex(y)\\\\n    var iz = worldCoordToChunkIndex(z)\\\\n    return chunk.get(ix, iy, iz)\\\\n}\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.getBlockSolidity = function (x, y, z) {\\\\n    var chunk = this._getChunkByCoords(x, y, z)\\\\n    if (!chunk) return 0\\\\n\\\\n    var ix = worldCoordToChunkIndex(x)\\\\n    var iy = worldCoordToChunkIndex(y)\\\\n    var iz = worldCoordToChunkIndex(z)\\\\n    return !!chunk.getSolidityAt(ix, iy, iz)\\\\n}\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.getBlockOpacity = function (x, y, z) {\\\\n    var id = this.getBlockID(x, y, z)\\\\n    return this.noa.registry.getBlockOpacity(id)\\\\n}\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.getBlockFluidity = function (x, y, z) {\\\\n    var id = this.getBlockID(x, y, z)\\\\n    return this.noa.registry.getBlockFluidity(id)\\\\n}\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.getBlockProperties = function (x, y, z) {\\\\n    var id = this.getBlockID(x, y, z)\\\\n    return this.noa.registry.getBlockProps(id)\\\\n}\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.getBlockObjectMesh = function (x, y, z) {\\\\n    var chunk = this._getChunkByCoords(x, y, z)\\\\n    if (!chunk) return 0\\\\n\\\\n    var ix = worldCoordToChunkIndex(x)\\\\n    var iy = worldCoordToChunkIndex(y)\\\\n    var iz = worldCoordToChunkIndex(z)\\\\n    return chunk.getObjectMeshAt(ix, iy, iz)\\\\n}\\\\n\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.setBlockID = function (val, x, y, z) {\\\\n    var i = worldCoordToChunkCoord(x)\\\\n    var j = worldCoordToChunkCoord(y)\\\\n    var k = worldCoordToChunkCoord(z)\\\\n    var ix = worldCoordToChunkIndex(x)\\\\n    var iy = worldCoordToChunkIndex(y)\\\\n    var iz = worldCoordToChunkIndex(z)\\\\n\\\\n    // if update is on chunk border, update neighbor's padding data too\\\\n    _updateChunkAndBorders(this, i, j, k, this.chunkSize, ix, iy, iz, val)\\\\n}\\\\n\\\\n\\\\n/** @param x,y,z */\\\\nWorld.prototype.isBoxUnobstructed = function (box) {\\\\n    var base = box.base\\\\n    var max = box.max\\\\n    for (var i = Math.floor(base[0]); i < max[0] + 1; i++) {\\\\n        for (var j = Math.floor(base[1]); j < max[1] + 1; j++) {\\\\n            for (var k = Math.floor(base[2]); k < max[2] + 1; k++) {\\\\n                if (this.getBlockSolidity(i, j, k)) return false\\\\n            }\\\\n        }\\\\n    }\\\\n    return true\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nWorld.prototype.tick = function () {\\\\n    profile_hook('start')\\\\n\\\\n    // check player position and needed/unneeded chunks\\\\n    var pos = getPlayerChunkCoords(this)\\\\n    var chunkID = getChunkID(pos[0], pos[1], pos[2])\\\\n    if (chunkID != this._lastPlayerChunkID) {\\\\n        this.emit('playerEnteredChunk', pos[0], pos[1], pos[2])\\\\n        buildChunkAddQueue(this, pos[0], pos[1], pos[2])\\\\n        buildChunkRemoveQueue(this, pos[0], pos[1], pos[2])\\\\n    }\\\\n    this._lastPlayerChunkID = chunkID\\\\n    profile_hook('build queues')\\\\n\\\\n    // process (create or mesh) some chunks. If fast enough, do several\\\\n    profile_queues(this, 'start')\\\\n    var cutoff = performance.now() + this._maxProcessingPerTick\\\\n    var done = false\\\\n    while (!done && (performance.now() < cutoff)) {\\\\n        var d1 = processMeshingQueues(this, false)\\\\n        var d2 = processChunkQueues(this)\\\\n        if (!d2) d2 = processChunkQueues(this)\\\\n        done = d1 && d2\\\\n    }\\\\n    profile_queues(this, 'end')\\\\n\\\\n\\\\n    // track whether the player's local chunk is loaded and ready or not\\\\n    var pChunk = getChunk(this, pos[0], pos[1], pos[2])\\\\n    var okay = !!(pChunk && pChunk.isGenerated && !pChunk.isInvalid)\\\\n    this.playerChunkLoaded = okay\\\\n\\\\n    profile_hook('end')\\\\n}\\\\n\\\\n\\\\n\\\\nfunction beforeRender(self) {\\\\n    // on render, quickly process the high-priority meshing queue\\\\n    // to help avoid flashes of background while neighboring chunks update\\\\n    var cutoff = performance.now() + self._maxProcessingPerRender\\\\n    var done = false\\\\n    while (!done && (performance.now() < cutoff)) {\\\\n        done = processMeshingQueues(self, true)\\\\n    }\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n/** client should call this after creating a chunk's worth of data (as an ndarray)  \\\\n * If userData is passed in it will be attached to the chunk\\\\n * @param id\\\\n * @param array\\\\n * @param userData\\\\n */\\\\nWorld.prototype.setChunkData = function (id, array, userData) {\\\\n    profile_queues(this, 'received')\\\\n    var arr = parseChunkID(id)\\\\n    var chunk = getChunk(this, arr[0], arr[1], arr[2])\\\\n    // ignore if chunk was invalidated while being prepared\\\\n    if (!chunk || chunk.isInvalid) return\\\\n    chunk.array = array\\\\n    if (userData) chunk.userData = userData\\\\n    chunk.initData()\\\\n    enqueueID(id, this._chunkIDsInMemory)\\\\n    unenqueueID(id, this._chunkIDsToCreate)\\\\n\\\\n    // chunk can now be meshed...\\\\n    this.noa.rendering.prepareChunkForRendering(chunk)\\\\n    enqueueID(id, this._chunkIDsToMesh)\\\\n    this.emit('chunkAdded', chunk)\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n * Calling this causes all world chunks to get unloaded and recreated \\\\n * (after receiving new world data from the client). This is useful when\\\\n * you're teleporting the player to a new world, e.g.\\\\n */\\\\nWorld.prototype.invalidateAllChunks = function () {\\\\n    var toInval = this._chunkIDsInMemory.concat(this._chunkIDsToCreate)\\\\n    for (var id of toInval) {\\\\n        var loc = parseChunkID(id)\\\\n        var chunk = getChunk(this, loc[0], loc[1], loc[2])\\\\n        chunk.isInvalid = true\\\\n    }\\\\n    // this causes chunk queues to get rebuilt next tick\\\\n    this._lastPlayerChunkID = ''\\\\n}\\\\n\\\\n\\\\n\\\\n// debugging\\\\nWorld.prototype.report = function () {\\\\n    console.log('World report - playerChunkLoaded: ', this.playerChunkLoaded)\\\\n    _report(this, '  to add     ', this._chunkIDsToAdd)\\\\n    _report(this, '  to remove: ', this._chunkIDsToRemove)\\\\n    _report(this, '  in memory: ', this._chunkIDsInMemory, true)\\\\n    _report(this, '  creating:  ', this._chunkIDsToCreate)\\\\n    _report(this, '  meshing:   ', this._chunkIDsToMesh.concat(this._chunkIDsToMeshFirst))\\\\n}\\\\n\\\\nfunction _report(world, name, arr, ext) {\\\\n    var ct = 0,\\\\n        full = 0,\\\\n        empty = 0\\\\n    for (var id of arr) {\\\\n        if (id.size) {\\\\n            if (id.isInvalid) ct++\\\\n            continue\\\\n        }\\\\n        var loc = parseChunkID(id)\\\\n        var chunk = getChunk(world, loc[0], loc[1], loc[2])\\\\n        if (chunk.isInvalid) ct++\\\\n        if (chunk.isFull) full++\\\\n        if (chunk.isEmpty) empty++\\\\n    }\\\\n    var len = (arr.length + '        ').substr(0, 6)\\\\n    var es = (ext) ? [', ', full, ' full, ', empty, ' empty'].join('') : ''\\\\n    console.log(name, len, ct, 'invalid' + es)\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n/*\\\\n *\\\\n *\\\\n *            INTERNALS\\\\n *\\\\n *\\\\n */\\\\n\\\\n\\\\n// canonical string ID handling for the i,j,k-th chunk\\\\nfunction getChunkID(i, j, k) {\\\\n    return i + '|' + j + '|' + k\\\\n}\\\\n\\\\nfunction parseChunkID(id) {\\\\n    var arr = id.split('|')\\\\n    return [parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2])]\\\\n}\\\\n\\\\n// canonical functions to store/retrieve a chunk held in memory\\\\nfunction getChunk(world, i, j, k) {\\\\n    var mi = (i | 0) & 1023\\\\n    var mj = (j | 0) & 1023\\\\n    var mk = (k | 0) & 1023\\\\n    return world._chunkHash.get(mi, mj, mk)\\\\n}\\\\n\\\\nfunction setChunk(world, i, j, k, value) {\\\\n    var mi = (i | 0) & 1023\\\\n    var mj = (j | 0) & 1023\\\\n    var mk = (k | 0) & 1023\\\\n    world._chunkHash.set(mi, mj, mk, value)\\\\n}\\\\n\\\\n\\\\n\\\\nfunction getPlayerChunkCoords(world) {\\\\n    var pos = world.noa.getPlayerPosition()\\\\n    var i = worldCoordToChunkCoord(pos[0])\\\\n    var j = worldCoordToChunkCoord(pos[1])\\\\n    var k = worldCoordToChunkCoord(pos[2])\\\\n    return [i, j, k]\\\\n}\\\\n\\\\n\\\\n// for internal use\\\\nWorld.prototype._getChunkByCoords = function (x, y, z) {\\\\n    var i = worldCoordToChunkCoord(x)\\\\n    var j = worldCoordToChunkCoord(y)\\\\n    var k = worldCoordToChunkCoord(z)\\\\n    return getChunk(this, i, j, k)\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n// run through chunk tracking queues looking for work to do next\\\\nfunction processChunkQueues(self) {\\\\n    var done = true\\\\n    // both queues are sorted by ascending distance\\\\n    if (self._chunkIDsToRemove.length) {\\\\n        var remove = parseChunkID(self._chunkIDsToRemove.pop())\\\\n        removeChunk(self, remove[0], remove[1], remove[2])\\\\n        profile_queues(self, 'removed')\\\\n        profile_hook('removed')\\\\n        done = false\\\\n    }\\\\n    if (self._chunkIDsToCreate.length >= self._maxChunksPendingCreation) return done\\\\n    // if (self._chunkIDsToMesh.length >= self._maxChunksPendingMeshing) return done\\\\n    if (self._chunkIDsToAdd.length) {\\\\n        var id = self._chunkIDsToAdd.shift()\\\\n        requestNewChunk(self, id)\\\\n        profile_hook('requested')\\\\n        profile_queues(self, 'requested')\\\\n        done = false\\\\n    }\\\\n    return done\\\\n}\\\\n\\\\n\\\\n// similar to above but for chunks waiting to be meshed\\\\nfunction processMeshingQueues(self, firstOnly) {\\\\n    var id\\\\n    if (self._chunkIDsToMeshFirst.length) {\\\\n        id = self._chunkIDsToMeshFirst.pop()\\\\n    } else if (firstOnly) {\\\\n        return true\\\\n    } else if (self._chunkIDsToMesh.length) {\\\\n        id = self._chunkIDsToMesh.pop()\\\\n    } else return true\\\\n\\\\n    var arr = parseChunkID(id)\\\\n    var chunk = getChunk(self, arr[0], arr[1], arr[2])\\\\n    if (chunk.isInvalid) return\\\\n    if (!chunk.isGenerated) {\\\\n        // client code triggered a remesh too early, requeue it\\\\n        self._chunkIDsToMesh.unshift(id)\\\\n        return\\\\n    }\\\\n    chunk.updateMeshes()\\\\n\\\\n    profile_queues(self, 'meshed')\\\\n    profile_hook('meshed')\\\\n    return false\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// make a new chunk and emit an event for it to be populated with world data\\\\nfunction requestNewChunk(world, id) {\\\\n    var pos = parseChunkID(id)\\\\n    var i = pos[0]\\\\n    var j = pos[1]\\\\n    var k = pos[2]\\\\n    var size = world.chunkSize\\\\n    var chunk = new Chunk(world.noa, id, i, j, k, size)\\\\n    setChunk(world, i, j, k, chunk)\\\\n    var x = i * size - 1\\\\n    var y = j * size - 1\\\\n    var z = k * size - 1\\\\n    enqueueID(id, world._chunkIDsToCreate)\\\\n    world.emit('worldDataNeeded', id, chunk.array, x, y, z)\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n// remove a chunk that wound up in the remove queue\\\\nfunction removeChunk(world, i, j, k) {\\\\n    var chunk = getChunk(world, i, j, k)\\\\n    world.emit('chunkBeingRemoved', chunk.id, chunk.array, chunk.userData)\\\\n    world.noa.rendering.disposeChunkForRendering(chunk)\\\\n    chunk.dispose()\\\\n    setChunk(world, i, j, k, 0)\\\\n    unenqueueID(chunk.id, world._chunkIDsInMemory)\\\\n    unenqueueID(chunk.id, world._chunkIDsToMesh)\\\\n    unenqueueID(chunk.id, world._chunkIDsToMeshFirst)\\\\n    // when removing a chunk because it was invalid, arrange for chunk queues to get rebuilt\\\\n    if (chunk.isInvalid) world._lastPlayerChunkID = ''\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// for a given chunk (i/j/k) and local location (x/y/z), \\\\n// update all chunks that need it (including border chunks with the \\\\n// changed block in their 1-block padding)\\\\n\\\\nfunction _updateChunkAndBorders(world, i, j, k, size, x, y, z, val) {\\\\n    var ilocs = [0]\\\\n    var jlocs = [0]\\\\n    var klocs = [0]\\\\n    if (x === 0) { ilocs.push(-1) } else if (x === size - 1) { ilocs.push(1) }\\\\n    if (y === 0) { jlocs.push(-1) } else if (y === size - 1) { jlocs.push(1) }\\\\n    if (z === 0) { klocs.push(-1) } else if (z === size - 1) { klocs.push(1) }\\\\n\\\\n    for (var di of ilocs) {\\\\n        var lx = [size, x, -1][di + 1]\\\\n        for (var dj of jlocs) {\\\\n            var ly = [size, y, -1][dj + 1]\\\\n            for (var dk of klocs) {\\\\n                var lz = [size, z, -1][dk + 1]\\\\n                _modifyBlockData(world,\\\\n                    i + di, j + dj, k + dk,\\\\n                    lx, ly, lz, val)\\\\n            }\\\\n        }\\\\n    }\\\\n}\\\\n\\\\n\\\\n\\\\n// internal function to modify a chunk's block\\\\n\\\\nfunction _modifyBlockData(world, i, j, k, x, y, z, val) {\\\\n    var chunk = getChunk(world, i, j, k)\\\\n    if (!chunk) return\\\\n    chunk.set(x, y, z, val)\\\\n    enqueueID(chunk.id, world._chunkIDsToMeshFirst)\\\\n    world.emit('chunkChanged', chunk)\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n// rebuild queue of chunks to be added around (ci,cj,ck)\\\\nfunction buildChunkAddQueue(world, ci, cj, ck) {\\\\n    var add = Math.ceil(world.chunkAddDistance)\\\\n    var pending = world._chunkIDsToCreate\\\\n    var queue = []\\\\n    var distArr = []\\\\n\\\\n    var addDistSq = world.chunkAddDistance * world.chunkAddDistance\\\\n    for (var i = ci - add; i <= ci + add; ++i) {\\\\n        for (var j = cj - add; j <= cj + add; ++j) {\\\\n            for (var k = ck - add; k <= ck + add; ++k) {\\\\n                var di = i - ci\\\\n                var dj = j - cj\\\\n                var dk = k - ck\\\\n                var distSq = di * di + dj * dj + dk * dk\\\\n                if (distSq > addDistSq) continue\\\\n\\\\n                if (getChunk(world, i, j, k)) continue\\\\n                var id = getChunkID(i, j, k)\\\\n                if (pending.indexOf(id) > -1) continue\\\\n                queue.push(id)\\\\n                distArr.push(distSq)\\\\n            }\\\\n        }\\\\n    }\\\\n    world._chunkIDsToAdd = sortByReferenceArray(queue, distArr)\\\\n}\\\\n\\\\n\\\\n// rebuild queue of chunks to be removed from around (ci,cj,ck)\\\\nfunction buildChunkRemoveQueue(world, ci, cj, ck) {\\\\n    var remDistSq = world.chunkRemoveDistance * world.chunkRemoveDistance\\\\n    var list = world._chunkIDsInMemory\\\\n    var queue = []\\\\n    var distArr = []\\\\n\\\\n    for (var i = 0; i < list.length; i++) {\\\\n        var id = list[i]\\\\n        var loc = parseChunkID(id)\\\\n        var di = loc[0] - ci\\\\n        var dj = loc[1] - cj\\\\n        var dk = loc[2] - ck\\\\n        var distSq = di * di + dj * dj + dk * dk\\\\n        if (distSq < remDistSq) {\\\\n            var chunk = getChunk(world, loc[0], loc[1], loc[2])\\\\n            if (!chunk.isInvalid) continue\\\\n            distSq *= -1 // rig sort so that invalidated chunks get removed first\\\\n        }\\\\n        queue.push(id)\\\\n        distArr.push(distSq)\\\\n    }\\\\n    world._chunkIDsToRemove = sortByReferenceArray(queue, distArr)\\\\n}\\\\n\\\\n\\\\n\\\\n// sorts [A, B, C] and [3, 1, 2] into [B, C, A]\\\\nfunction sortByReferenceArray(data, ref) {\\\\n    var ind = Object.keys(ref)\\\\n    ind.sort((i, j) => ref[i] - ref[j])\\\\n    return ind.map(i => data[i])\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// uniquely enqueue a string id into an array of them\\\\nfunction enqueueID(id, queue) {\\\\n    var i = queue.indexOf(id)\\\\n    if (i >= 0) return\\\\n    queue.push(id)\\\\n}\\\\n\\\\n// remove string id from queue if it exists\\\\nfunction unenqueueID(id, queue) {\\\\n    var i = queue.indexOf(id)\\\\n    if (i >= 0) queue.splice(i, 1)\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\nvar profile_queues = function (w, s) {}\\\\nif (PROFILE_QUEUES)(function () {\\\\n    var every = 100\\\\n    var iter = 0\\\\n    var t, nrem, nreq, totalrec, nmesh\\\\n    var reqcts, remcts, meshcts\\\\n    var qadd, qrem, qmem, qgen, qmesh\\\\n    profile_queues = function (world, state) {\\\\n        if (state === 'start') {\\\\n            if (iter === 0) {\\\\n                t = performance.now()\\\\n                qadd = qrem = qmem = qgen = qmesh = 0\\\\n                totalrec = 0\\\\n                remcts = []\\\\n                reqcts = []\\\\n                meshcts = []\\\\n            }\\\\n            iter++\\\\n            nrem = nreq = nmesh = 0\\\\n        } else if (state === 'removed') {\\\\n            nrem++\\\\n        } else if (state === 'received') {\\\\n            totalrec++\\\\n        } else if (state === 'requested') {\\\\n            nreq++\\\\n        } else if (state === 'meshed') {\\\\n            nmesh++\\\\n        } else if (state === 'end') {\\\\n            // counts for frames that were fully worked\\\\n            if (world._chunkIDsToAdd.length) reqcts.push(nreq)\\\\n            if (world._chunkIDsToRemove.length) remcts.push(nrem)\\\\n            if (world._chunkIDsToMesh.length + world._chunkIDsToMeshFirst.length) meshcts.push(nmesh)\\\\n            // avg queue sizes\\\\n            qadd += world._chunkIDsToAdd.length\\\\n            qrem += world._chunkIDsToRemove.length\\\\n            qmem += world._chunkIDsInMemory.length\\\\n            qgen += world._chunkIDsToCreate.length\\\\n            qmesh += world._chunkIDsToMesh.length + world._chunkIDsToMeshFirst.length\\\\n            // on end\\\\n            if (iter === every) {\\\\n                var dt = (performance.now() - t) / 1000\\\\n                console.log('world chunk queues:',\\\\n                    'made', rnd(totalrec / dt), 'cps',\\\\n                    '- avg queuelen: ',\\\\n                    'add', qadd / every,\\\\n                    'rem', qrem / every,\\\\n                    'mem', qmem / every,\\\\n                    'gen', qgen / every,\\\\n                    'mesh', qmesh / every,\\\\n                    '- work/frame: ',\\\\n                    'req', rnd(reqcts.reduce(sum, 0) / reqcts.length),\\\\n                    'rem', rnd(remcts.reduce(sum, 0) / remcts.length),\\\\n                    'mesh', rnd(meshcts.reduce(sum, 0) / meshcts.length)\\\\n                )\\\\n                iter = 0\\\\n            }\\\\n        }\\\\n    }\\\\n    var sum = function (num, prev) { return num + prev }\\\\n    var rnd = function (n) { return Math.round(n * 10) / 10 }\\\\n})()\\\\n\\\\n\\\\nvar profile_hook = function (s) {}\\\\nif (PROFILE)(function () {\\\\n    var every = 200\\\\n    var timer = new(__webpack_require__(/*! ./util */ \\\\\\\"./node_modules/noa-engine/src/lib/util.js\\\\\\\").Timer)(every, 'world ticks')\\\\n    profile_hook = function (state) {\\\\n        if (state === 'start') timer.start()\\\\n        else if (state === 'end') timer.report()\\\\n        else timer.add(state)\\\\n    }\\\\n})()\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/noa-engine/src/lib/world.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./node_modules/simplex-noise/simplex-noise.js\\\":\\n/*!*****************************************************!*\\\\\\n  !*** ./node_modules/simplex-noise/simplex-noise.js ***!\\n  \\\\*****************************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"var __WEBPACK_AMD_DEFINE_RESULT__;/*\\\\n * A fast javascript implementation of simplex noise by Jonas Wagner\\\\n *\\\\n * Based on a speed-improved simplex noise algorithm for 2D, 3D and 4D in Java.\\\\n * Which is based on example code by Stefan Gustavson (stegu@itn.liu.se).\\\\n * With Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).\\\\n * Better rank ordering method by Stefan Gustavson in 2012.\\\\n *\\\\n *\\\\n * Copyright (C) 2016 Jonas Wagner\\\\n *\\\\n * Permission is hereby granted, free of charge, to any person obtaining\\\\n * a copy of this software and associated documentation files (the\\\\n * \\\\\\\"Software\\\\\\\"), to deal in the Software without restriction, including\\\\n * without limitation the rights to use, copy, modify, merge, publish,\\\\n * distribute, sublicense, and/or sell copies of the Software, and to\\\\n * permit persons to whom the Software is furnished to do so, subject to\\\\n * the following conditions:\\\\n *\\\\n * The above copyright notice and this permission notice shall be\\\\n * included in all copies or substantial portions of the Software.\\\\n *\\\\n * THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND,\\\\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\\\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\\\\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\\\\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\\\\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\\\\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\\\\n *\\\\n */\\\\n(function() {\\\\n'use strict';\\\\n\\\\nvar F2 = 0.5 * (Math.sqrt(3.0) - 1.0);\\\\nvar G2 = (3.0 - Math.sqrt(3.0)) / 6.0;\\\\nvar F3 = 1.0 / 3.0;\\\\nvar G3 = 1.0 / 6.0;\\\\nvar F4 = (Math.sqrt(5.0) - 1.0) / 4.0;\\\\nvar G4 = (5.0 - Math.sqrt(5.0)) / 20.0;\\\\n\\\\nfunction SimplexNoise(random) {\\\\n  if (!random) random = Math.random;\\\\n  this.p = buildPermutationTable(random);\\\\n  this.perm = new Uint8Array(512);\\\\n  this.permMod12 = new Uint8Array(512);\\\\n  for (var i = 0; i < 512; i++) {\\\\n    this.perm[i] = this.p[i & 255];\\\\n    this.permMod12[i] = this.perm[i] % 12;\\\\n  }\\\\n\\\\n}\\\\nSimplexNoise.prototype = {\\\\n    grad3: new Float32Array([1, 1, 0,\\\\n                            -1, 1, 0,\\\\n                            1, -1, 0,\\\\n\\\\n                            -1, -1, 0,\\\\n                            1, 0, 1,\\\\n                            -1, 0, 1,\\\\n\\\\n                            1, 0, -1,\\\\n                            -1, 0, -1,\\\\n                            0, 1, 1,\\\\n\\\\n                            0, -1, 1,\\\\n                            0, 1, -1,\\\\n                            0, -1, -1]),\\\\n    grad4: new Float32Array([0, 1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1,\\\\n                            0, -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1,\\\\n                            1, 0, 1, 1, 1, 0, 1, -1, 1, 0, -1, 1, 1, 0, -1, -1,\\\\n                            -1, 0, 1, 1, -1, 0, 1, -1, -1, 0, -1, 1, -1, 0, -1, -1,\\\\n                            1, 1, 0, 1, 1, 1, 0, -1, 1, -1, 0, 1, 1, -1, 0, -1,\\\\n                            -1, 1, 0, 1, -1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, -1,\\\\n                            1, 1, 1, 0, 1, 1, -1, 0, 1, -1, 1, 0, 1, -1, -1, 0,\\\\n                            -1, 1, 1, 0, -1, 1, -1, 0, -1, -1, 1, 0, -1, -1, -1, 0]),\\\\n    noise2D: function(xin, yin) {\\\\n        var permMod12 = this.permMod12;\\\\n        var perm = this.perm;\\\\n        var grad3 = this.grad3;\\\\n        var n0 = 0; // Noise contributions from the three corners\\\\n        var n1 = 0;\\\\n        var n2 = 0;\\\\n        // Skew the input space to determine which simplex cell we're in\\\\n        var s = (xin + yin) * F2; // Hairy factor for 2D\\\\n        var i = Math.floor(xin + s);\\\\n        var j = Math.floor(yin + s);\\\\n        var t = (i + j) * G2;\\\\n        var X0 = i - t; // Unskew the cell origin back to (x,y) space\\\\n        var Y0 = j - t;\\\\n        var x0 = xin - X0; // The x,y distances from the cell origin\\\\n        var y0 = yin - Y0;\\\\n        // For the 2D case, the simplex shape is an equilateral triangle.\\\\n        // Determine which simplex we are in.\\\\n        var i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords\\\\n        if (x0 > y0) {\\\\n          i1 = 1;\\\\n          j1 = 0;\\\\n        } // lower triangle, XY order: (0,0)->(1,0)->(1,1)\\\\n        else {\\\\n          i1 = 0;\\\\n          j1 = 1;\\\\n        } // upper triangle, YX order: (0,0)->(0,1)->(1,1)\\\\n        // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and\\\\n        // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where\\\\n        // c = (3-sqrt(3))/6\\\\n        var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords\\\\n        var y1 = y0 - j1 + G2;\\\\n        var x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords\\\\n        var y2 = y0 - 1.0 + 2.0 * G2;\\\\n        // Work out the hashed gradient indices of the three simplex corners\\\\n        var ii = i & 255;\\\\n        var jj = j & 255;\\\\n        // Calculate the contribution from the three corners\\\\n        var t0 = 0.5 - x0 * x0 - y0 * y0;\\\\n        if (t0 >= 0) {\\\\n          var gi0 = permMod12[ii + perm[jj]] * 3;\\\\n          t0 *= t0;\\\\n          n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0); // (x,y) of grad3 used for 2D gradient\\\\n        }\\\\n        var t1 = 0.5 - x1 * x1 - y1 * y1;\\\\n        if (t1 >= 0) {\\\\n          var gi1 = permMod12[ii + i1 + perm[jj + j1]] * 3;\\\\n          t1 *= t1;\\\\n          n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1);\\\\n        }\\\\n        var t2 = 0.5 - x2 * x2 - y2 * y2;\\\\n        if (t2 >= 0) {\\\\n          var gi2 = permMod12[ii + 1 + perm[jj + 1]] * 3;\\\\n          t2 *= t2;\\\\n          n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2);\\\\n        }\\\\n        // Add contributions from each corner to get the final noise value.\\\\n        // The result is scaled to return values in the interval [-1,1].\\\\n        return 70.0 * (n0 + n1 + n2);\\\\n      },\\\\n    // 3D simplex noise\\\\n    noise3D: function(xin, yin, zin) {\\\\n        var permMod12 = this.permMod12;\\\\n        var perm = this.perm;\\\\n        var grad3 = this.grad3;\\\\n        var n0, n1, n2, n3; // Noise contributions from the four corners\\\\n        // Skew the input space to determine which simplex cell we're in\\\\n        var s = (xin + yin + zin) * F3; // Very nice and simple skew factor for 3D\\\\n        var i = Math.floor(xin + s);\\\\n        var j = Math.floor(yin + s);\\\\n        var k = Math.floor(zin + s);\\\\n        var t = (i + j + k) * G3;\\\\n        var X0 = i - t; // Unskew the cell origin back to (x,y,z) space\\\\n        var Y0 = j - t;\\\\n        var Z0 = k - t;\\\\n        var x0 = xin - X0; // The x,y,z distances from the cell origin\\\\n        var y0 = yin - Y0;\\\\n        var z0 = zin - Z0;\\\\n        // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\\\\n        // Determine which simplex we are in.\\\\n        var i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\\\\n        var i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\\\\n        if (x0 >= y0) {\\\\n          if (y0 >= z0) {\\\\n            i1 = 1;\\\\n            j1 = 0;\\\\n            k1 = 0;\\\\n            i2 = 1;\\\\n            j2 = 1;\\\\n            k2 = 0;\\\\n          } // X Y Z order\\\\n          else if (x0 >= z0) {\\\\n            i1 = 1;\\\\n            j1 = 0;\\\\n            k1 = 0;\\\\n            i2 = 1;\\\\n            j2 = 0;\\\\n            k2 = 1;\\\\n          } // X Z Y order\\\\n          else {\\\\n            i1 = 0;\\\\n            j1 = 0;\\\\n            k1 = 1;\\\\n            i2 = 1;\\\\n            j2 = 0;\\\\n            k2 = 1;\\\\n          } // Z X Y order\\\\n        }\\\\n        else { // x0<y0\\\\n          if (y0 < z0) {\\\\n            i1 = 0;\\\\n            j1 = 0;\\\\n            k1 = 1;\\\\n            i2 = 0;\\\\n            j2 = 1;\\\\n            k2 = 1;\\\\n          } // Z Y X order\\\\n          else if (x0 < z0) {\\\\n            i1 = 0;\\\\n            j1 = 1;\\\\n            k1 = 0;\\\\n            i2 = 0;\\\\n            j2 = 1;\\\\n            k2 = 1;\\\\n          } // Y Z X order\\\\n          else {\\\\n            i1 = 0;\\\\n            j1 = 1;\\\\n            k1 = 0;\\\\n            i2 = 1;\\\\n            j2 = 1;\\\\n            k2 = 0;\\\\n          } // Y X Z order\\\\n        }\\\\n        // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),\\\\n        // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and\\\\n        // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where\\\\n        // c = 1/6.\\\\n        var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords\\\\n        var y1 = y0 - j1 + G3;\\\\n        var z1 = z0 - k1 + G3;\\\\n        var x2 = x0 - i2 + 2.0 * G3; // Offsets for third corner in (x,y,z) coords\\\\n        var y2 = y0 - j2 + 2.0 * G3;\\\\n        var z2 = z0 - k2 + 2.0 * G3;\\\\n        var x3 = x0 - 1.0 + 3.0 * G3; // Offsets for last corner in (x,y,z) coords\\\\n        var y3 = y0 - 1.0 + 3.0 * G3;\\\\n        var z3 = z0 - 1.0 + 3.0 * G3;\\\\n        // Work out the hashed gradient indices of the four simplex corners\\\\n        var ii = i & 255;\\\\n        var jj = j & 255;\\\\n        var kk = k & 255;\\\\n        // Calculate the contribution from the four corners\\\\n        var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0;\\\\n        if (t0 < 0) n0 = 0.0;\\\\n        else {\\\\n          var gi0 = permMod12[ii + perm[jj + perm[kk]]] * 3;\\\\n          t0 *= t0;\\\\n          n0 = t0 * t0 * (grad3[gi0] * x0 + grad3[gi0 + 1] * y0 + grad3[gi0 + 2] * z0);\\\\n        }\\\\n        var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1;\\\\n        if (t1 < 0) n1 = 0.0;\\\\n        else {\\\\n          var gi1 = permMod12[ii + i1 + perm[jj + j1 + perm[kk + k1]]] * 3;\\\\n          t1 *= t1;\\\\n          n1 = t1 * t1 * (grad3[gi1] * x1 + grad3[gi1 + 1] * y1 + grad3[gi1 + 2] * z1);\\\\n        }\\\\n        var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2;\\\\n        if (t2 < 0) n2 = 0.0;\\\\n        else {\\\\n          var gi2 = permMod12[ii + i2 + perm[jj + j2 + perm[kk + k2]]] * 3;\\\\n          t2 *= t2;\\\\n          n2 = t2 * t2 * (grad3[gi2] * x2 + grad3[gi2 + 1] * y2 + grad3[gi2 + 2] * z2);\\\\n        }\\\\n        var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3;\\\\n        if (t3 < 0) n3 = 0.0;\\\\n        else {\\\\n          var gi3 = permMod12[ii + 1 + perm[jj + 1 + perm[kk + 1]]] * 3;\\\\n          t3 *= t3;\\\\n          n3 = t3 * t3 * (grad3[gi3] * x3 + grad3[gi3 + 1] * y3 + grad3[gi3 + 2] * z3);\\\\n        }\\\\n        // Add contributions from each corner to get the final noise value.\\\\n        // The result is scaled to stay just inside [-1,1]\\\\n        return 32.0 * (n0 + n1 + n2 + n3);\\\\n      },\\\\n    // 4D simplex noise, better simplex rank ordering method 2012-03-09\\\\n    noise4D: function(x, y, z, w) {\\\\n        var permMod12 = this.permMod12;\\\\n        var perm = this.perm;\\\\n        var grad4 = this.grad4;\\\\n\\\\n        var n0, n1, n2, n3, n4; // Noise contributions from the five corners\\\\n        // Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in\\\\n        var s = (x + y + z + w) * F4; // Factor for 4D skewing\\\\n        var i = Math.floor(x + s);\\\\n        var j = Math.floor(y + s);\\\\n        var k = Math.floor(z + s);\\\\n        var l = Math.floor(w + s);\\\\n        var t = (i + j + k + l) * G4; // Factor for 4D unskewing\\\\n        var X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space\\\\n        var Y0 = j - t;\\\\n        var Z0 = k - t;\\\\n        var W0 = l - t;\\\\n        var x0 = x - X0; // The x,y,z,w distances from the cell origin\\\\n        var y0 = y - Y0;\\\\n        var z0 = z - Z0;\\\\n        var w0 = w - W0;\\\\n        // For the 4D case, the simplex is a 4D shape I won't even try to describe.\\\\n        // To find out which of the 24 possible simplices we're in, we need to\\\\n        // determine the magnitude ordering of x0, y0, z0 and w0.\\\\n        // Six pair-wise comparisons are performed between each possible pair\\\\n        // of the four coordinates, and the results are used to rank the numbers.\\\\n        var rankx = 0;\\\\n        var ranky = 0;\\\\n        var rankz = 0;\\\\n        var rankw = 0;\\\\n        if (x0 > y0) rankx++;\\\\n        else ranky++;\\\\n        if (x0 > z0) rankx++;\\\\n        else rankz++;\\\\n        if (x0 > w0) rankx++;\\\\n        else rankw++;\\\\n        if (y0 > z0) ranky++;\\\\n        else rankz++;\\\\n        if (y0 > w0) ranky++;\\\\n        else rankw++;\\\\n        if (z0 > w0) rankz++;\\\\n        else rankw++;\\\\n        var i1, j1, k1, l1; // The integer offsets for the second simplex corner\\\\n        var i2, j2, k2, l2; // The integer offsets for the third simplex corner\\\\n        var i3, j3, k3, l3; // The integer offsets for the fourth simplex corner\\\\n        // simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.\\\\n        // Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w\\\\n        // impossible. Only the 24 indices which have non-zero entries make any sense.\\\\n        // We use a thresholding to set the coordinates in turn from the largest magnitude.\\\\n        // Rank 3 denotes the largest coordinate.\\\\n        i1 = rankx >= 3 ? 1 : 0;\\\\n        j1 = ranky >= 3 ? 1 : 0;\\\\n        k1 = rankz >= 3 ? 1 : 0;\\\\n        l1 = rankw >= 3 ? 1 : 0;\\\\n        // Rank 2 denotes the second largest coordinate.\\\\n        i2 = rankx >= 2 ? 1 : 0;\\\\n        j2 = ranky >= 2 ? 1 : 0;\\\\n        k2 = rankz >= 2 ? 1 : 0;\\\\n        l2 = rankw >= 2 ? 1 : 0;\\\\n        // Rank 1 denotes the second smallest coordinate.\\\\n        i3 = rankx >= 1 ? 1 : 0;\\\\n        j3 = ranky >= 1 ? 1 : 0;\\\\n        k3 = rankz >= 1 ? 1 : 0;\\\\n        l3 = rankw >= 1 ? 1 : 0;\\\\n        // The fifth corner has all coordinate offsets = 1, so no need to compute that.\\\\n        var x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords\\\\n        var y1 = y0 - j1 + G4;\\\\n        var z1 = z0 - k1 + G4;\\\\n        var w1 = w0 - l1 + G4;\\\\n        var x2 = x0 - i2 + 2.0 * G4; // Offsets for third corner in (x,y,z,w) coords\\\\n        var y2 = y0 - j2 + 2.0 * G4;\\\\n        var z2 = z0 - k2 + 2.0 * G4;\\\\n        var w2 = w0 - l2 + 2.0 * G4;\\\\n        var x3 = x0 - i3 + 3.0 * G4; // Offsets for fourth corner in (x,y,z,w) coords\\\\n        var y3 = y0 - j3 + 3.0 * G4;\\\\n        var z3 = z0 - k3 + 3.0 * G4;\\\\n        var w3 = w0 - l3 + 3.0 * G4;\\\\n        var x4 = x0 - 1.0 + 4.0 * G4; // Offsets for last corner in (x,y,z,w) coords\\\\n        var y4 = y0 - 1.0 + 4.0 * G4;\\\\n        var z4 = z0 - 1.0 + 4.0 * G4;\\\\n        var w4 = w0 - 1.0 + 4.0 * G4;\\\\n        // Work out the hashed gradient indices of the five simplex corners\\\\n        var ii = i & 255;\\\\n        var jj = j & 255;\\\\n        var kk = k & 255;\\\\n        var ll = l & 255;\\\\n        // Calculate the contribution from the five corners\\\\n        var t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;\\\\n        if (t0 < 0) n0 = 0.0;\\\\n        else {\\\\n          var gi0 = (perm[ii + perm[jj + perm[kk + perm[ll]]]] % 32) * 4;\\\\n          t0 *= t0;\\\\n          n0 = t0 * t0 * (grad4[gi0] * x0 + grad4[gi0 + 1] * y0 + grad4[gi0 + 2] * z0 + grad4[gi0 + 3] * w0);\\\\n        }\\\\n        var t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;\\\\n        if (t1 < 0) n1 = 0.0;\\\\n        else {\\\\n          var gi1 = (perm[ii + i1 + perm[jj + j1 + perm[kk + k1 + perm[ll + l1]]]] % 32) * 4;\\\\n          t1 *= t1;\\\\n          n1 = t1 * t1 * (grad4[gi1] * x1 + grad4[gi1 + 1] * y1 + grad4[gi1 + 2] * z1 + grad4[gi1 + 3] * w1);\\\\n        }\\\\n        var t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;\\\\n        if (t2 < 0) n2 = 0.0;\\\\n        else {\\\\n          var gi2 = (perm[ii + i2 + perm[jj + j2 + perm[kk + k2 + perm[ll + l2]]]] % 32) * 4;\\\\n          t2 *= t2;\\\\n          n2 = t2 * t2 * (grad4[gi2] * x2 + grad4[gi2 + 1] * y2 + grad4[gi2 + 2] * z2 + grad4[gi2 + 3] * w2);\\\\n        }\\\\n        var t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;\\\\n        if (t3 < 0) n3 = 0.0;\\\\n        else {\\\\n          var gi3 = (perm[ii + i3 + perm[jj + j3 + perm[kk + k3 + perm[ll + l3]]]] % 32) * 4;\\\\n          t3 *= t3;\\\\n          n3 = t3 * t3 * (grad4[gi3] * x3 + grad4[gi3 + 1] * y3 + grad4[gi3 + 2] * z3 + grad4[gi3 + 3] * w3);\\\\n        }\\\\n        var t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;\\\\n        if (t4 < 0) n4 = 0.0;\\\\n        else {\\\\n          var gi4 = (perm[ii + 1 + perm[jj + 1 + perm[kk + 1 + perm[ll + 1]]]] % 32) * 4;\\\\n          t4 *= t4;\\\\n          n4 = t4 * t4 * (grad4[gi4] * x4 + grad4[gi4 + 1] * y4 + grad4[gi4 + 2] * z4 + grad4[gi4 + 3] * w4);\\\\n        }\\\\n        // Sum up and scale the result to cover the range [-1,1]\\\\n        return 27.0 * (n0 + n1 + n2 + n3 + n4);\\\\n      }\\\\n  };\\\\n\\\\nfunction buildPermutationTable(random) {\\\\n  var i;\\\\n  var p = new Uint8Array(256);\\\\n  for (i = 0; i < 256; i++) {\\\\n    p[i] = i;\\\\n  }\\\\n  for (i = 0; i < 255; i++) {\\\\n    var r = i + 1 + ~~(random() * (255 - i));\\\\n    var aux = p[i];\\\\n    p[i] = p[r];\\\\n    p[r] = aux;\\\\n  }\\\\n  return p;\\\\n}\\\\nSimplexNoise._buildPermutationTable = buildPermutationTable;\\\\n\\\\n// amd\\\\nif (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {return SimplexNoise;}).call(exports, __webpack_require__, exports, module),\\\\n\\\\t\\\\t\\\\t\\\\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\\\\n// common js\\\\nif (true) exports.SimplexNoise = SimplexNoise;\\\\n// browser\\\\nelse {}\\\\n// nodejs\\\\nif (true) {\\\\n  module.exports = SimplexNoise;\\\\n}\\\\n\\\\n})();\\\\n\\\\n\\\\n//# sourceURL=webpack:///./node_modules/simplex-noise/simplex-noise.js?\\\");\\n\\n/***/ }),\\n\\n/***/ \\\"./src/lib/worldgen_worker.js\\\":\\n/*!************************************!*\\\\\\n  !*** ./src/lib/worldgen_worker.js ***!\\n  \\\\************************************/\\n/*! no static exports found */\\n/***/ (function(module, exports, __webpack_require__) {\\n\\neval(\\\"//'use strict'\\\\n\\\\n//console.log(\\\\\\\"step2\\\\\\\")\\\\n\\\\n\\\\n\\\\nvar SimplexNoise = __webpack_require__(/*! simplex-noise */ \\\\\\\"./node_modules/simplex-noise/simplex-noise.js\\\\\\\")\\\\nvar simplex = new SimplexNoise()\\\\nvar hash = __webpack_require__(/*! ndhash */ \\\\\\\"./node_modules/ndhash/hash.js\\\\\\\")\\\\nvar ndarray = __webpack_require__(/*! ndarray */ \\\\\\\"./node_modules/ndarray/ndarray.js\\\\\\\")\\\\nconst world = __webpack_require__(/*! noa-engine/src/lib/world */ \\\\\\\"./node_modules/noa-engine/src/lib/world.js\\\\\\\")\\\\n\\\\n\\\\n// plumbing\\\\nvar worldgen = new WorldGen()\\\\nself.onmessage = function (ev) { worldgen.onMessage(ev); }\\\\n\\\\n\\\\nconst rprime = [3,5,7,13,17,19,23,37,47,59,61,67,71,79,89,101,103,107,109,127,]\\\\nconst cprime = [353,331,313,311,307,293,283,277,271,239,233,229,223,199,197,191,167,163,157,151]\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n// root module of the web worker\\\\n// catches messages and passes an ndarray off for chunk generation\\\\n\\\\nfunction WorldGen() {\\\\n\\\\n  /*\\\\n   *    message handling\\\\n  */\\\\n  \\\\n  this.onMessage = function (ev){\\\\n    var msg = ev && ev.data && ev.data.msg\\\\n    \\\\n    if (!msg) return\\\\n    if (msg!=\\\\\\\"init\\\\\\\"&&msg!=\\\\\\\"generated\\\\\\\"&&msg!=\\\\\\\"generate\\\\\\\"){\\\\n      var seedz = msg\\\\n        buidl(seedz)\\\\n      \\\\n    }\\\\n    if (msg=='init') {\\\\n      var seedz = msg\\\\n      //console.log(seedz + \\\\\\\"#2\\\\\\\")\\\\n      initBlockIDs(ev.data.ids)\\\\n    }\\\\n\\\\n    if (msg=='generate') {\\\\n      //console.log(\\\\\\\"generated world\\\\\\\")\\\\n      var d = ev.data\\\\n      var array = new ndarray( d.data, d.shape )\\\\n      \\\\n    \\\\n      generateWorld(array, d.x, d.y, d.z)\\\\n      \\\\n      // when done, return the ndarray to main thread\\\\n      self.postMessage({\\\\n        msg: 'generated',\\\\n        data: array.data,\\\\n        shape: array.shape,\\\\n        id: d.id,\\\\n      })\\\\n    }\\\\n  }\\\\n\\\\n\\\\n  /*\\\\n   *    block ID initialization\\\\n  */\\\\n\\\\n  var initted = false\\\\n  var dirtID, grassID, stoneID, block1ID, cloudID, leafID, flowerID, woodID, waterID, sandID\\\\n  var plant1ID, plant2ID, plant3ID, plant4ID, plant5ID, treasureID\\\\n  var obSet\\\\n  var overlays\\\\n\\\\n  function initBlockIDs(obj) {\\\\n    dirtID =   obj.dirtID\\\\n    grassID =  obj.grassID\\\\n    stoneID =  obj.stoneID\\\\n    sandID =  obj.sandID\\\\n    block1ID = obj.block1ID\\\\n    cloudID =  obj.cloudID\\\\n    leafID =   obj.leafID\\\\n    flowerID = obj.flowerID\\\\n    woodID =   obj.woodID\\\\n    waterID =  obj.waterID\\\\n    plant1ID = obj.plant1ID\\\\n    plant2ID = obj.plant2ID\\\\n    plant3ID = obj.plant3ID\\\\n    plant4ID = obj.plant4ID\\\\n    plant5ID = obj.plant5ID\\\\n    treasureID = obj.treasureID\\\\n\\\\n    obSet = [plant1ID, plant2ID, plant3ID, plant4ID, plant5ID]\\\\n\\\\n    overlays = obj.overlays\\\\n    initted = true\\\\n  }\\\\n\\\\n\\\\n  /*\\\\n   *    Hacked in slide stuff\\\\n  */\\\\n  // used by generateWorld\\\\n  function getOverlay(x,y,z) {\\\\n    if (! overlays[x]) return -1\\\\n    if (! overlays[x][y]) return -1\\\\n    return overlays[x][y][z]\\\\n  }\\\\n\\\\n  var waterLevel = 0\\\\n\\\\n  var cloudXZ = 200, \\\\n      cloudY = 20,\\\\n      cloudLevel = 60, \\\\n      cloudCutoff = .93  \\\\n      \\\\n      \\\\n  const mult = 3\\\\n\\\\n  var floor = Math.floor\\\\n  var dim = []\\\\n  var map3 = []\\\\n\\\\n  //buidl(137246265)\\\\n\\\\nfunction buidl(seedz){\\\\n  const mapLevel = [[0,1],\\\\n  [0.004661188,2],\\\\n  [0.013903448,3],\\\\n  [0.035930319,4],\\\\n  [0.080756659,5],\\\\n  [0.158655254,6],\\\\n  [0.274253118,7],\\\\n  [0.420740291,8],\\\\n  [0.579259709,9],\\\\n  [0.725746882,10],\\\\n  [0.841344746,11],\\\\n  [0.919243341,12],\\\\n  [0.964069681,13],\\\\n  [0.986096552,14],\\\\n  [0.995338812,15]\\\\n  [1, 16]];\\\\n\\\\n    \\\\n    var seed = seedz\\\\n    \\\\n      /*\\\\n   *    Chunk generation\\\\n  \\\\n\\\\n  var terrainXZ = 80, \\\\n      terrainY = 10\\\\n  */\\\\n  \\\\n\\\\n      \\\\n      \\\\n      var minimap = []\\\\n      const rand = [839, 829, 827, 823]\\\\n  \\\\n      const s = 5+Math.ceil((seed%rand[0])%100)/100*4\\\\n      const g = s+Math.ceil((seed%rand[1])%100)/100*4\\\\n      const t = g+Math.ceil((seed%rand[2])%100)/100*3\\\\n      const m = t+Math.ceil((seed%rand[3])%100)/100*4\\\\n      dim = [s,g,t,m]\\\\n    \\\\n  \\\\n  \\\\n  \\\\n      for (var a = 0; a < 20; a++) {\\\\n          for (var b = 0; b < 20; b++) {\\\\n              \\\\n              var rrand = rprime[a]\\\\n              var crand = cprime[b]\\\\n              const blah = Math.round(((Math.ceil((seed%(rrand+crand))%17+1)-Math.sin(seed-crand+rrand-10^8)/4)/17)*100)/100\\\\n              //console.log(vlookup(blah,mapLevel))\\\\n              minimap[a+20*b] = vlookup(blah,mapLevel);\\\\n          }\\\\n      }\\\\n    \\\\n      \\\\n  \\\\n      \\\\n      for (var i = 0; i < 500; ++i) {\\\\n          for (var k = 0; k < 500; ++k) {\\\\n  \\\\n                  var x1c = (i - i%25)/25\\\\n                  var x2c = (x1c + 1)%20\\\\n  \\\\n                  var y1c = (k - k%25)/25\\\\n                  var y2c = (y1c + 1)%20\\\\n                  \\\\n                  \\\\n  \\\\n                  var x1y1 = minimap[y1c*20 + x1c]*mult\\\\n                  var x2y1 = minimap[y1c*20 + x2c]*mult\\\\n                  \\\\n                  var x1y2 = minimap[y2c*20 + x1c]*mult\\\\n                  var x2y2 = minimap[y2c*20 + x2c]*mult\\\\n              \\\\n                  map3[500*k + i] = (x1y1*(25-i%25)/25*(25-k%25)/25 + x2y1*(i%25)/25*(25-k%25)/25 + x1y2*(25-i%25)/25*(k%25)/25 + x2y2*(i%25)/25*(k%25)/25)\\\\n                  \\\\n          }\\\\n      }\\\\n      \\\\n  \\\\n  \\\\n  }\\\\n\\\\n  function vlookup(value, rangeArr) {\\\\n    var ans = 15\\\\n    for(var i = 0; i < 13; i++) {\\\\n        if(value >= rangeArr[i][0] && value < rangeArr[i+1][0]) {\\\\n            ans = rangeArr[i][1];\\\\n        }\\\\n    }\\\\n    return ans\\\\n  }\\\\n  \\\\n\\\\n\\\\n\\\\n\\\\n \\\\n\\\\n    // worldgen - return a heightmap for a given [x,z]\\\\n  function getHeightMap(x, z, xsize, zsize) {\\\\n\\\\n      var xm = x % xsize\\\\n      var zm = z % zsize\\\\n      var hhh = map3[(zm*zsize+xm)]\\\\n      return hhh \\\\n  }\\\\n\\\\n\\\\n  function generateWorld( chunk, x, y, z ) {\\\\n    //console.log(window.location.href)\\\\n    // defer execution if block data has not arrived yet\\\\n    if (!initted) {\\\\n      setTimeout(function() { generateWorld(chunk,x,y,z) }, 500)\\\\n      return\\\\n    }\\\\n\\\\n    // populate chunk. xyz is the origin of the chunk in world coords\\\\n    var dx = chunk.shape[0]\\\\n    var dy = chunk.shape[1]\\\\n    var dz = chunk.shape[2]\\\\n\\\\n    for (var i=0; i<dx; ++i) {\\\\n      for (var k=0; k<dz; ++k) {\\\\n        // simple heightmap across x/z\\\\n        \\\\n        var height = getHeightMap(x + i, z + k, 500, 500)\\\\n\\\\n        for (var j=0; j<dy; ++j) {\\\\n          \\\\n          var add_id = decideBlockID2( x+i, y+j, z+k, height )\\\\n          var id = decideBlockID( x+i, y+j, z+k, height )\\\\n          if (add_id !== 0) chunk.set( i,j,k, add_id )\\\\n          if (id !== 0) chunk.set( i,j,k, id )\\\\n          \\\\n        }\\\\n        // possibly add a tree at this x/z coord\\\\n        if (height>5){\\\\n          tree(chunk, x, y, z, height, i, k)\\\\n        }\\\\n      }\\\\n    }\\\\n\\\\n    return chunk\\\\n  }\\\\n\\\\n\\\\n  function decideBlockID2(x, y, z, cloudLevel){\\\\n    //flowers\\\\n    /*\\\\n    \\\\n     if (y==cloudLevel && y<(dim[2])*mult && y>dim[1]*mult-1) {\\\\n      var h = hash(x,z)\\\\n      if (floor(h*10)===0) return flowerID//;\\\\n    } */\\\\n\\\\n    if (y==cloudLevel && y<(dim[2])*mult && y>dim[1]*mult-1) {\\\\n      var h = hash(x,z)\\\\n      if (floor(h*10)===0) return treasureID//;\\\\n    } \\\\n\\\\n    //plants\\\\n    for(var i = 0; i < 5; i++){\\\\n      if (y==cloudLevel && y<(dim[3])*mult && y>dim[0]*mult) {\\\\n        var h = Math.floor(hash(x,y,z,i)*20)\\\\n        //console.log(h)\\\\n        if (h==0) return obSet[i];//this[\\\\\\\"plant\\\\\\\"+i+\\\\\\\"ID\\\\\\\"];\\\\n      }\\\\n    } \\\\n\\\\n    // clouds\\\\n    if (y < cloudLevel || y<dim[3]*mult +1) return 0\\\\n    var cloud = simplex.noise3D(x/cloudXZ, y/cloudY, z/cloudXZ)\\\\n    if (y<cloudLevel+20) cloud *= (y-cloudLevel)/20\\\\n    if (cloud > cloudCutoff) return cloudID\\\\n\\\\n  }\\\\n\\\\n  function decideBlockID(x, y, z, groundLevel) {\\\\n    \\\\n    var s = getOverlay(x,y,z)\\\\n    if (s>-1) return s\\\\n  \\\\n   \\\\n    if (y < groundLevel) {\\\\n      if (y < dim[1] * mult){\\\\n         return sandID\\\\n      }else if (y <  dim[2] *mult) {\\\\n        return grassID\\\\n          \\\\n       \\\\n      }else if (y <  dim[3] * mult) {\\\\n        return dirtID\\\\n      }else if (y < 14.8 * mult) {\\\\n        return dirtID\\\\n      }else{\\\\n        return stoneID\\\\n      }   \\\\n    } else {\\\\n        if (y > dim[0] * mult) return 0\\\\n        // alternate by depth between two different water IDs\\\\n        return  waterID\\\\n    }\\\\n   \\\\n   \\\\n\\\\n    \\\\n\\\\n\\\\n  }\\\\n\\\\n\\\\n  // possibly overlay a columnar tree at a given i,k\\\\n  function tree(chunk, xoff, yoff, zoff, height, i, k) {\\\\n    // no trees at/near water level\\\\n    if (height <= waterLevel) return\\\\n    \\\\n    // leave if chunk is above/below tree height\\\\n    var js = chunk.shape[1]\\\\n    var treelo = height\\\\n    var treemax = treelo + 20\\\\n    if (yoff>treemax || yoff+js<treelo) return\\\\n\\\\n    // don't build at chunk border for now\\\\n    var border = 5\\\\n    if (i<border || k<border) return\\\\n    var is = chunk.shape[0]\\\\n    var ks = chunk.shape[2]\\\\n    if (i>is-border || k>ks-border) return\\\\n\\\\n    // sparse trees\\\\n    var x = xoff + i\\\\n    var z = zoff + k\\\\n    var thash = hash(x, z)\\\\n    if (floor(300*thash)!==0) return\\\\n\\\\n    // build the treetrunk\\\\n    var treehi = treelo + 6 + floor(6*hash(x,z,1))\\\\n    for (var y=treelo; y<treehi; ++y) {\\\\n      var j = y-yoff\\\\n      if (j<0 || j>=js) continue\\\\n      chunk.set( i,j,k, woodID );\\\\n    }\\\\n\\\\n    // spherical-ish foliage\\\\n    for (var ci=-3; ci<=3; ++ci) { \\\\n      for (var cj=-3; cj<=3; ++cj) { \\\\n        for (var ck=-3; ck<=3; ++ck) {\\\\n          var tj = treehi + cj - yoff\\\\n          if (ci===0 && ck===0 && cj<0) continue\\\\n          if (tj<0 || tj>=js) continue\\\\n          var rad = ci*ci + cj*cj + ck*ck\\\\n          if (rad>15) continue\\\\n          if (rad>5) {\\\\n            if (rad*hash(x+z+tj,ci,ck,cj) < 6) continue;\\\\n          }\\\\n          chunk.set( i+ci, tj, k+ck, leafID );\\\\n        }\\\\n      }\\\\n    }\\\\n  }\\\\n\\\\n\\\\n}\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n\\\\n//# sourceURL=webpack:///./src/lib/worldgen_worker.js?\\\");\\n\\n/***/ })\\n\\n/******/ });\", null);\n};\n\n//# sourceURL=webpack:///./src/lib/worldgen_worker.js?");

/***/ }),

/***/ "./src/lib/zoom.js":
/*!*************************!*\
  !*** ./src/lib/zoom.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n\nmodule.exports = function (game) {\n    var state = game.inputs.state\n\n\n    // settings\n    var max = 12 // this should be an option somewhere, surely?\n    var min = 0\n    game.rendering._cameraZoomSpeed = 0.15\n\n    // state\n    var zoom = 0\n    var lastZoomSet = max\n\n\n    // bind F to swap 1s/3rd person cameras\n    game.inputs.bind('swapCamera', 'F')\n    game.inputs.down.on('swapCamera', function () {\n        zoom = (zoom > min) ? min : lastZoomSet\n        game.rendering.zoomDistance = zoom\n    })\n\n\n    // scroll camera zoom on shift+mousewheel\n    game.on('tick', function (dt) {\n        if (state.scrolly !== 0) {\n            // zoom camera\n            zoom += (state.scrolly > 0) ? 1 : -1\n            if (zoom < min) zoom = min\n            if (zoom > max) zoom = max\n            game.rendering.zoomDistance = zoom\n            // remember for 1p/3p swaps\n            lastZoomSet = (zoom > min) ? zoom : Math.round(max / 2)\n        }\n    })\n\n\n}\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/lib/zoom.js?");

/***/ })

/******/ });